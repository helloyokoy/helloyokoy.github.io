<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2018-01-23T09:20:05+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objc 高阶函数]]></title>
    <link href="http://helloyokoy.github.io/blog/objc-higher-order-function/"/>
    <updated>2018-01-21T17:27:29+08:00</updated>
    <id>http://helloyokoy.github.io/blog/objc-higher-order-function</id>
    <content type="html"><![CDATA[<blockquote>
  <p>前段时间一直在写 swift, 最近 又来写 Objc ,发现 语法确实是差了点,表现力不足,  缺乏高阶函数,  这不 自力更生 写了一个~</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#pragma mark - Map, filter, reduce, flatMap function without class restrictor
</span><span class="line">- (NSArray *)map:(id (^)(id obj))block {
</span><span class="line">    NSMutableArray *mutableArray = [NSMutableArray new];
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        [mutableArray addObject:block(obj)];
</span><span class="line">    }];
</span><span class="line">    return mutableArray;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (NSArray *)filter:(BOOL (^)(id obj))block {
</span><span class="line">    NSMutableArray *mutableArray = [NSMutableArray new];
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if (block(obj) == YES) {
</span><span class="line">            [mutableArray addObject:obj];
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return mutableArray;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (id)reduce:(id)initial
</span><span class="line">       block:(id (^)(id obj1, id obj2))block {
</span><span class="line">    __block id obj = initial;
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id _obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        obj = block(obj, _obj);
</span><span class="line">    }];
</span><span class="line">    return obj;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (NSArray *)flatMap:(id (^)(id obj))block {
</span><span class="line">    NSMutableArray *mutableArray = [NSMutableArray new];
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        id _obj = block(obj);
</span><span class="line">        if ([_obj isKindOfClass:[NSArray class]]) {
</span><span class="line">            NSArray *_array = [_obj flatMap:block];
</span><span class="line">            [mutableArray addObjectsFromArray:_array];
</span><span class="line">            return;
</span><span class="line">        }
</span><span class="line">        [mutableArray addObject:_obj];
</span><span class="line">    }];
</span><span class="line">    return mutableArray;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (BOOL)contains:(BOOL (^)(id obj))block {
</span><span class="line">    __block BOOL contains = NO;
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if (block(obj) == YES) {
</span><span class="line">            contains = YES;
</span><span class="line">            *stop = YES;
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return contains;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (void)forEach:(void (^)(id obj))block {
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        block(obj);
</span><span class="line">    }];
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>下面这个是 筛选 nsarray 对象类型</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#pragma mark - Map, filter, reduce, flatMap function with class restrictor
</span><span class="line">- (NSArray *)map:(id (^)(id obj))block
</span><span class="line">           class:(Class)aClass {
</span><span class="line">    NSMutableArray *mutableArray = [NSMutableArray new];
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if ([obj isKindOfClass:aClass]) {
</span><span class="line">            [mutableArray addObject:block(obj)];
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return mutableArray;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (NSArray *)filter:(BOOL (^)(id obj))block
</span><span class="line">              class:(Class)aClass {
</span><span class="line">    NSMutableArray *mutableArray = [NSMutableArray new];
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if ([obj isKindOfClass:aClass] &amp;&amp;
</span><span class="line">            block(obj) == YES) {
</span><span class="line">            [mutableArray addObject:obj];
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return mutableArray;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (id)reduce:(id)initial
</span><span class="line">       block:(id (^)(id obj1, id obj2))block
</span><span class="line">       class:(Class)aClass {
</span><span class="line">    __block id obj = initial;
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id _obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if ([obj isKindOfClass:aClass] &amp;&amp;
</span><span class="line">            [_obj isKindOfClass:aClass]) {
</span><span class="line">            obj = block(obj, _obj);
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return obj;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (NSArray *)flatMap:(id (^)(id obj))block
</span><span class="line">               class:(Class)aClass {
</span><span class="line">    NSMutableArray *mutableArray = [NSMutableArray new];
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        id _obj = block(obj);
</span><span class="line">        if ([_obj isKindOfClass:[NSArray class]]) {
</span><span class="line">            NSArray *_array = [_obj flatMap:block
</span><span class="line">                                      class:aClass];
</span><span class="line">            [mutableArray addObjectsFromArray:_array];
</span><span class="line">            return;
</span><span class="line">        }
</span><span class="line">
</span><span class="line">        if ([_obj isKindOfClass:aClass]) {
</span><span class="line">            [mutableArray addObject:_obj];
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return mutableArray;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (BOOL)contains:(BOOL (^)(id obj))block
</span><span class="line">           class:(Class)aClass {
</span><span class="line">    __block BOOL contains = NO;
</span><span class="line">
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if (![obj isKindOfClass:aClass]) {
</span><span class="line">            return;
</span><span class="line">        }
</span><span class="line">
</span><span class="line">        if (block(obj) == YES) {
</span><span class="line">            contains = YES;
</span><span class="line">            *stop = YES;
</span><span class="line">        }
</span><span class="line">    }];
</span><span class="line">    return contains;
</span><span class="line">}
</span><span class="line">
</span><span class="line">- (void)forEach:(void (^)(id obj))block
</span><span class="line">          class:(Class)aClass {
</span><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class="line">        if (![obj isKindOfClass:aClass]) {
</span><span class="line">            return;
</span><span class="line">        }
</span><span class="line">        block(obj);
</span><span class="line">    }];
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS BLE]]></title>
    <link href="http://helloyokoy.github.io/blog/ios-ble/"/>
    <updated>2017-10-22T10:08:24+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ios-ble</id>
    <content type="html"><![CDATA[<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/94746767.jpg" alt="" /></p>

<h2 id="ble">BLE</h2>

<blockquote>
  <p>BLE是蓝牙低能耗的简称（Bluetooh Low Energy）。蓝牙低能耗(BLE)技术是低成本、短距离、可互操作的鲁棒性无线技术，工作在免许可的2.4GHz ISM射频频段。它从一开始就设计为超低功耗(ULP)无线技术。它利用许多智能手段最大限度地降低功耗</p>
</blockquote>

<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/47797739.jpg" alt="" /></p>

<ul>
  <li>GATT:Generic Attribute Profile</li>
  <li>ATT: Attribute Protocol</li>
  <li>L2CAP: Logical Link Control and Adaptation Protocol</li>
</ul>

<!--more-->

<h2 id="corebluetooth">CoreBlueTooth</h2>

<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/79935884.jpg" alt="" /></p>

<ul>
  <li>CBCentralManager - 中心设备管理，用于搜索周边设备，对应CBPeripheral使用</li>
  <li>
    <p>CBPeripheralManager - 周边设备管理，用于作为周边设备，对应CBCentral使用</p>
  </li>
  <li>CBPeripheral - 周边设备</li>
  <li>
    <p>CBCentral - 中心设备</p>
  </li>
  <li>CBService - 设备 服务</li>
  <li>CBCharacteristic - 设备 服务 特征</li>
  <li>
    <p>CBDescriptor - 设备 服务 特征 描述</p>
  </li>
  <li>CBError - 错误</li>
  <li>CBUUID - 唯一码</li>
  <li>CBAdvertisementData - 广播包</li>
  <li>CBATTRequest - ATT请求</li>
</ul>

<h3 id="cbcentralmanager">CBCentralManager</h3>

<p>初始化 manager</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">self.centerManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
</span><span class="line">    // [self.centerManager stopScan];  可以停止扫描
</span><span class="line">
</span><span class="line">    - (void)centralManagerDidUpdateState:(CBCentralManager *)central {
</span><span class="line">    if (central.state == CBCentralManagerStatePoweredOn) {
</span><span class="line">        NSLog(@"蓝牙 - 打开");
</span><span class="line">        // 开始扫描，周边设备
</span><span class="line">        [self.centerManager scanForPeripheralsWithServices:nil options:nil];
</span><span class="line">    } else {
</span><span class="line">        NSLog(@"蓝牙 异常,其他状态自行判断");
</span><span class="line">    }
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    - (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict {
</span><span class="line">        NSLog(@"%@",dict);
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI {
</span><span class="line">    if (peripheral.name) {
</span><span class="line">        NSLog(@"扫描到设备 %@",peripheral.name);
</span><span class="line">    }
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>调用连接设备</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[self.centerManager connectPeripheral:currentPer options:nil];                       
</span><span class="line">    currentPer.delegate = self;
</span><span class="line">
</span><span class="line">    - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral {
</span><span class="line">        NSLog(@"链接成功");
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    - (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"链接失败");
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"设备断开链接");
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="cbperipheral">CBPeripheral</h3>

<p>扫描 设备的某些 UUID 的服务</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[currentPer discoverServices:@[@"UUID"]];
</span><span class="line">
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",service.UUID);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>扫描 设备的某服务的 UUID 服务</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[currentPer discoverIncludedServices:@[] forService:service];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(NSError *)error {
</span><span class="line">        NSLog(@"%@",service.UUID);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>扫描 设备的某个服务中的 UUID 特性</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral discoverCharacteristics:@[] forService:peripheral.services.lastObject];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",service.characteristics);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>扫描 设备的某个特征 UUID</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral discoverDescriptorsForCharacteristic:peripheral.services.lastObject.characteristics.lastObject];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",characteristic);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>获取设备 蓝牙信号强度</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral readRSSI];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didReadRSSI:(NSNumber *)RSSI error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",RSSI.stringValue);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>读取 特征</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral readValueForCharacteristic:peripheral.services.lastObject.characteristics.lastObject];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {
</span><span class="line">        NSLog(@"%@",characteristic);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>写入 特征</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral writeValue:[NSData data] forCharacteristic:peripheral.services.lastObject.characteristics.lastObject type:CBCharacteristicWriteWithResponse];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",characteristic);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>读取 描述</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral readValueForDescriptor:peripheral.services.lastObject.characteristics.lastObject.descriptors.lastObject];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",descriptor);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>写入描述</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral writeValue:[NSData data] forDescriptor:peripheral.services.lastObject.characteristics.lastObject.descriptors.lastObject];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",descriptor);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>添加 监听</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[peripheral setNotifyValue:YES forCharacteristic:peripheral.services.lastObject.characteristics.lastObject];
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error {
</span><span class="line">        NSLog(@"%@",characteristic);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其他</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">// 最大数据量？
</span><span class="line">    NSLog(@"%zi",[peripheral maximumWriteValueLengthForType:CBCharacteristicWriteWithResponse]);
</span><span class="line">    
</span><span class="line">    // 修改 名称
</span><span class="line">    - (void)peripheralDidUpdateName:(CBPeripheral *)peripheral {
</span><span class="line">    NSLog(@"%@",peripheral);
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    // 修改 服务
</span><span class="line">    - (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray&lt;CBService *&gt; *)invalidatedServices {
</span><span class="line">    NSLog(@"%@",peripheral);
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    // 修改 RSSI
</span><span class="line">    - (void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(nullable NSError *)error {
</span><span class="line">    NSLog(@"%@",peripheral.RSSI.stringValue);
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS TDD&amp;BDD]]></title>
    <link href="http://helloyokoy.github.io/blog/ios-tdd-and-bdd/"/>
    <updated>2017-06-14T10:37:14+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ios-tdd-and-bdd</id>
    <content type="html"><![CDATA[<h2 id="tdd">TDD</h2>

<p>Test Drive Development</p>

<ul>
  <li>有利于更加专注软件设计；</li>
  <li>清晰地了解软件的需求；</li>
  <li>很好的诠释了代码即文档。</li>
</ul>

<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/95570113.jpg" alt="TDD" /></p>

<blockquote>
  <p>TDD是一种相对于普通思维的方式来说，比较极端的一种做法。我们一般能想到的是先编写业务代码，然后为其编写测试代码，用来验证产品方法是不是按照设计工作。而TDD的思想正好与之相反，在TDD的世界中，我们应该首先根据需求或者接口情况编写测试，然后再根据测试来编写业务代码，而这其实是违反传统软件开发中的先验认知的.</p>
</blockquote>

<p>我们可以举一个生活中类似的例子来说明TDD的必要性：有经验的砌砖师傅总是会先拉一条垂线，然后沿着线砌砖，因为有直线的保证，因此可以做到笔直整齐；而新入行的师傅往往二话不说直接开工，然后在一阶段完成后再用直尺垂线之类的工具进行测量和修补。</p>

<p>TDD的好处不言自明，因为总是先测试，再编码，所以至少你的所有代码的public部分都应该含有必要的测试。另外，因为测试代码实际是要使用产品代码的，因此在编写产品代码前你将有一次深入思考和实践如何使用这些代码的机会，这对提高设计和可扩展性有很好的帮助，试想一下你测试都很难写的接口，别人（或者自己）用起来得多纠结。在测试的准绳下，你可以有目的有方向地编码；另外，因为有测试的保护，你可以放心对原有代码进行重构，而不必担心破坏逻辑。这些其实都指向了一个最终的目的：让我们快乐安心高效地工作。</p>

<!--more-->

<h2 id="bdd">BDD</h2>

<blockquote>
  <p>Behavior Drive Development</p>
</blockquote>

<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/45991035.jpg" alt="DBB" /></p>

<p>XCTest(作者注:苹果官方测试框架)是基于OCUnit的传统测试框架，在书写性和可读性上都不太好。在测试用例太多的时候，由于各个测试方法是割裂的，想在某个很长的测试文件中找到特定的某个测试并搞明白这个测试是在做什么并不是很容易的事情。所有的测试都是由断言完成的，而很多时候断言的意义并不是特别的明确，对于项目交付或者新的开发人员加入时，往往要花上很大成本来进行理解或者转换。另外，每一个测试的描述都被写在断言之后，夹杂在代码之中，难以寻找。使用XCTest测试另外一个问题是难以进行mock或者stub，而这在测试中是非常重要的一部分。</p>

<blockquote>
  <p>行为驱动开发（BDD）正是为了解决上述问题而生的，作为第二代敏捷方法，BDD提倡的是通过将测试语句转换为类似自然语言的描述，开发人员可以使用更符合大众语言的习惯来书写测试，这样不论在项目交接/交付，或者之后自己修改时，都可以顺利很多</p>
</blockquote>

<p>如果说作为开发者的我们日常工作是写代码，那么BDD其实就是在讲故事。一个典型的BDD的测试用例包活完整的三段式上下文，测试大多可以翻译为Given..When..Then的格式，读起来轻松惬意。BDD在其他语言中也已经有一些框架，包括最早的Java的JBehave和赫赫有名的Ruby的RSpec和Cucumber。而在objc社区中BDD框架也正在欣欣向荣地发展，得益于objc的语法本来就非常接近自然语言，再加上C语言宏的威力，我们是有可能写出漂亮优美的测试的。在objc中，现在比较流行的BDD框架有cedar，specta和Kiwi。</p>

<h2 id="quick--nimble-in-swift">Quick + Nimble In Swift</h2>

<p><a href="https://github.com/Quick/Quick">https://github.com/Quick/Quick</a></p>

<pre><code>// Swift
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import Quick
</span><span class="line">	import Nimble
</span><span class="line">
</span><span class="line">	class TableOfContentsSpec: QuickSpec {
</span><span class="line">  	override func spec() {
</span><span class="line">    	describe("the 'Documentation' directory") {
</span><span class="line">      it("has everything you need to get started") {
</span><span class="line">        let sections = Directory("Documentation").sections
</span><span class="line">        expect(sections).to(contain("Organized Tests with Quick 	Examples and Example Groups"))
</span><span class="line">        expect(sections).to(contain("Installing Quick"))
</span><span class="line">      }
</span><span class="line">
</span><span class="line">      context("if it doesn't have what you're looking for") {
</span><span class="line">        it("needs to be updated") {
</span><span class="line">          let you = You(awesome: true)
</span><span class="line">          expect{you.submittedAnIssue}.toEventually(beTruthy())
</span><span class="line">        }
</span><span class="line">      	}
</span><span class="line">    }
</span><span class="line">  	}
</span><span class="line">	}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="nimble">Nimble</h2>

<p><a href="https://github.com/Quick/Nimble">https://github.com/Quick/Nimble</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Swift
</span><span class="line">	expect(1 + 1).to(equal(2))
</span><span class="line">	expect(1.2).to(beCloseTo(1.1, within: 0.1))
</span><span class="line">	expect(3) &gt; 2
</span><span class="line">	expect("seahorse").to(contain("sea"))
</span><span class="line">	expect(["Atlantic", "Pacific"]).toNot(contain("Mississippi"))
</span><span class="line">	expect(ocean.isClean).toEventually(beTruthy())</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="specta">Specta</h2>
<p><a href="https://github.com/specta/specta">https://github.com/specta/specta</a></p>

<p>A light-weight TDD / BDD framework for Objective-C.</p>

<p>FEATURES</p>

<ul>
  <li>An Objective-C RSpec-like BDD DSL</li>
  <li>Quick and easy set up</li>
  <li>Built on top of XCTest</li>
  <li>Excellent Xcode integration</li>
</ul>

<h2 id="specta-bdd-dsl">Specta BDD DSL</h2>

<ol>
  <li>SpecBegin 声明了一个测试类，SpecEnd 结束了类声明</li>
  <li>describe (context) 块声明了一组实例</li>
  <li>it (example/specify) 是一个单一的例子</li>
  <li>beforeAll 是一个运行于所有同级块之前的块，只运行一次。afterAll 与beforeAll相反，是在所有同级块之后运行的块，只运行一次。</li>
  <li>beforeEach/afterEach，在每个同级块运行的时候，都会运行一次，而beforeAll/afterAll只会运行一次</li>
  <li>it/waitUntil/done()，异步调用，注意完成异步操作之后，必须调用done()函数，如下：</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	     it(@"should do some stuff asynchronously", ^{
</span><span class="line">        waitUntil(^(DoneCallback done) {
</span><span class="line">        // Async example blocks need to invoke done()     callback.
</span><span class="line">        done();
</span><span class="line">        });
</span><span class="line">  	     });</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="expecta">Expecta</h2>

<p><a href="https://github.com/specta/expecta">https://github.com/specta/expecta</a></p>

<p>A matcher framework for Objective-C and Cocoa.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	waitUntil(^(DoneCallback done) {
</span><span class="line">            //query
</span><span class="line">            [manager getSedentaryDataModels:^(NSArray &lt; DMSedentaryDataModel * &gt; *modelList) {
</span><span class="line">                tempModel = modelList.firstObject;
</span><span class="line">                expect(modelList.count).to.equal(1);
</span><span class="line">                done();
</span><span class="line">            }];
</span><span class="line">        });
</span><span class="line">        expect(tempModel).notTo.beNil();
</span><span class="line">        expect(tempModel.prKey).notTo.equal(0);</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="ocmock">OCMock</h2>
<p><a href="http://ocmock.org/reference/#creating-mock-objects">http://ocmock.org/reference/#creating-mock-objects</a></p>

<ul>
  <li>Creating mock objects</li>
  <li>Stubbing methods</li>
  <li>Verifying interactions</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	      __block id mockConnection = nil;
</span><span class="line">    
</span><span class="line">        beforeAll(^{
</span><span class="line">        
</span><span class="line">        });
</span><span class="line">    
</span><span class="line">        afterAll(^{
</span><span class="line">        
</span><span class="line">        });
</span><span class="line">    
</span><span class="line">        beforeEach(^{
</span><span class="line">        mockConnection = OCMClassMock([TwitterConnection class]);
</span><span class="line">        });
</span><span class="line">    
</span><span class="line">        afterEach(^{
</span><span class="line">        [mockConnection stopMocking];
</span><span class="line">        });
</span><span class="line">    
</span><span class="line">        it(@"is should be success", ^{
</span><span class="line">        
</span><span class="line">        TwitterViewController *controller = [[TwitterViewController alloc] init];
</span><span class="line">        controller.connection = mockConnection;
</span><span class="line">        
</span><span class="line">        //模拟fetchTweets方法返回预设值
</span><span class="line">        Tweet *testTweet = [[Tweet alloc] init];
</span><span class="line">        testTweet.userName = @"齐滇大圣";
</span><span class="line">        Tweet *testTweet2 = [[Tweet alloc] init];
</span><span class="line">        testTweet2.userName = @"美猴王";
</span><span class="line">        NSArray *tweetArray = @[testTweet,testTweet2];
</span><span class="line">        OCMStub([mockConnection fetchTweets]).andReturn(tweetArray);
</span><span class="line">        
</span><span class="line">        //模拟出来一个view类
</span><span class="line">        id mockView = OCMClassMock([TweetView class]);
</span><span class="line">        controller.tweetView = mockView;
</span><span class="line">        
</span><span class="line">        //这里执行updateTweetView之后，[mockView addTweet:]加入了testTweet和testTweet2
</span><span class="line">        [controller updateTweetView];
</span><span class="line">        
</span><span class="line">        OCMVerify([mockView addTweet:testTweet]);
</span><span class="line">        OCMVerify([mockView addTweet:testTweet2]);
</span><span class="line">        OCMVerify([mockView addTweet:[OCMArg any]]);</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="slather">Slather</h2>
<p><a href="https://github.com/SlatherOrg/slather">https://github.com/SlatherOrg/slather</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	source ~/.bash_profile
</span><span class="line">	cd ${SRCROOT}
</span><span class="line">	rm -rf  ${SRCROOT}/slather-html
</span><span class="line">	slather coverage --html --output-directory  ${SRCROOT}/slather-html --scheme DeviceManager --workspace ${SRCROOT}/DeviceManager.xcworkspace ${SRCROOT}/DeviceManager.xcodeproj
</span><span class="line">	open 'slather-html/index.html'</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Runtime & libObjc]]></title>
    <link href="http://helloyokoy.github.io/blog/ios-runtime-and-libobjc/"/>
    <updated>2017-05-11T19:57:20+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ios-runtime-and-libobjc</id>
    <content type="html"><![CDATA[<h2 id="runtime">Runtime</h2>

<blockquote>
  <p>Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统(runtime system) 来执行编译后的代码。这就是 Objective-C Runtime.
RunTime简称运行时。OC就是运行时机制，其中最主要的是消息机制。对于C语言，函数的调用在编译的时候会决定调用哪个函数。对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</p>
</blockquote>

<p>Runtime基本是用C和汇编写的，苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p>

<ul>
  <li><a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a></li>
  <li><a href="https://github.com/RetVal/objc-runtime">https://github.com/RetVal/objc-runtime</a></li>
</ul>

<h2 id="id--class">id &amp; Class</h2>

<p>define id&amp;class</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	typedef struct objc_class *Class;
</span><span class="line">	typedef struct objc_object *id;
</span><span class="line">	struct objc_object {
</span><span class="line">    	Class isa;
</span><span class="line">	};
</span><span class="line">	struct objc_class {
</span><span class="line">    	Class isa;
</span><span class="line">	}
</span><span class="line">	/// 不透明结构体, selector
</span><span class="line">	typedef struct objc_selector *SEL;
</span><span class="line">	/// 函数指针, 用于表示对象方法的实现
</span><span class="line">	typedef id (*IMP)(id, SEL, ...);</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="define">Define</h2>

<ul>
  <li>对对象进行操作的方法一般以object_开头</li>
  <li>对类进行操作的方法一般以class_开头</li>
  <li>对类或对象的方法进行操作的方法一般以method_开头</li>
  <li>对成员变量进行操作的方法一般以ivar_开头</li>
  <li>对属性进行操作的方法一般以property_开头</li>
  <li>对协议进行操作的方法一般以protocol_开头</li>
</ul>

<p>根据以上的函数的前缀 可以大致了解到层级关系。对于以objc_开头的方法，则是runtime最终的管家，可以获取内存中类的加载信息,类的列表，关联对象和关联属性等操作。</p>

<h2 id="important-method">important method</h2>

<pre><code>objc_copyClassList

class_copyIvarList

class_copyPropertyList
</code></pre>

<blockquote>
  <p>ivarList可以获取到@property关键字定义的属性 ，而propertyList不可以获取到成员变量。使用ivarList是可以将所有的成员变量和属性都获取的。</p>
</blockquote>

<pre><code>+ (BOOL)resolveClassMethod:(SEL)sel 
+ (BOOL)resolveInstanceMethod:(SEL)sel

class_addIvar

class_addMethod
</code></pre>

<!--more-->

<h2 id="nscoding-default-implement">NSCoding default implement</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	- (void)encodeWithCoder:(NSCoder *)aCoder {
</span><span class="line">    unsigned int count = 0;
</span><span class="line">    Ivar *ivars = class_copyIvarList(self.class, &amp;count);
</span><span class="line">    for (int i = 0; i &lt; count; i++) {
</span><span class="line">        const char *cname = ivar_getName(ivars[i]);
</span><span class="line">        NSString *name = [NSString stringWithUTF8String:cname];
</span><span class="line">        NSString *key = [name substringFromIndex:1];
</span><span class="line">        
</span><span class="line">        id value = [self valueForKey:key]; // KVC隐性数据转换
</span><span class="line">        [aCoder encodeObject:value forKey:key]; // 编码
</span><span class="line">    	}
</span><span class="line">	}
</span><span class="line">	- (id)initWithCoder:(NSCoder *)aDecoder {
</span><span class="line">    if (self = [super init]) {
</span><span class="line">        unsigned int count = 0;
</span><span class="line">        Ivar *ivars = class_copyIvarList(self.class, &amp;count);
</span><span class="line">        for (int i = 0; i &lt; count; i++) {
</span><span class="line">            const char *cname = ivar_getName(ivars[i]);
</span><span class="line">            NSString *name = [NSString stringWithUTF8String:cname];
</span><span class="line">            NSString *key = [name substringFromIndex:1];
</span><span class="line">            
</span><span class="line">            id value = [aDecoder decodeObjectForKey:key]; // 解码
</span><span class="line">            [self setValue:value forKey:key]; // KVC隐性数据转换
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    return self;    
</span><span class="line">	}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="add-method-dynamic">Add method Dynamic</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	void abc(id self, SEL _cmd){
</span><span class="line">    NSLog(@"%@说了hello", [self name]);
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	@implementation Person
</span><span class="line">
</span><span class="line">	//动态添加方法：在resolve中添加相应的方法，注意是类方法还是对象方法。
</span><span class="line">	+ (BOOL)resolveInstanceMethod:(SEL)sel
</span><span class="line">	{
</span><span class="line">    if ([NSStringFromSelector(sel) isEqualToString:@"sayHi"]) {
</span><span class="line">        class_addMethod(self, sel, abc, "v@:"); // 为sel指定实现为abc
</span><span class="line">    }
</span><span class="line">    return YES;
</span><span class="line">	}
</span><span class="line">	@end</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="add-class-dynamic">Add Class Dynamic</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	// 添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型
</span><span class="line">    if (class_addIvar(classStudent, "schoolName", sizeof(NSString *), 0, "@")) {
</span><span class="line">        NSLog(@"添加成员变量schoolName成功");
</span><span class="line">    }
</span><span class="line">    // 为Student类添加方法 "v@:"这种写法见参数类型连接
</span><span class="line">    if (class_addMethod(classStudent, @selector(printSchool), (IMP)printSchool, "v@:")) {
</span><span class="line">        NSLog(@"添加方法printSchool:成功");
</span><span class="line">    }
</span><span class="line">    // 注册这个类到runtime系统中就可以使用他了
</span><span class="line">    objc_registerClassPair(classStudent); // 返回void
</span><span class="line">    // 使用创建的类
</span><span class="line">    id student = [[classStudent alloc] init];
</span><span class="line">    NSString *schoolName = @"清华大学";
</span><span class="line">    [student setValue:schoolName forKey:@"schoolName"];
</span><span class="line">    [student performSelector:@selector(printSchool) withObject:nil]; // 动态调用未显式在类中声明的方法</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="associatedobjectcategory">AssociatedObject&amp;Category</h2>

<ul>
  <li>objc_setAssociatedObject</li>
  <li>objc_getAssociatedObject</li>
  <li>objc_removeAssociatedObjects</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">		enum {
</span><span class="line">   		OBJC_ASSOCIATION_ASSIGN = 0,
</span><span class="line">   		OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
</span><span class="line">   		OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
</span><span class="line">   		OBJC_ASSOCIATION_RETAIN = 01401,
</span><span class="line">   		OBJC_ASSOCIATION_COPY = 01403
</span><span class="line">		};</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Category       invoke order:   Category =&gt; self  =&gt; super</p>

<blockquote>
  <p>当同一个类的有多个Category时，调用同名方法，谁编译最后，谁就会被调用。最后编译的那个Category，其方法被放在了方法列表（无论是类里的实例方法列表还是元类里的类方法列表）的前面，当objc_msgSend查找方法时会优先找到了它。</p>
</blockquote>

<h2 id="message">message</h2>

<pre><code>[receiver message];
</code></pre>

<p>向receiver发送名为message的消息。</p>

<pre><code>clang -rewrite-objc MyClass.m
</code></pre>

<p>执行上面的命令，将这一句重写为C代码，是这样的：</p>

<pre><code>((void (*)(id, SEL))(void *)objc_msgSend)((id)receiver, sel_registerName("message"));
</code></pre>

<p>去掉那些强制转换，最终[receiver message]会由编译器转化为以下的纯C调用。</p>

<pre><code>objc_msgSend(receiver, @selector(message));
</code></pre>

<h2 id="method-forwarding">method forwarding</h2>
<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/43880704.jpg" alt="" /></p>

<p>_objc_msgForward消息转发做了如下几件事：</p>

<p>1.调用resolveInstanceMethod:方法，允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回。如果仍没实现，继续下面的动作。</p>

<p>2.调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接转发给它。如果返回了nil，继续下面的动作。</p>

<p>3.调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。</p>

<p>4.调用forwardInvocation:方法，将地3步获取到的方法签名包装成Invocation传入，如何处理就在这里面了。</p>

<p>上面这4个方法均是模板方法，开发者可以override，由runtime来调用。最常见的实现消息转发，就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。</p>

<p>如果直到NSObject，继承体系中的其它类都无法处理这个消息转发，就会由NSObject调用该方法，并在该方法中调用doesNotRecognizeSelector，以抛出异常。</p>

<h2 id="method-swizzling">method swizzling</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	+ (void)load {
</span><span class="line">    static dispatch_once_t onceToken;
</span><span class="line">    dispatch_once(&amp;onceToken, ^{
</span><span class="line">        Class class = [self class];
</span><span class="line">        SEL originalSelector = @selector(viewWillAppear:);
</span><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);
</span><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);
</span><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
</span><span class="line">        // 如果 swizzling 的是类方法, 采用如下的方式:
</span><span class="line">        // Class class = object_getClass((id)self);
</span><span class="line">        // ...
</span><span class="line">        // Method originalMethod = class_getClassMethod(class, originalSelector);
</span><span class="line">        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);
</span><span class="line">        //交换实现
</span><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);
</span><span class="line">    	});
</span><span class="line">	}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="thirdparty">ThirdParty</h2>

<p>Aspect</p>

<ul>
  <li><a href="https://github.com/steipete/Aspects">https://github.com/steipete/Aspects</a></li>
</ul>

<p>JsPatch</p>

<ul>
  <li><a href="https://github.com/bang590/JSPatch">https://github.com/bang590/JSPatch</a></li>
</ul>

<p>GYBootingProtection</p>

<ul>
  <li><a href="https://github.com/liuslevis/GYBootingProtection">https://github.com/liuslevis/GYBootingProtection</a></li>
</ul>

<h2 id="libextobjc">libExtObjc</h2>

<p>source code</p>

<ul>
  <li><a href="https://github.com/jspahrsummers/libextobjc">https://github.com/jspahrsummers/libextobjc</a></li>
  <li>Safe categories</li>
  <li>Concrete protocols</li>
  <li>Simpler and safer key paths</li>
  <li>Easier use of weak variables in blocks</li>
  <li>Scope-based resource cleanup</li>
  <li>Algebraic data types</li>
  <li>Block-based coroutines</li>
  <li>EXTNil</li>
  <li>Lots of extensions</li>
</ul>

<h2 id="swift-defer">swift defer</h2>

<p>defer 是 Swift 在 2.0 时代加入的一个关键字，它提供了一种非常安全并且简单的方法声明一个在作用域结束时执行的代码块。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!swift
</span><span class="line">	func hello() {
</span><span class="line">    defer {
</span><span class="line">        print("4")
</span><span class="line">    }
</span><span class="line">    if true {
</span><span class="line">        defer {
</span><span class="line">            print("2")
</span><span class="line">        }
</span><span class="line">        defer {
</span><span class="line">            print("1")
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    print("3")
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	hello()
</span><span class="line">	
</span><span class="line">output
</span><span class="line">   
</span><span class="line">	1  2  3  4</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="objc-implement-of-defer">Objc implement of defer</h2>

<p>libextobjc 实现的 defer 并没有基于 Objective-C 的动态特性，甚至也没有调用已有的任何方法，而是使用了 <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">Variable Attributes</a> 这一特性。同样在 GCC 中也存在用于修饰函数的 <a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">Function Attributes</a>.</p>

<p>Variable Attributes 其实是 GCC 中用于描述变量的一种修饰符。我们可以使用 <strong>attribute</strong> 来修饰一些变量来参与静态分析等编译过程；而在 Cocoa Touch 中很多的宏其实都是通过 <strong>attribute</strong> 来实现的，例如：</p>

<pre><code>#define NS_ROOT_CLASS __attribute__((objc_root_class))
</code></pre>

<p>而 <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#Common-Variable-Attributes#cleanup">cleanup</a> 就是在这里会使用的变量属性：
&gt;The cleanup attribute runs a function when the variable goes out of scope. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.</p>

<p>GCC 文档中对 Cleanup 属性的介绍告诉我们，在 cleanup 中必须传入只有一个参数的函数并且这个参数需要与变量的类型兼容。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!c
</span><span class="line">	void cleanup_block(int *a) {
</span><span class="line">    printf("%d\n", *a);
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	int variable __attribute__((cleanup(cleanup_block))) = 2;</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="onexit">onExit</h2>

<p>libextobjc 中并没有使用 defer 这个名字，而是使用了 onExit（表示代码是在退出作用域时执行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	#define onExit \
</span><span class="line">    ext_keywordify \
</span><span class="line">    __strong ext_cleanupBlock_t metamacro_concat(ext_exitBlock_, __LINE__) __attribute__((cleanup(ext_executeCleanupBlock), unused)) = ^</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>既然它只是一个宏，那么上面的代码其实是可以展开的</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">autoreleasepool {}
</span><span class="line">	__strong ext_cleanupBlock_t ext_exitBlock_19 	__attribute__((cleanup(ext_executeCleanupBlock), unused)) = ^ {
</span><span class="line">    NSLog("Log when out of scope.");
</span><span class="line">	};</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>ext_keywordify 也是一个宏定义，它通过添加在宏之前添加 autoreleasepool {} 强迫 onExit 前必须加上 @ 符号</p>

<pre><code>#define ext_keywordify autoreleasepool {}
</code></pre>

<p>ext_cleanupBlock_t 是一个类型：</p>

<pre><code>typedef void (^ext_cleanupBlock_t)(); metamacro_concat(ext_exitBlock_, __LINE__) 会将 ext_exitBlock 和当前行号拼接成一个临时的的变量名，例如：ext_exitBlock_19。

__attribute__((cleanup(ext_executeCleanupBlock), unused))  将 cleanup 函数设置为 ext_executeCleanupBlock；并将当前变量 ext_exitBlock_19 标记为 unused 来抑制 Unused variable 警告。
</code></pre>

<p>变量 ext_exitBlock_19 的值为 ^{ NSLog(“Log when out of scope.”); }，是一个类型为 ext_cleanupBlock_t 的 block。</p>

<p>在这个变量离开作用域时，会把上面的 block 的指针传入 cleanup 函数，也就是 ext_executeCleanupBlock：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void ext_executeCleanupBlock (__strong ext_cleanupBlock_t *block) 	{
</span><span class="line">    	(*block)();
</span><span class="line">	}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="corutinesyield">Corutines&amp;Yield</h2>

<p>TestCase</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	__block int i;
</span><span class="line">    int (^myCoroutine)(void) = coroutine(void)({
</span><span class="line">         for (i = 0;i &lt; 3;++i) {
</span><span class="line">                yield i;
</span><span class="line">            }
</span><span class="line">        });
</span><span class="line">    XCTAssertEqual(myCoroutine(), 0, @"expected first coroutine call to yield 0");
</span><span class="line">    XCTAssertEqual(myCoroutine(), 1, @"expected second coroutine call to yield 1");
</span><span class="line">    XCTAssertEqual(myCoroutine(), 2, @"expected third coroutine call to yield 2");
</span><span class="line">    XCTAssertEqual(myCoroutine(), 0, @"expected restarted coroutine call to yield 0");
</span><span class="line">    XCTAssertEqual(myCoroutine(), 1, @"expected second coroutine call to yield 1");
</span><span class="line">        
</span><span class="line">     myCoroutine = coroutine(void)({
</span><span class="line">            NSLog(@"invoke step 1");
</span><span class="line">            yield 5;
</span><span class="line">            NSLog(@"invoke step 2");
</span><span class="line">            yield 18;
</span><span class="line">            NSLog(@"invoke step 3");
</span><span class="line">     });
</span><span class="line">     XCTAssertEqual(myCoroutine(), 5, @"expected first coroutine call to yield 5");
</span><span class="line">     XCTAssertEqual(myCoroutine(), 18, @"expected second coroutine call to yield 18");
</span><span class="line">     XCTAssertEqual(myCoroutine(), 5, @"expected restarted coroutine call to yield 5");</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="corutinesyield-implement">Corutines&amp;Yield Implement</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	#define coroutine(...) \
</span><span class="line">    ^{ \
</span><span class="line">        __block unsigned long ext_coroutine_line_ = 0; \
</span><span class="line">        \
</span><span class="line">        return [ \
</span><span class="line">            ^(__VA_ARGS__) coroutine_body
</span><span class="line">            
</span><span class="line">    #define yield \
</span><span class="line">    if ((ext_coroutine_line_ = __LINE__) == 0) \
</span><span class="line">        case __LINE__: \
</span><span class="line">            ; \
</span><span class="line">    else \
</span><span class="line">        return
</span><span class="line">    #define coroutine_body(STATEMENT) \
</span><span class="line">            { \
</span><span class="line">                for (;; ext_coroutine_line_ = 0) \
</span><span class="line">                    switch (ext_coroutine_line_) \
</span><span class="line">                        default: \
</span><span class="line">                            STATEMENT \
</span><span class="line">            } \
</span><span class="line">        copy]; \
</span><span class="line">    }()</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="concrete-protocols">Concrete protocols</h2>

<p>TestCase</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	@protocol MyProtocol &lt;NSObject&gt;
</span><span class="line">	@concrete
</span><span class="line">	+ (NSUInteger)meaningfulNumber;
</span><span class="line">	- (NSString *)getSomeString;
</span><span class="line">	@end
</span><span class="line">	@protocol SubProtocol &lt;MyProtocol&gt;
</span><span class="line">	@concrete
</span><span class="line">	- (void)additionalMethod;
</span><span class="line">	@end
</span><span class="line">	@concreteprotocol(MyProtocol)
</span><span class="line">	+ (void)initialize {
</span><span class="line">    NSLog(@"  MyProtocol  +initialize should only be invoked once per 	concrete protocol");
</span><span class="line">	}
</span><span class="line">	+ (NSUInteger)meaningfulNumber {
</span><span class="line">    return 42;
</span><span class="line">	}
</span><span class="line">	- (NSString *)getSomeString {
</span><span class="line">    return @"MyProtocol";
</span><span class="line">	}
</span><span class="line">	@end
</span><span class="line">	/*** SubProtocol ***/
</span><span class="line">	@concreteprotocol(SubProtocol)
</span><span class="line">	+ (void)initialize {
</span><span class="line">    NSLog(@"SubProtocol +initialize should only be invoked once per 		concrete protocol");
</span><span class="line">	}
</span><span class="line">	- (void)additionalMethod {}
</span><span class="line">	// this should take precedence over the implementation in MyProtocol
</span><span class="line">	- (NSString *)getSomeString {
</span><span class="line">    return @"SubProtocol";
</span><span class="line">	}
</span><span class="line">	@end
</span><span class="line">	@interface TestClass : NSObject &lt;MyProtocol&gt; {}
</span><span class="line">	@end
</span><span class="line">	@implementation TestClass
</span><span class="line">	+ (NSUInteger)meaningfulNumber {
</span><span class="line">    return 0;
</span><span class="line">	}
</span><span class="line">	@end
</span><span class="line">	@interface TestClass5 : TestClass &lt;SubProtocol&gt; {}
</span><span class="line">	@end
</span><span class="line">	@implementation TestClass5
</span><span class="line">	@end</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">    TestClass *obj = [[TestClass alloc] init];
</span><span class="line">    XCTAssertNotNil(obj, @"could not allocate concreteprotocol'd class");
</span><span class="line">        XCTAssertEqualObjects([obj getSomeString], @"MyProtocol", @"TestClass should be using protocol implementation of getSomeString");
</span><span class="line">        
</span><span class="line">        obj = [[TestClass5 alloc] init];
</span><span class="line">        XCTAssertNotNil(obj, @"could not allocate concreteprotocol'd class");
</span><span class="line">        XCTAssertTrue([obj respondsToSelector:@selector(additionalMethod)], @"TestClass5 should have protocol implementation of additionalMethod");
</span><span class="line">        XCTAssertEqualObjects([obj getSomeString], @"SubProtocol", @"TestClass5 should be using SubProtocol implementation of getSomeString");
</span><span class="line">        
</span><span class="line">        XCTAssertEqual([TestClass5 meaningfulNumber], (NSUInteger)0, @"TestClass5 should not be using protocol implementation of meaningfulNumber");</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="concrete-protocols-implement">Concrete protocols implement</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class=""><span class="line">!Objc
</span><span class="line">	#define concreteprotocol(NAME) \
</span><span class="line">    /*
</span><span class="line">     * create a class used to contain all the methods used in this protocol
</span><span class="line">     */ \
</span><span class="line">    interface NAME ## _ProtocolMethodContainer : NSObject &lt; NAME &gt; {} \
</span><span class="line">    @end \
</span><span class="line">    \
</span><span class="line">    @implementation NAME ## _ProtocolMethodContainer \
</span><span class="line">    /*
</span><span class="line">     * when this class is loaded into the runtime, add the concrete protocol
</span><span class="line">     * into the list we have of them
</span><span class="line">     */ \
</span><span class="line">    + (void)load { \
</span><span class="line">        /*
</span><span class="line">         * passes the actual protocol as the first parameter, then this class as
</span><span class="line">         * the second
</span><span class="line">         */ \
</span><span class="line">        if (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), self)) \
</span><span class="line">            fprintf(stderr, "ERROR: Could not load concrete protocol %s\n", metamacro_stringify(NAME)); \
</span><span class="line">    } \
</span><span class="line">    \
</span><span class="line">    /*
</span><span class="line">     * using the "constructor" function attribute, we can ensure that this
</span><span class="line">     * function is executed only AFTER all the Objective-C runtime setup (i.e.,
</span><span class="line">     * after all +load methods have been executed)
</span><span class="line">     */ \
</span><span class="line">    __attribute__((constructor)) \
</span><span class="line">    static void ext_ ## NAME ## _inject (void) { \
</span><span class="line">        /*
</span><span class="line">         * use this injection point to mark this concrete protocol as ready for
</span><span class="line">         * loading
</span><span class="line">         */ \
</span><span class="line">        ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lottie &amp; BodyMovin]]></title>
    <link href="http://helloyokoy.github.io/blog/lottie-and-bodymovin/"/>
    <updated>2017-04-21T14:37:36+08:00</updated>
    <id>http://helloyokoy.github.io/blog/lottie-and-bodymovin</id>
    <content type="html"><![CDATA[<h2 id="svg">SVG</h2>
<ul>
  <li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>
  <li>SVG 用来定义用于网络的基于矢量的图形</li>
  <li>SVG 使用 XML 格式定义图形</li>
  <li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li>
  <li>SVG 是万维网联盟的标准</li>
  <li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li>
</ul>

<h2 id="json-file">JSON File</h2>
<p><img src="http://owx2ayke3.bkt.clouddn.com/15083136240610.jpg" alt="" /></p>

<!--more-->

<h2 id="decode-json">Decode JSON</h2>
<p><img src="http://owx2ayke3.bkt.clouddn.com/15083136587789.jpg" alt="" /></p>

<h2 id="bodymovin">BodyMovin</h2>
<ul>
  <li>Github:  https://github.com/bodymovin/bodymovin</li>
  <li>AffterEffects: <a href="https://creative.adobe.com/addons/products/12557#.WTev0nWGOi4">https://creative.adobe.com/addons/products/12557#.WTev0nWGOi4</a></li>
  <li>http://ivweb.io/topic/592864df09439b0640aefbb9</li>
</ul>

<h2 id="bodymovinjs">BodyMovin.js</h2>
<p><img src="http://owx2ayke3.bkt.clouddn.com/15083136848623.jpg" alt="" /></p>

<h2 id="lottie-for-ios">Lottie for iOS</h2>
<p><img src="http://owx2ayke3.bkt.clouddn.com/15083137419971.jpg" alt="" /></p>

<h2 id="lottie-for-android">Lottie for Android</h2>
<p><img src="http://owx2ayke3.bkt.clouddn.com/15083137617672.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何编写更棒的代码]]></title>
    <link href="http://helloyokoy.github.io/blog/write-best-code/"/>
    <updated>2016-08-13T12:46:03+08:00</updated>
    <id>http://helloyokoy.github.io/blog/write-best-code</id>
    <content type="html"><![CDATA[<p>作为一个合格的程序员，有太多的理由促使你去编写干净利落且可读性强的代码。最重要的是因为你编写的代码，将来会有很多人一次次地阅读。当你有一天回过头来看自己的代码时，你就会明白编写优雅的代码是多么的重要。另外，如果别人来阅读你编写的代码，你是否想知道别人看到那些烂代码无比抓狂的感受。因此，花多一点的时间去编写优雅的代码，将来说不定会给你节省更多的时间。</p>

<p>那么，如何编写更棒的代码，下面是11条基本规则：</p>

<ol>
  <li>
    <p>保持方法简短扼要</p>
  </li>
  <li>
    <p>永远永远不要将同一个变量用于不同的目的</p>
  </li>
  <li>
    <p>尽可能让变量和方法的名称能够描述要实现的功能</p>
  </li>
  <li>
    <p>尽可能将变量定义在最靠近它们的地方</p>
  </li>
  <li>
    <p>不要出现让人费解的数字</p>
  </li>
  <li>
    <p>要像对待朋友一样对待你擅长的语言</p>
  </li>
  <li>
    <p>不要逆常规而行</p>
  </li>
  <li>
    <p>千万小心过早的优化代码</p>
  </li>
  <li>
    <p>要常常重构经过测试的代码</p>
  </li>
  <li>
    <p>不要沉溺于过度的设计技巧</p>
  </li>
  <li>
    <p>随时随地学习新的知识</p>
  </li>
</ol>

<!--more-->

<p>下面我们来对每一点详细展开介绍。</p>

<h3 id="section">1、保持方法简短扼要</h3>

<p>尽管很多人都遵循这条规则，但是它依然很重要。总的来说，编写的方法最好能在首屏完全显示。试想，如果你需要滚动页面才能看到整一个方法，那是一件多么分散注意力的事情。一个方法最好能保持在5 – 20行之间，当然，你也要视具体情况而定，并不是一概而论的。对于getter和setter方法，通常只需一行代码，所以它们看起来更像是类成员的存取访问器。</p>

<h3 id="section-1">2、远永远不要将同一个变量用于不同的目的</h3>
<p>一个变量应该只能被用于一个目的，我们可以通过使用常量（C++中用const标识，Java中用final标识），帮助编译器优化代码编译，也可以向程序标识“这个变量是不能被改变的”，这样我们编写的代码就有更好的可读性。</p>

<h3 id="section-2">3、尽可能让变量和方法的名称能够描述要实现的功能</h3>
<p>一段通俗易懂的程序代码，应该是任何人只要看了代码，就能明白程序是用来干嘛的。所以我建议大家尽量少用缩写，除非是程序界公认的简写习惯，像下面的简写习惯：</p>

<pre><code>src - source
pos - position
prev - previous
</code></pre>

<p>如果你觉得描述性的简写方式没有价值，你可以比较一下n, ns, nsisd和numTeamMembers, seatCount, numSeatsInStadium。</p>

<h3 id="section-3">4、尽可能将变量定义在最靠近它们的地方</h3>
<p>当你在盖房子的时候，总不希望把锤子放在别人家的院子里吧，相反，你会把盖房的工具放得尽可能近，定义变量也是同样的道理。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int foo = 3;
</span><span class="line">int bar = 5;
</span><span class="line">// bunch of code that uses "bar"
</span><span class="line">// but doesn't care about "foo"
</span><span class="line">// ...
</span><span class="line">
</span><span class="line">baz(foo);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们可以这样重构代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int bar = 5;
</span><span class="line">// bunch of code that use "bar"
</span><span class="line">// but doesn't care about "foo"
</span><span class="line">// ...
</span><span class="line">
</span><span class="line">int foo = 3;
</span><span class="line">baz(foo);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当你把变量的声明跟使用它的地方相隔太远的时候（甚至是超过一屏），那的确会给你带来很大的麻烦。你会经常滚动页面去寻找这个变量，导致你很难在大脑中保持代码之间的连贯性。</p>

<h3 id="section-4">5、不要出现让人费解的数字</h3>
<p>任何时候，你要比较一些常量时，都要将它们定义成constant类型。团队之间调试代码时最让人头疼是出现下面的代码：</p>

<pre><code>il &lt; 4384 把它替换成下面的代码该多好：

inputLength &lt; MAX_INPUT_LENGTH
</code></pre>

<h3 id="section-5">6、要像对待朋友一样对待你擅长的语言</h3>

<p>学习一种新的编程语言是一件很有趣的事情，从中你可以用很酷的方式学到新东西。还有就是让一个对某种语言很专业的人去学另外一种语言，很多时候会让人心有余而力不足。举个例子，你让一个Java大牛去学Ruby，他应该会用Ruby的方式去解决问题，而不是继续沿用Java的解决问题的思想。</p>

<p>当你需要循环输出5遍”Hello World“时，Java代码应该会是这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int i = 0; i &lt; 5; i++) {
</span><span class="line">    System.out.println("Hello world!");
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是用Ruby，你也许会这样写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for i in (0..5)
</span><span class="line">  	puts "Hello world!"
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这些看上去都很不错，但是最完美的方式可能是下面这样：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">5.times { puts "Hello world!" }</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-6">7、不要逆常规而行</h3>
<p>每一种编程语言都有自己的约束习惯，总的来说，大家对Java的编程习惯可能会了解得比较多，我们一起来看看其中的一些习惯：</p>

<p>方法名以小写字母开头，后面紧跟的是大写字母开头的单词，比如veryLongVariableName。
类名一般都是大写字母开头的单词组合。
常量的命名都是大写字母的单词，之间用下划线隔开，比如MY_CONSTANT
左大括号应该跟if在同一行
只有在迫不得已的时候才能打破这种规则，千万不要因为不喜欢这种做法而违背已经约定好的编码习俗。如果你身为团队一员，想改变一些编码规则的话，那也可以，不过当你把自己的代码分享给没有你这种习惯的队友的时候，棘手的问题会迎面而来。</p>

<h3 id="section-7">8、千万小心过早的优化代码</h3>

<p>过早的优化是所有问题的根源，至少电视上是这么说的…你的首要任务是编写容易理解的代码，而不要求你能很快写出来。除非你的程序运行很慢，否则谈优化都是为时太早。如果你想优化你的程序，那么得先找出程序的问题，这就是我们需要profilers这个工具的原因。</p>

<p>在没有找到问题源头就去优化代码，这样做你所要付出的代价就是破坏了程序的结构，至少会丧失程序的可读性。如果你发现程序运行缓慢了，也不要盲目地重构代码，要先找到导致运行慢的根本原因。</p>

<p>千万不要傻乎乎地去解决根本不存在的问题。</p>

<h3 id="section-8">9、要常常重构经过测试的代码</h3>

<p>世上没有绝对完美的事情。尽管你认为自己的代码已经写得非常完美了，过一段时间也要经常去看看它，也许那时你会对自己大骂：”怎么会那么傻！”</p>

<p>有一种提高代码质量的方法，那就是经常重构通过测试的代码。所谓通过测试，我指的是程序要能正常工作，你可以通过自动化测试或者手动测试来确保这一点。</p>

<p>首先你要确保程序能够正常运行，第一次我们并不需要写出多么完美的程序，能用就行，接下来我们可以慢慢重构，让它逐渐变得完美。这种开发方式很有TDD的味道，关键在于你需要熟悉重构的每一个环节。如果你熟练使用一些高级的IDE，像IntelliJ IDEA，那你的重构工作将会简单很多。</p>

<p>重构完以后，也许你会碰到很多这样那样的问题，甚至会破坏正常的程序，这就是我们要利用自动化测试的原因了。当你重构完以后，跑一遍单元测试就能避免这些令人头疼的问题了。</p>

<h3 id="section-9">10、不要沉溺于过度的设计技巧</h3>

<p>当我第一次接触到设计模式这一概念时，我觉得自己找到了“圣杯”。这些精妙的设计思想可以让你工作更加顺利，也可以让你的设计浅显易懂，因为你可以简单的说“我使用了观察者模式”，而不同大费周章的解释一通。然而问题来了，由于有些问题看起来太自然太简单了，你会把那些设计模式的思想应用到任何地方，为什么不把这个类设计成单例模式（singleton）？干嘛不去创建一些工厂类呢？</p>

<p>于是用80行代码就能完成的脚本，结果你用了10个类，15个接口和一堆泛型和注释，这其中的97%代码并没有做实质上的事情。设计模式虽然非常有用，可以帮助你简化设计，但是这并不是说你可以到处使用它们。你可以使用设计模式，但是不能将它滥用了。</p>

<h3 id="section-10">11、随时随地学习新的知识</h3>

<p>编程就是一项随时学习新事物的工作，当你学到了新的类库或者编程语言时，你会迫不及待地丢掉老的代码，进而去重写它们。然而有很多理由说明你不该这么做。</p>

<p>将一个新的类库或者框架应用到现有的项目中就会出现类似的问题。比如说你正在为一个Web项目写Javascript，但是中间你发现了jQuery，这时候你会迫不及待想把jQuery应用进去，而丢掉原来的Javascript代码，即便你根本没用jQuery写过任何项目。</p>

<p>最好的方式是你先用jQuery学着写一些简单的例子，把你项目中要用到的技术都学会。比如说你想要用AJAX？就先在项目之外写一些关于AJAX的简单例子，等到完全掌握了，就可以将老代码从项目中移除。</p>

<p>如果你热衷于编程，我强烈推荐你阅读Steve McConnell编写的《Code Complete》，它将永远改变你的编程思维。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多线程]]></title>
    <link href="http://helloyokoy.github.io/blog/iosduo-xian-cheng/"/>
    <updated>2016-07-18T22:25:55+08:00</updated>
    <id>http://helloyokoy.github.io/blog/iosduo-xian-cheng</id>
    <content type="html"><![CDATA[<h2 id="section">概述</h2>
<hr />

<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>

<ul>
  <li>Pthreads</li>
  <li>NSThread</li>
  <li>GCD</li>
  <li>NSOperation &amp; NSOperationQueue</li>
</ul>

<!--more-->

<h3 id="pthreads">Pthreads</h3>

<p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。</p>

<p>简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于 c语言 的框架，使用起来这酸爽！感受一下：</p>

<p>OBJECTIVE-C</p>

<p>当然第一步要包含头文件</p>

<pre><code>#import &lt;pthread.h&gt;
</code></pre>

<p>然后创建线程，并执行任务</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
</span><span class="line">   pthread_t thread;
</span><span class="line">   //创建一个线程并自动执行
</span><span class="line">   pthread_create(&amp;thread, NULL, start, NULL);
</span><span class="line">}
</span><span class="line">
</span><span class="line">void *start(void *data) {
</span><span class="line">   NSLog(@"%@", [NSThread currentThread]);
</span><span class="line">   return NULL;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打印输出：</p>

<pre><code>2015-07-27 23:57:21.689 testThread[10616:2644653] {number = 2, name = (null)} 看代码就会发现他需要 c语言函数，这是比较蛋疼的，更蛋疼的是你需要手动处理线程的各个状态的转换即管理生命周期，比如，这段代码虽然创建了一个线程，但并没有销毁。
</code></pre>

<h3 id="nsthread">NSThread</h3>

<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法。</p>

<h4 id="section-1">创建并启动</h4>

<p>先创建线程类，再启动</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">// 创建
</span><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];
</span><span class="line">// 启动
</span><span class="line">[thread start];
</span><span class="line">    
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">//创建
</span><span class="line">let thread = NSThread(target: self, selector: "run:", object: nil)
</span><span class="line">//启动
</span><span class="line">thread.start()</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-2">创建并自动启动</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];
</span><span class="line">
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">NSThread.detachNewThreadSelector("run:", toTarget: self, withObject: nil)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>使用 NSObject 的方法创建并自动启动</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">[self performSelectorInBackground:@selector(run:) withObject:nil];
</span><span class="line">
</span><span class="line">SWIFT</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>苹果认为 performSelector: 不安全，所以在 Swift 去掉了这个方法。</p>

<blockquote>
  <p>Note: The performSelector: method and related selector-invoking methods are not imported in Swift because they are inherently unsafe.</p>
</blockquote>

<h4 id="section-3">其他方法</h4>

<p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法大家可以去类的定义里去看。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">//取消线程
</span><span class="line">- (void)cancel;
</span><span class="line">//启动线程
</span><span class="line">- (void)start;
</span><span class="line">//判断某个线程的状态的属性
</span><span class="line">@property (readonly, getter=isExecuting) BOOL executing;
</span><span class="line">@property (readonly, getter=isFinished) BOOL finished;
</span><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled;
</span><span class="line">//设置和获取线程名字
</span><span class="line">-(void)setName:(NSString *)n;
</span><span class="line">-(NSString *)name;
</span><span class="line">//获取当前线程信息
</span><span class="line">+ (NSThread *)currentThread;
</span><span class="line">//获取主线程信息
</span><span class="line">+ (NSThread *)mainThread;
</span><span class="line">//使当前线程暂停一段时间，或者暂停到某个时刻
</span><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)time;
</span><span class="line">+ (void)sleepUntilDate:(NSDate *)date;
</span><span class="line">
</span><span class="line">SWIFT</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Swift的方法名字和OC的方法名都一样，我就不浪费空间列举出来了。</p>

<p>其实，NSThread 用起来也挺简单的，因为它就那几种方法。同时，我们也只有在一些非常简单的场景才会用 NSThread, 毕竟它还不够智能，不能优雅地处理多线程中的其他高级概念。所以接下来要说的内容才是重点。</p>

<h3 id="gcd">GCD</h3>

<p>苹果为多核的并行运算提出的解决方案，会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。</p>

<h4 id="section-4">任务和队列</h4>

<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。</p>

<p>任务：即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。</p>

<p>任务有两种执行方式： 同步执行 和 异步执行，主要区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕！</p>

<p>如果是 同步（sync） 操作，它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行。</p>

<p>如果是 异步（async）操作，当前线程会直接往下执行，它不会阻塞当前线程。</p>

<p>队列：用于存放任务。一共有两种队列， 串行队列 和 并行队列。
串行队列 中的任务会根据队列的定义 FIFO 的执行，一个接一个的先进先出的进行执行。</p>

<p>更新：放到串行队列的任务，GCD 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。</p>

<p>并行队列 中的任务根据同步或异步有不同的执行方式。虽然很绕，但请看下表：</p>

<p>更新：放到串行队列的任务，GCD 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，GCD 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。</p>

<h4 id="section-5">创建队列</h4>

<p>主队列：这是一个特殊的 串行队列。什么是主队列，大家都知道吧，它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//OBJECTIVE-C
</span><span class="line">dispatch_queue_t queue = ispatch_get_main_queue();
</span><span class="line">//SWIFT
</span><span class="line">let queue = ispatch_get_main_queue()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>自己创建的队列：凡是自己创建的队列都是 串行队列。其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空。大家可以看xcode的文档查看参数意义。</p>

<p>更新：自己可以创建 串行队列, 也可以创建 并行队列。看下面的代码（代码已更新），它有两个参数，第一个上面已经说了，第二个才是最重要的。</p>

<p>第二个参数用来表示创建的队列是串行的还是并行的，</p>

<p>传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。</p>

<p>传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//OBJECTIVE-C
</span><span class="line">dispatch_queue_t queue = dispatch_queue_create("tk.bourne.testQueue", NULL);
</span><span class="line">//SWIFT
</span><span class="line">let queue = dispatch_queue_create("tk.bourne.testQueue", nil);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>全局并行队列：这应该是唯一一个并行队列，只要是并行任务一般都加入到这个队列。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//OBJECTIVE-C
</span><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class="line">//SWIFT
</span><span class="line">let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-6">创建任务</h4>

<p>同步任务：不会另开线程 (SYNC)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">dispatch_sync(, ^{
</span><span class="line">      //code here
</span><span class="line">      NSLog(@"%@", [NSThread currentThread]);
</span><span class="line">});
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">dispatch_sync(, { () -&gt; Void in
</span><span class="line">      //code here
</span><span class="line">      println(NSThread.currentThread())
</span><span class="line">})</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>异步任务：会另开线程 (ASYNC)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">dispatch_async(, ^{
</span><span class="line">      //code here
</span><span class="line">      NSLog(@"%@", [NSThread currentThread]);
</span><span class="line">});
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">dispatch_async(, { () -&gt; Void in
</span><span class="line">      //code here
</span><span class="line">      println(NSThread.currentThread())
</span><span class="line">})</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更新：</p>

<p>为了更好的理解同步和异步，和各种队列的使用，下面看两个示例：</p>

<p>示例一：</p>

<p>以下代码在主线程调用，结果是什么？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">NSLog("之前 - %@", NSThread.currentThread())
</span><span class="line">dispatch_sync(dispatch_get_main_queue(), { () -&gt; Void in 
</span><span class="line">        NSLog("sync - %@", NSThread.currentThread())
</span><span class="line">})
</span><span class="line">NSLog("之后 - %@", NSThread.currentThread())</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>答案：</p>

<p>只会打印第一句：之前 - {number = 1, name = main} ，然后主线程就卡死了，你可以在界面上放一个按钮，你就会发现点不了了。</p>

<p>解释：</p>

<p>同步任务会阻塞当前线程，然后把 Block 中的任务放到指定的队列中执行，只有等到 Block 中的任务完成后才会让当前线程继续往下运行。</p>

<p>那么这里的步骤就是：打印完第一句后，dispatch_sync 立即阻塞当前的主线程，然后把 Block 中的任务放到 main_queue 中，可以 main_queue 中的任务会被取出来放到主线程中执行，但主线程这个时候已经被阻塞了，所以 Block 中的任务就不能完成，它不完成，dispatch_sync 就会一直阻塞主线程，这就是死锁现象。导致主线程一直卡死。</p>

<p>示例二：</p>

<p>以下代码会产生什么结果？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">let queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL)
</span><span class="line">NSLog("之前 - %@", NSThread.currentThread())
</span><span class="line">dispatch_async(queue, { () -&gt; Void in
</span><span class="line">NSLog("sync之前 - %@", NSThread.currentThread())
</span><span class="line">dispatch_sync(queue, { () -&gt; Void in
</span><span class="line">   NSLog("sync - %@", NSThread.currentThread())
</span><span class="line">})
</span><span class="line">  NSLog("sync之后 - %@", NSThread.currentThread())
</span><span class="line">})
</span><span class="line">  	NSLog("之后 - %@", NSThread.currentThread())</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>答案：</p>

<pre><code>2015-07-30 02:06:51.058 test[33329:8793087] 之前 - {number = 1, name = main}

2015-07-30 02:06:51.059 test[33329:8793356] sync之前 - {number = 2, name = (null)}

2015-07-30 02:06:51.059 test[33329:8793087] 之后 - {number = 1, name = main}
</code></pre>

<p>很明显 sync - %@ 和 sync之后 - %@ 没有被打印出来！这是为什么呢？我们再来分析一下：</p>

<p>分析：</p>

<p>我们按执行顺序一步步来哦：</p>

<p>使用 DISPATCH_QUEUE_SERIAL 这个参数，创建了一个 串行队列。
打印出 之前 - %@ 这句。</p>

<p>dispatch_async 异步执行，所以当前线程不会被阻塞，于是有了两条线程，一条当前线程继续往下打印出 之后 - %@这句, 另一台执行 Block 中的内容打印 sync之前 - %@ 这句。因为这两条是并行的，所以打印的先后顺序无所谓。</p>

<p>注意，高潮来了。现在的情况和上一个例子一样了。dispatch_sync同步执行，于是它所在的线程会被阻塞，一直等到 sync 里的任务执行完才会继续往下。于是 sync 就高兴的把自己 Block 中的任务放到 queue 中，可谁想 queue 是一个串行队列，一次执行一个任务，所以 sync 的 Block 必须等到前一个任务执行完毕，可万万没想到的是 queue 正在执行的任务就是被 sync 阻塞了的那个。于是又发生了死锁。所以 sync 所在的线程被卡死了。剩下的两句代码自然不会打印。</p>

<p>队列组</p>

<p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。下面是使用方法，这是一个很实用的功能。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">//1.创建队列组
</span><span class="line">dispatch_group_t group = dispatch_group_create();
</span><span class="line">//2.创建队列
</span><span class="line">dispatch_queue_t queue = 	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class="line">//3.多次使用队列组的方法执行任务, 只有异步方法
</span><span class="line">//3.1.执行3次循环
</span><span class="line">dispatch_group_async(group, queue, ^{
</span><span class="line">for (NSInteger i = 0; i &lt; 3; i++) {
</span><span class="line">        NSLog(@"group-01 - %@", [NSThread currentThread]);
</span><span class="line">}
</span><span class="line">});
</span><span class="line">//3.2.主队列执行8次循环
</span><span class="line">dispatch_group_async(group, dispatch_get_main_queue(), ^{
</span><span class="line">    for (NSInteger i = 0; i &lt; 8; i++) {
</span><span class="line">        NSLog(@"group-02 - %@", [NSThread currentThread]);
</span><span class="line">    }
</span><span class="line">});
</span><span class="line">//3.3.执行5次循环
</span><span class="line">dispatch_group_async(group, queue, ^{
</span><span class="line">    for (NSInteger i = 0; i &lt; 5; i++) {
</span><span class="line">        NSLog(@"group-03 - %@", [NSThread currentThread]);
</span><span class="line">    }
</span><span class="line">});
</span><span class="line">//4.都完成后会自动通知
</span><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^{
</span><span class="line">    NSLog(@"完成 - %@", [NSThread currentThread]);
</span><span class="line">});
</span><span class="line">
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">//1.创建队列组
</span><span class="line">let group = dispatch_group_create()
</span><span class="line">//2.创建队列
</span><span class="line">let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
</span><span class="line">//3.多次使用队列组的方法执行任务, 只有异步方法
</span><span class="line">//3.1.执行3次循环
</span><span class="line">dispatch_group_async(group, queue) { () -&gt; Void in
</span><span class="line">    for _ in 0.. Void in
</span><span class="line">    for _ in 0.. Void in
</span><span class="line">    for _ in 0.. Void in
</span><span class="line">    NSLog("完成 - %@", NSThread.currentThread())
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打印结果</p>

<pre><code>2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] 完成 - {number = 1, name = main}
</code></pre>

<p>这些就是 GCD 的基本功能，但是它的能力远不止这些，等讲完 NSOperation 后，我们再来看看它的一些其他方面用途。而且，只要你想象力够丰富，你可以组合出更好的用法。</p>

<p>更新：关于GCD，还有两个需要说的：</p>

<pre><code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法重点是你传入的 queue，当你传入的 queue 是通过 DISPATCH_QUEUE_CONCURRENT 参数自己创建的 queue 时，这个方法会阻塞这个 queue（注意是阻塞 queue ，而不是阻塞当前线程），一直等到这个 queue 中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue 中排在它后面的任务继续执行。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_async 一样了。</p>

<pre><code>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法的使用和上一个一样，传入 自定义的并发队列（DISPATCH_QUEUE_CONCURRENT），它和上一个方法一样的阻塞 queue，不同的是 这个方法还会 阻塞当前线程。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_sync 一样了。</p>

<h3 id="nsoperationnsoperationqueue">NSOperation和NSOperationQueue</h3>

<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>

<p>将要执行的任务封装到一个 NSOperation 对象中。
将此任务添加到一个 NSOperationQueue 对象中。
然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>

<h4 id="section-7">添加任务</h4>

<p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>

<p>NSInvocationOperation : 需要传入一个方法名。</p>

<p>OBJECTIVE-C</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//1.创建NSInvocationOperation对象
</span><span class="line"> NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];
</span><span class="line">//2.开始执行
</span><span class="line">[operation start];</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>NSBlockOperation</p>

<p>OBJECTIVE-C</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//1.创建NSBlockOperation对象
</span><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
</span><span class="line">   NSLog(@"%@", [NSThread currentThread]);
</span><span class="line">}];
</span><span class="line">//2.开始任务
</span><span class="line">[operation start];
</span><span class="line">
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">//1.创建NSBlockOperation对象
</span><span class="line">let operation = NSBlockOperation { () -&gt; Void in
</span><span class="line">   println(NSThread.currentThread())
</span><span class="line">}
</span><span class="line">//2.开始任务
</span><span class="line">operation.start()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程 执行这些任务，注意下面的打印结果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">//1.创建NSBlockOperation对象
</span><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
</span><span class="line">          NSLog(@"%@", [NSThread currentThread]);
</span><span class="line">}];
</span><span class="line">//添加多个Block
</span><span class="line">for (NSInteger i = 0; i &lt; 5; i++) {
</span><span class="line">  [operation addExecutionBlock:^{
</span><span class="line">      NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
</span><span class="line">  }];
</span><span class="line">}
</span><span class="line">//2.开始任务
</span><span class="line">[operation start];
</span><span class="line">      
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">//1.创建NSBlockOperation对象
</span><span class="line">let operation = NSBlockOperation { () -&gt; Void in
</span><span class="line">    NSLog("%@", NSThread.currentThread())
</span><span class="line">}
</span><span class="line">//2.添加多个Block
</span><span class="line">for i in 0.. Void in
</span><span class="line">   NSLog("第%ld次 - %@", i, NSThread.currentThread())
</span><span class="line">   }
</span><span class="line"> }
</span><span class="line">//2.开始任务
</span><span class="line">operation.start()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打印输出</p>

<pre><code>2015-07-28 17:50:16.585 test[17527:4095467] 第2次 -{number = 1, name = main}
2015-07-28 17:50:16.585 test[17527:4095666] 第1次 -{number = 4, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095665]{number = 3, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095662] 第0次 -{number = 2, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095666] 第3次 -{number = 4, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095467] 第4次 -{number = 1, name = main}
</code></pre>

<p>NOTE：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>

<pre><code>-[NSBlockOperation addExecutionBlock:]: 

blocks cannot be added after the operation has started executing or finished'
</code></pre>

<p>NOTE：大家可能发现了一个问题，为什么我在 Swift 里打印输出使用 NSLog() 而不是 println() 呢？原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。它会把需要输出的每个字符一个一个的输出到控制台。普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 println() 同时打印，就会导致控制台上的字符混乱的堆在一起，而NSLog() 就没有这个问题。</p>

<h4 id="operation">自定义Operation</h4>

<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的需求，你就需要自定义了。</p>

<h4 id="section-8">创建队列</h4>

<p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 同步执行 的。就算是 addExecutionBlock 方法，也会在 当前线程和其他线程 中执行，也就是说还是会占用当前线程。</p>

<p>这是就要用到队列 NSOperationQueue 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 start() 方法</p>

<p>主队列</p>

<p>每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//OBJECTIVE-C
</span><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];
</span><span class="line">//SWIFT
</span><span class="line">let queue = NSOperationQueue.mainQueue()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其他队列</p>

<p>因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>

<p>注意：其他队列的任务会在其他线程并行执行。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">//1.创建一个其他队列    
</span><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];
</span><span class="line">//2.创建NSBlockOperation对象
</span><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
</span><span class="line">NSLog(@"%@", [NSThread currentThread]);
</span><span class="line">}];
</span><span class="line">//3.添加多个Block
</span><span class="line">for (NSInteger i = 0; i &lt; 5; i++) {
</span><span class="line">  [operation addExecutionBlock:^{
</span><span class="line">      NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
</span><span class="line">  }];
</span><span class="line"> }
</span><span class="line">//4.队列添加任务
</span><span class="line">[queue addOperation:operation];
</span><span class="line">
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">//1.创建其他队列
</span><span class="line">let queue = NSOperationQueue()
</span><span class="line">//2.创建NSBlockOperation对象
</span><span class="line">let operation = NSBlockOperation { () -&gt; Void in
</span><span class="line">NSLog("%@", NSThread.currentThread())
</span><span class="line">}
</span><span class="line">//3.添加多个Block
</span><span class="line">for i in 0.. Void in
</span><span class="line">   NSLog("第%ld次 - %@", i, NSThread.currentThread())
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">//4.队列添加任务
</span><span class="line">queue.addOperation(operation)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打印输出</p>

<pre><code>2015-07-28 20:26:28.463 test[18622:4443534]{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第2次 -{number = 2, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443535] 第0次 -{number = 4, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443533] 第1次 -{number = 3, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443534] 第3次 -{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第4次 -{number = 2, name = (null)}
</code></pre>

<p>NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。设置为 1 的时候为串行.</p>

<p>NSOperationQueue 还有一个添加任务的方法，</p>

<pre><code>- (void)addOperationWithBlock:(void (^)(void))block; 
</code></pre>

<p>这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>

<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：</p>

<p>A: 从服务器上下载一张图片.</p>

<p>B：给这张图片加个水印.</p>

<p>C：把图片返回给服务器。</p>

<p>这时就可以用到依赖了:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">//1.任务一：下载图片
</span><span class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
</span><span class="line">NSLog(@"下载图片 - %@", [NSThread currentThread]);
</span><span class="line">[NSThread sleepForTimeInterval:1.0];
</span><span class="line">}];
</span><span class="line">//2.任务二：打水印
</span><span class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
</span><span class="line">NSLog(@"打水印   - %@", [NSThread currentThread]);
</span><span class="line">   [NSThread sleepForTimeInterval:1.0];
</span><span class="line">}];
</span><span class="line">//3.任务三：上传图片
</span><span class="line">NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
</span><span class="line">NSLog(@"上传图片 - %@", [NSThread currentThread]);
</span><span class="line">   [NSThread sleepForTimeInterval:1.0];
</span><span class="line">}];
</span><span class="line">//4.设置依赖
</span><span class="line">[operation2 addDependency:operation1];      //任务二依赖任务一
</span><span class="line">[operation3 addDependency:operation2];      //任务三依赖任务二
</span><span class="line">//5.创建队列并加入任务
</span><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];
</span><span class="line">[queue addOperations:@[operation3, operation2, operation1] 	waitUntilFinished:NO];
</span><span class="line">
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">//1.任务一：下载图片
</span><span class="line">let operation1 = NSBlockOperation { () -&gt; Void in
</span><span class="line">NSLog("下载图片 - %@", NSThread.currentThread())
</span><span class="line">  NSThread.sleepForTimeInterval(1.0)
</span><span class="line">}
</span><span class="line">//2.任务二：打水印
</span><span class="line">let operation2 = NSBlockOperation { () -&gt; Void in
</span><span class="line">  NSLog("打水印   - %@", NSThread.currentThread())
</span><span class="line">  NSThread.sleepForTimeInterval(1.0)
</span><span class="line">}
</span><span class="line">//3.任务三：上传图片
</span><span class="line">let operation3 = NSBlockOperation { () -&gt; Void in
</span><span class="line">   NSLog("上传图片 - %@", NSThread.currentThread())
</span><span class="line">   NSThread.sleepForTimeInterval(1.0)
</span><span class="line">}
</span><span class="line">//4.设置依赖
</span><span class="line">operation2.addDependency(operation1)    //任务二依赖任务一
</span><span class="line">operation3.addDependency(operation2)    //任务三依赖任务二
</span><span class="line">//5.创建队列并加入任务
</span><span class="line">let queue = NSOperationQueue()
</span><span class="line">queue.addOperations([operation3, operation2, operation1], waitUntilFinished: false)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打印结果</p>

<pre><code>2015-07-28 21:24:28.622 test[19392:4637517] 下载图片 -{number = 2, name = (null)}
2015-07-28 21:24:29.622 test[19392:4637515] 打水印 -{number = 3, name = (null)}
2015-07-28 21:24:30.627 test[19392:4637515] 上传图片 -{number = 3, name = (null)}
</code></pre>

<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。
可以使用 removeDependency 来解除依赖关系。
可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</p>

<p>其他方法</p>

<p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">NSOperation
</span><span class="line">
</span><span class="line">BOOL executing; //判断任务是否正在执行
</span><span class="line">BOOL finished; //判断任务是否完成
</span><span class="line">void (^completionBlock)(void); //用来设置完成后需要执行的操作
</span><span class="line">- (void)cancel; //取消任务
</span><span class="line">- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕
</span><span class="line">NSOperationQueue
</span><span class="line">
</span><span class="line">NSUInteger operationCount; //获取队列的任务数
</span><span class="line">- (void)cancelAllOperations; //取消队列中所有的任务
</span><span class="line">- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕
</span><span class="line">[queue setSuspended:YES]; // 暂停queue
</span><span class="line">[queue setSuspended:NO]; // 继续queue</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-9">其他用法</h3>

<h4 id="section-10">线程同步</h4>

<p>所谓线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>

<p>互斥锁 ：给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">@synchronized(self) {
</span><span class="line">  //需要执行的代码块
</span><span class="line">}
</span><span class="line">	
</span><span class="line">SWIFT
</span><span class="line">
</span><span class="line">objc_sync_enter(self)
</span><span class="line">//需要执行的代码块
</span><span class="line">objc_sync_exit(self)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>同步执行 ：我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 GCD 和 NSOperation 两种方案，我都写出来。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">//GCD
</span><span class="line">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中
</span><span class="line">dispatch_sync(queue, ^{
</span><span class="line">   NSInteger ticket = lastTicket;
</span><span class="line">   [NSThread sleepForTimeInterval:0.1];
</span><span class="line">   NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
</span><span class="line">   ticket -= 1;
</span><span class="line">   lastTicket = ticket;
</span><span class="line">});
</span><span class="line">//NSOperation &amp; NSOperationQueue
</span><span class="line">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中
</span><span class="line">//     2. 设置 queue 的 maxConcurrentOperationCount 为 1
</span><span class="line">//     3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。	waitUntilFinished 要在添加到队列之后！
</span><span class="line">NSBlockOperation *operation = [NSBlockOperation 	blockOperationWithBlock:^{
</span><span class="line">      NSInteger ticket = lastTicket;
</span><span class="line">      [NSThread sleepForTimeInterval:1];
</span><span class="line">      NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
</span><span class="line">      ticket -= 1;
</span><span class="line">      lastTicket = ticket;
</span><span class="line">}];
</span><span class="line">[queue addOperation:operation];
</span><span class="line">[operation waitUntilFinished];
</span><span class="line">//后续要做的事
</span><span class="line">
</span><span class="line">SWIFT</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-11">延迟执行</h4>

<p>所谓延迟执行就是延时一段时间再执行某段代码。</p>

<p>下面说一些常用方法。</p>

<h4 id="perform">perform</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">// 3秒后自动调用self的run:方法，并且传递参数：@"abc"
</span><span class="line">[self performSelector:@selector(run:) withObject:@"abc" afterDelay:3];
</span><span class="line">  	
</span><span class="line">SWIFT</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>之前就已经说过，Swift 里去掉了这个方法。</p>

<h4 id="gcd-1">GCD</h4>

<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用，这里只写 OC 的，Swift 的是一样的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">// 创建队列
</span><span class="line">dispatch_queue_t queue = 	dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class="line">// 设置延时，单位秒
</span><span class="line">double delay = 3; 
</span><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
</span><span class="line"> // 3秒后需要执行的任务
</span><span class="line">});</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="nstimer">NSTimer</h4>

<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法，不过这里直说延迟执行的用法。同样只写 OC 版的，Swift 也是相同的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@"abc" repeats:NO];</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-12">单例模式</h4>

<p>在 Objective-C 中，实现单例的方法已经很具体了，虽然有别的方法，但是一般都是用一个标准的方法了，下面来看看。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OBJECTIVE-C
</span><span class="line">
</span><span class="line">@interface Tool : NSObject
</span><span class="line">+ (instancetype)sharedTool;
</span><span class="line">@end
</span><span class="line">@implementation Tool
</span><span class="line">static id _instance;
</span><span class="line">+ (instancetype)sharedTool {
</span><span class="line"> static dispatch_once_t onceToken;
</span><span class="line"> dispatch_once(&amp;onceToken, ^{
</span><span class="line">     _instance = [[Tool alloc] init];
</span><span class="line"> });
</span><span class="line"> return _instance;
</span><span class="line"> }
</span><span class="line">@end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里之所以将单例模式，是因为其中用到了 GCD 的 dispatch_once 方法。</p>

<p>下面看 Swift 中的单例模式，在Swift中单例模式非常简单.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">SWIFT
</span><span class="line">
</span><span class="line">class Tool: NSObject {
</span><span class="line"> static let sharedTool = Tool()
</span><span class="line"> // 私有化构造方法，阻止其他对象使用这个类的默认的'()'构造方法
</span><span class="line"> private override init() {}
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-13">从其他线程回到主线程的方法</h4>

<p>我们都知道在其他线程操作完成后必须到主线程更新UI。所以，介绍完所有的多线程方案后，我们来看看有哪些方法可以回到主线程。</p>

<p>NSThread</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//Objective-C
</span><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
</span><span class="line">//Swift
</span><span class="line">//swift 取消了 performSelector 方法。</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>GCD</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//Objective-C
</span><span class="line">dispatch_async(dispatch_get_main_queue(), ^{
</span><span class="line">});
</span><span class="line">//Swift
</span><span class="line">dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
</span><span class="line">})</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>NSOperationQueue</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//Objective-C
</span><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^{
</span><span class="line">}];
</span><span class="line">//Swift
</span><span class="line">NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Framework]]></title>
    <link href="http://helloyokoy.github.io/blog/android-framework/"/>
    <updated>2016-05-26T14:47:35+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-framework</id>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160524172058595" alt="img" /></p>

<!--more-->

<ul>
  <li>缓存</li>
</ul>

<p>DiskLruCache:	Java实现基于LRU的磁盘缓存</p>

<ul>
  <li>图片加载</li>
</ul>

<p>Android Universal Image Loader:	一个强大的加载，缓存，展示图片的库</p>

<p>Picasso:	一个强大的图片下载与缓存的库</p>

<p>Fresco:	一个用于管理图像和他们使用的内存的库</p>

<p>Glide:	一个图片加载和缓存的库</p>

<ul>
  <li>图片处理</li>
</ul>

<p>Picasso-transformations	: 一个为Picasso提供多种图片变换的库</p>

<p>Glide-transformations:	一个为Glide提供多种图片变换的库</p>

<p>Android-gpuimage: 	基于OpenGL的Android过滤器</p>

<ul>
  <li>网络请求</li>
</ul>

<p>Android Async HTTP:	Android异步HTTP库</p>

<p>AndroidAsync: 	异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。</p>

<p>OkHttp: 	一个Http与Http/2的客户端</p>

<p>Retrofit:	类型安全的Http客户端</p>

<p>Volley: Google推出的Android异步网络请求框架和图片加载框架</p>

<ul>
  <li>网络解析</li>
</ul>

<p>Gson:	一个Java序列化/反序列化库，可以将JSON和java对象互相转换</p>

<p>Jackson:	Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象</p>

<p>Fastjson:	Java上一个快速的JSON解析器/生成器</p>

<p>HtmlPaser: 一种用来解析单个独立html或嵌套html的方式</p>

<p>Jsoup:	一个以最好的DOM，CSS和jQuery解析html的库</p>

<ul>
  <li>数据库</li>
</ul>

<p>OrmLite:	JDBC和Android的轻量级ORM java包</p>

<p>Sugar:	用超级简单的方法处理Android数据库</p>

<p>GreenDAO:	一种轻快地将对象映射到SQLite数据库的ORM解决方案</p>

<p>ActiveAndroid: 以活动记录方式为Android SQLite提供持久化</p>

<p>SQLBrite:	SQLiteOpenHelper 和ContentResolver的轻量级包装</p>

<p>Realm 移动数据库：一个SQLite和ORM的替换品</p>

<ul>
  <li>依赖注入</li>
</ul>

<p>ButterKnife:	将Android视图和回调方法绑定到字段和方法上</p>

<p>Dagger2:	一个Android和java快速依赖注射器。</p>

<p>AndroidAnotations:	快速安卓开发。易于维护</p>

<p>RoboGuice: Android平台的Google Guice</p>

<ul>
  <li>图表</li>
</ul>

<p>WilliamChart:	创建图表的Android库</p>

<p>HelloCharts:	兼容到API8的Android图表库</p>

<p>MPAndroidChart:	一个强大的Android图表视图/图形库</p>

<ul>
  <li>后台处理</li>
</ul>

<p>Tape:	一个轻快的，事务性的，基于文件的FIFO的库</p>

<p>Android Priority Job Queue: 一个专门为Android轻松调度任务的工作队列</p>

<ul>
  <li>事件总线</li>
</ul>

<p>EventBus:	安卓优化的事件总线，简化了活动、片段、线程、服务等的通信</p>

<p>Otto:	一个基于Guava的增强的事件总线</p>

<ul>
  <li>响应式编程</li>
</ul>

<p>RxJava: JVM上的响应式扩展</p>

<p>RxJavaJoins:	为RxJava提供Joins操作</p>

<p>RxAndroid: Android上的响应式扩展，在RxJava基础上添加了Android线程调度</p>

<p>RxBinding: 提供用RxJava绑定Android UI的API</p>

<p>Agera:	Android上的响应式编程</p>

<ul>
  <li>Log框架</li>
</ul>

<p>Logger: 简单，漂亮，强大的Android日志工具
Hugo: 在调试版本上注解的触发方法进行日志记录
Timber: 一个小的，可扩展的日志工具</p>

<ul>
  <li>测试框架</li>
</ul>

<p>Mockito:	Java编写的Mocking单元测试框架</p>

<p>Robotium:	Android UI 测试</p>

<p>Robolectric:	Android单元测试框架</p>

<p>Android自带很多测试工具：JUnit，Monkeyrunner，
UiAutomator，Espresso等</p>

<ul>
  <li>调试框架</li>
</ul>

<p>Stetho: 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试</p>

<ul>
  <li>性能优化</li>
</ul>

<p>LeakCanary:	内存泄漏检测工具</p>

<p>ACRA:	Android应用程序崩溃报告</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surge]]></title>
    <link href="http://helloyokoy.github.io/blog/surge/"/>
    <updated>2016-05-19T11:24:57+08:00</updated>
    <id>http://helloyokoy.github.io/blog/surge</id>
    <content type="html"><![CDATA[<p>iOS 9 有个激动人心的新特性 Network Extension 弥补了 iOS 长久以来无法定制底层网络 app 的不足。APN 代理不安全，成本高；虚拟专网速度不佳，爱掉线，阻塞问题严重…</p>

<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/93867584.jpg" alt="surge" /></p>

<p>那么对于专业用户来说比较完美的方案必须是安全的，可低成本的，最大网络速度，无连接状态，国内外分流完美的 iOS 方案，那么现在这个堕落的愿望已经实现了，感谢苹果公司这么给(chi)力(dao)的 API 和 app 开发大牛。</p>

<p>Surge.app （App Store）是一款给专业用户使用的网络调试工具，使用比较复杂。它的工作原理是使用 packet tunnel provider，然后给系统套上一个代理，后端转发支持 http 代理，SSL 代理，和 Socks 代理。如果 app 尊重系统代理，就会走这个代理，如果不尊重，我们也可以通过规则强制流量走系统 tun 设备达到支持全部 app 的目的。用代理的好处是可以跟踪和调试网络，容易分流，ACL 功能更多，弹性更大更方便。</p>

<!--more-->

<p>简单的开始可以直接导入一份 conf 文件（URL 或者 iTunes），例如<a href="https://gist.github.com/janlay/b57476c72a93b7e622a6" title="link">这里</a>的，对于不求甚解的用户来说你可以直接使用完事（但是你还是要改改服务器地址用户名什么的。。或者直接从供应商处获取导入 URL）。</p>

<p>配置的结构大概是这样，对于专业用户来说，理解应该不难</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (rules)</span> <a href="http://helloyokoy.github.io/downloads/code/rules">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
</pre></td><td class="code"><pre><code class=""><span class="line"><span class="k">[General]</span>
</span><span class="line"><span class="c1"># warning, notify, info, verbose</span>
</span><span class="line"><span class="na">loglevel</span> <span class="o">=</span> <span class="s">notify</span>
</span><span class="line">
</span><span class="line"><span class="k">[Proxy]</span>
</span><span class="line"><span class="c1"># http, https, socks5</span>
</span><span class="line"><span class="c1"># SSLedge 使用 https，老式 APNp 用 http</span>
</span><span class="line"><span class="na">Proxy</span> <span class="o">=</span> <span class="s">https, server, port, username, password, ciphers </span>
</span><span class="line">
</span><span class="line"><span class="k">[Rule]</span>
</span><span class="line"><span class="c1"># 域名关键字，干掉不想要的请求</span>
</span><span class="line"><span class="err">DOMAIN-KEYWORD,umeng.co,REJECT</span>
</span><span class="line"><span class="err">...</span>
</span><span class="line">
</span><span class="line"><span class="c1"># 常用网站优先匹配，加快速度。使用代理转发，完全没有 CDN 被干扰的问题~</span>
</span><span class="line"><span class="err">DOMAIN-SUFFIX,cn,DIRECT</span>
</span><span class="line"><span class="err">DOMAIN-SUFFIX,qq.com,DIRECT</span>
</span><span class="line"><span class="err">DOMAIN-SUFFIX,ls.apple.com,DIRECT</span>
</span><span class="line"><span class="err">DOMAIN-SUFFIX,apple.com,Proxy</span>
</span><span class="line"><span class="err">...</span>
</span><span class="line">
</span><span class="line"><span class="c1"># 强制这些不尊重系统代理的请求走 packet-tunnel-provider，解决 Twitter.app 和 Mail.app 收发邮件问题</span>
</span><span class="line"><span class="err">DOMAIN-KEYWORD,twitter,Proxy,force-remote-dns</span>
</span><span class="line"><span class="err">DOMAIN-KEYWORD,gmail,Proxy,force-remote-dns</span>
</span><span class="line"><span class="c1"># instagram.app 也没问题</span>
</span><span class="line"><span class="err">DOMAIN-KEYWORD,instagram,Proxy,force-remote-dns</span>
</span><span class="line"><span class="c1"># Telegram.app 也没问题</span>
</span><span class="line"><span class="err">IP-CIDR,91.108.56.0/22,Proxy,force-remote-dns</span>
</span><span class="line"><span class="err">...</span>
</span><span class="line">
</span><span class="line"><span class="c1"># LAN</span>
</span><span class="line"><span class="err">IP-CIDR,192.168.0.0/16,DIRECT</span>
</span><span class="line"><span class="err">...</span>
</span><span class="line">
</span><span class="line"><span class="c1"># 其余的请求使用 GEOIP 判断服务器所在地，如果是国内的，走直连，搞定</span>
</span><span class="line"><span class="err">GEOIP,CN,DIRECT</span>
</span><span class="line">
</span><span class="line"><span class="c1"># 最后 Matchall，丢给代理</span>
</span><span class="line"><span class="err">FINAL,Proxy</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过规则定义和组合，必然可以满足专业用户的需求，非常强大。配置可以使用 app 自带的 GUI，当然也有文本编辑方式。</p>

<p>由于 Surge 的核心和是个 http proxy，有些处理不了的请求我们可以强制 bypass 掉，走系统接口，这个可以在代理设置-高级处设置，如果你不太懂，请不要随意设置。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebook Redex]]></title>
    <link href="http://helloyokoy.github.io/blog/facebook-redex/"/>
    <updated>2016-04-15T17:08:14+08:00</updated>
    <id>http://helloyokoy.github.io/blog/facebook-redex</id>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160414083628369" alt="redex" /></p>

<p>去年，Facebook使用叫ReDex的字节码优化工具优化了他们的安卓应用的性能.</p>

<p>现在，ReDex已经开源了。安卓开发者可以免费地使用这个工具优化自己的应用。也可以将它用作其它安卓字节码优化工具的基础。</p>

<!--more-->

<p>在Facebook工程博客的一篇文章中指出，.DEX（安卓的可执行文件的形式）文件中的类，并不是按照应用启动时候加载的顺序加载的，而是按照编译工具指定的顺序加载的。</p>

<p>ReDex使用程序运行时产生的运行数据判定哪些类应该在.DEX文件中被优先载入。“想要最小化从内存中读取数据的次数，最好从启动的时候就载入字节码。”Facebook称，他们使用ReDex对应用优化之后，对存储的读取减少了25%，运行速度提高了30%。</p>

<p>关于这个速度，Facebook称，在存储较慢的老旧机器上效果非常明显，但是对于新的收集，性能也有明显的提高。Facebook在一台搭载了安卓4.4的全新的Nexus4上（有35%的安卓设备运行这个版本）测试，启动时间从2秒降至1.6秒。</p>

<p>Runtime分析可以用来删除无关的元数据和接口，但是开发者也可以自定义优化的行为。比如，有些方法即使没有直接被调用，也可以让它们保留下来。</p>

<p>这个优化是在应用编译完成之后进行的。也就是说，理论上你也可以结合其他优化，比如对Java进行虚拟机层的优化和语言的优化，像即将到来的Java 9的语言模块特性等等。</p>

<p>优化Java的字节码文件并不是一种新技术。还有其他的开源项目，例如ProGuard就可以通过删除运行时没有使用的代码进行优化。但是它并不能像ReDex那样按照执行顺序来重新组织类。</p>

<hr />
<p>原文链接：  <a href="http://www.infoworld.com/article/3055222/android/">http://www.infoworld.com/article/3055222/android/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emmet 学习]]></title>
    <link href="http://helloyokoy.github.io/blog/emmelearn/"/>
    <updated>2016-01-20T21:33:48+08:00</updated>
    <id>http://helloyokoy.github.io/blog/emmelearn</id>
    <content type="html"><![CDATA[<h3 id="section">介绍</h3>

<p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具:</p>

<p><img src="http://cdn.w3cplus.com/cdn/farfuture/jXcuIfm_Jn4-aJO7c59GOzDUd1163lwYGIWK3PIX2oE/mtime:1421034939/sites/default/files/styles/print_image/public/baiyaimages/emmet-p1.jpg" alt="icon" /></p>

<p>基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。</p>

<p>Emmet 把片段这个概念提高到了一个新的层次：你可以设置 CSS 形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet 是很成熟的并且非常适用于编写 HTML/XML 和 CSS 代码的前端开发人员，但也可以用于编程语言。</p>

<h3 id="section-1">使用示例</h3>

<p>在编辑器中输入缩写代码：ul&gt;li*5 ，然后按下拓展键（默认为 tab ），即可得到代码片段：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;ul&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">&lt;/ul&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<h3 id="section-2">安装</h3>

<p>在线编辑器的支持</p>

<ul>
  <li>JSFiddle</li>
  <li>JS Bin</li>
  <li>CodePen</li>
  <li>ICEcoder</li>
  <li>Divshot</li>
  <li>Codio</li>
</ul>

<p>第三方插件的支持</p>

<p>下面这些编辑器的插件都是由第三方开发者所提供的，所以可能并不支持所有Emmet的功能和特性。</p>

<ul>
  <li>SynWrite</li>
  <li>WebStorm</li>
  <li>PhpStorm</li>
  <li>Vim</li>
  <li>HTML-Kit</li>
  <li>HippoEDIT</li>
  <li>CodeLobster PHP Edition</li>
  <li>TinyMCE</li>
</ul>

<p>因为我也是 Sublime Text的使用者，所以下面为大家介绍一下 sublime text 中 Emmet 的安装方法：</p>

<ol>
  <li>步骤一：首先你需要为 sublime text 安装 Package Control 组件：</li>
</ol>

<ul>
  <li>按 Ctrl + ` 调出 sublime text 的 console</li>
  <li>粘贴以下代码到底部命令行并回车：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installedpackagespath();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>重启 Sublime Text</li>
  <li>在 Perferences-&gt;package settings中 看到 package control，则表示安装成功</li>
</ul>

<ol>
  <li>步骤二：使用 Package Control 安装 Emmet 插件：</li>
</ol>

<ul>
  <li>按 Ctrl+Shift+P 命令板</li>
  <li>输入 install 然后选择 install Package，然后输入 emmet 找到 Emmet Css Snippets，点击就可以自动完成安装。</li>
</ul>

<p><a href="http://www.w3cplus.com/tools/emmet-cheat-sheet.html">语法介绍</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode Plugin]]></title>
    <link href="http://helloyokoy.github.io/blog/xcode-plugin/"/>
    <updated>2015-12-10T16:17:52+08:00</updated>
    <id>http://helloyokoy.github.io/blog/xcode-plugin</id>
    <content type="html"><![CDATA[<p>新版 xcode 插件 不能用 解决方法</p>

<pre><code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID`
</code></pre>

<p>xcode 插件管理器</p>

<pre><code>Alcatraz
</code></pre>

<p>xcode 常用插件</p>

<pre><code>xtodo 
fuzzyautocompelte
codepilot
xcodeboost
xalign
KSimageNamed
xcolors
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Self 和 下划线 _ 区别]]></title>
    <link href="http://helloyokoy.github.io/blog/ios-self/"/>
    <updated>2015-12-05T15:48:50+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ios-self</id>
    <content type="html"><![CDATA[<pre><code>@property (nonatomic,copy) NSString *propertyName;
</code></pre>

<p>self.propertyName是对属性的访问；使用_propertyName是对局部变量的访问。</p>

<p>所有被声明为属性的成员，在iOS5 之前需要使用编译器指令@synthesize 来告诉编译器帮助生成属性的getter,setter方法。
之后这个指令可以不用人为指定了，默认情况下编译器会帮我们生成。</p>

<p>编译器在生成getter,setter方法时是有优先级的，它首先查找当前的类中用户是否已定义属性的getter,setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。</p>

<p>也就是说你在使用self.propertyName 时是在调用一个getter方法。</p>

<pre><code>self.propertyName 会让计数器＋1;_propertyName却不会。  

_propertyName是类似于self-&gt;_propertyName。
</code></pre>

<p>用self.propertyName 是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下划线的时候忽视了self这个指针，后者容易在block中造成循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Grape 构建 RESTful API]]></title>
    <link href="http://helloyokoy.github.io/blog/grape-on-rails/"/>
    <updated>2015-12-04T11:32:56+08:00</updated>
    <id>http://helloyokoy.github.io/blog/grape-on-rails</id>
    <content type="html"><![CDATA[<p><img src="http://blog.lanvige.com/uploads/ruby/grape-logo.png" alt="img" /></p>

<p>Rails中构建API的方式有很多种，Grape因性能而被推荐，其可构建于任何Rack上，仍建议使用Rails作为载体，来构建Grape，会非常省心。</p>

<h3 id="section">安装配置</h3>

<p>首先确保安装：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">## Platform
</span><span class="line">gem 'rails', '4.2.0'
</span><span class="line">
</span><span class="line">## RESTful API Engine
</span><span class="line">gem 'grape'
</span><span class="line">gem 'grape-entity'</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">组织架构</h3>

<h4 id="section-2">目录结构</h4>

<pre><code>api
├── api.rb
└── v1
	├── base.rb
	├── entities
	│   ├── base.rb
	│   └── user_basic.rb
	├── helpers
	│   ├── page_helper.rb
	│   └── user_helper.rb
	├── base_api.rb
	└── users_api.rb
</code></pre>

<p>base.rb 中定义着API的版本、输出格式，及挂载更多API。
users_api.rb 就像controller，对每个resources都进行分开写，然后在base.rb中进行mount
entities 使用grape-entity，控制输出中的对象及格式。
helper 放置常用的helper，像分页，用户验证。</p>

<!--more-->

<p>entities/user_basic.rb</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">module V1
</span><span class="line">  module Entities
</span><span class="line">    class UserBasic &lt; Entities::Base
</span><span class="line">      format_with(:iso8601) { |dt| dt.iso8601 }
</span><span class="line">
</span><span class="line">      expose :id
</span><span class="line">      expose :name
</span><span class="line">      # 如果需要输出层级对象，可以按这种方式
</span><span class="line">      # expose :company, using: Entities::Company
</span><span class="line">
</span><span class="line">      # 日期、时间一律使用ISO 8601
</span><span class="line">      expose :created_at, format_with: :iso8601
</span><span class="line">
</span><span class="line">      # with_options(format_with: :iso8601) do
</span><span class="line">      #   expose :created_at
</span><span class="line">      # end
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>base.rb</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">module V1
</span><span class="line">  class Base &lt; Grape::API
</span><span class="line">    version      'v1'
</span><span class="line">    format       :json
</span><span class="line">
</span><span class="line">    # Mount the APIs
</span><span class="line">    mount UsersApi
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-3">挂载</h4>

<p>routes.rb</p>

<pre><code>mount V1::API =&gt; '/'
</code></pre>

<h4 id="section-4">测试</h4>

<p><a href="http://localhost:3000/v1/users">http://localhost:3000/v1/users</a></p>

<h3 id="best-practices">Best Practices</h3>
<p><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">Best Practices for Designing a Pragmatic RESTful API Vinay Sahni</a></p>

<p><a href="http://www.restapitutorial.com/">A RESTful Tutorial</a></p>

<p>非常推荐 Vinay Sahni的实践，说明的非常清晰，而 RESTful Tutorial 也是推荐，但Wrapper一节不作推荐。</p>

<h3 id="doc-with-swagger-ui">Doc with Swagger UI</h3>

<h4 id="grape-swagger">grape-swagger</h4>

<p>routes.rb</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gem 'grape-swagger'
</span><span class="line">routes.rb
</span><span class="line">
</span><span class="line">add_swagger_documentation
</span><span class="line">./config/initializers/swagger.rb
</span><span class="line">
</span><span class="line">
</span><span class="line">GrapeSwaggerRails.options.url      = '/swagger_doc.json'
</span><span class="line">GrapeSwaggerRails.options.app_url  = 'http://swagger.wordnik.com'</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><a href="http://localhost:3000/swagger_doc.json">http://localhost:3000/swagger_doc.json</a></p>

<h4 id="grapeswaggerrails">GrapeSwaggerRails</h4>

<p>./config/initializers/swagger.rb</p>

<pre><code>gem 'grape-swagger-rails' ./config/initializers/swagger.rb

mount GrapeSwaggerRails::Engine +&gt; '/docs'
</code></pre>

<h3 id="section-5">分页</h3>

<p>类库有will_paginate和<a href="https://github.com/amatsuda/kaminari">Kaminari</a>，示例中选后者。</p>

<p>和Grape结合部分，使用 <a href="https://github.com/davidcelis/api-pagination#grape">api-pagination</a>。</p>

<p>测试：</p>

<p><a href="http://localhost:3000/v1/users?page=2&amp;per_page=2">http://localhost:3000/v1/users?page=2&amp;per_page=2</a></p>

<p>分页有很多种定义方式，建议采用RFC-5988  中所定义。（如上链接）</p>

<h3 id="jsend">JSend</h3>

<p><a href="http://labs.omniti.com/labs/jsend">http://labs.omniti.com/labs/jsend</a></p>

<p>RESTful Tutorial 中推荐过JSend，而之前项目中也使用了类似的格式，就是在数据源外包一层，并加上其它的一些信息，像code, status, message。</p>

<p>这些信息主要是应用于JSONP。<a href="https://github.com/bolasblack/http-api-guide#json-p">建议用该方式</a>：，或者是一些无法获取或处理HTTP Header的JS类库。</p>

<h3 id="partial-response">Partial Response</h3>

<p>Grape中实现参见该文：<a href="http://www.nicolasgarnil.me/blog/2013/crafting-ruby-grape-apis-partial-response-part1/">Crafting Ruby Grape APIs: Partial Response</a></p>

<h3 id="error-">Error 处理</h3>

<p>REF::</p>

<p><a href="https://github.com/bolasblack/http-api-guide">HTTP 接口设计指北</a></p>

<hr />

<p>转载自 <a href="http://blog.lanvige.com/2015/01/13/build-restful-api-with-grape/?utm_source=tuicool&amp;utm_medium=referral">http://blog.lanvige.com/2015/01/13/build-restful-api-with-grape/?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charles]]></title>
    <link href="http://helloyokoy.github.io/blog/charles/"/>
    <updated>2015-11-26T21:34:03+08:00</updated>
    <id>http://helloyokoy.github.io/blog/charles</id>
    <content type="html"><![CDATA[<h3 id="section">简介</h3>

<p><img src="http://blog.devtang.com/images/charles-logo.png" alt="img" /></p>

<p>Charles 是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p>

<p><a href="http://blog.devtang.com/images/charles-logo.png">Charles</a> 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p>

<p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p>

<p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p>

<p>Charles 主要的功能包括：</p>

<p>截取 Http 和 Https 网络封包。</p>

<ol>
  <li>支持重发网络请求，方便后端调试。</li>
  <li>支持修改网络请求参数。</li>
  <li>支持网络请求的截获并动态修改。</li>
  <li>支持模拟慢速网络。</li>
</ol>

<!--more-->

<h3 id="charles">安装 Charles</h3>

<p>去 Charles 的官方网站（<a href="http://www.charlesproxy.com">http://www.charlesproxy.com</a>）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。</p>

<h3 id="charles-">将 Charles 设置成系统代理</h3>

<p>之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。</p>

<p>启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-pro-3.png" alt="img" /></p>

<p>之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。</p>

<p>需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p>

<p>Charles 主界面介绍</p>

<p><img src="http://blog.devtang.com/images/charles-pro-4.png" alt="img" /></p>

<p>Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。</p>

<ol>
  <li>Structure 视图将网络请求按访问的域名分类。</li>
  <li>Sequence 视图将网络请求按访问的时间排序。</li>
</ol>

<p>大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p>

<p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p>

<h3 id="section-1">过滤网络请求</h3>

<p>通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法：</p>

<p>方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuantiku.com , 那么只需要在 Filter 栏中填入 yuantiku 即可。</p>

<p>方法二：在 Charles 的菜单栏选择 “Proxy”–&gt;“Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-filter-setting.jpg" alt="img" /></p>

<p>通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。</p>

<p>方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-focus.png" alt="img" /></p>

<p>这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。</p>

<h3 id="iphone-">截取 iPhone 上的网络封包</h3>

<p>Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。</p>

<p>Charles 上的设置</p>

<p>要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”–&gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:</p>

<p><img src="http://blog.devtang.com/images/charles-proxy-setting.jpg" alt="img" /></p>

<p>iPhone 上的设置</p>

<p>首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-local-ip.png" alt="img" /></p>

<p>在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-iphone-setting.jpg" alt="img" /></p>

<p>设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。</p>

<h3 id="https-">截取 Https 通讯信息</h3>

<p>安装证书</p>

<p>如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p>

<p>首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-pro-1.png" alt="img" /></p>

<p>需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-ssl-add-host.jpg" alt="img" /></p>

<p>这样，对于该 Host 的所有 SSL 请求可以被截取到了。</p>

<h3 id="https--1">截取移动设备中的 Https 通讯信息</h3>

<p>如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-pro-2.png" alt="img" /></p>

<p>按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p>

<h3 id="section-2">模拟慢速网络</h3>

<p>在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。</p>

<p>在 Charles 的菜单上，选择 “Proxy”–&gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-throttle-setting.jpg" alt="img" /></p>

<p>如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p>

<h3 id="section-3">修改网络请求内容</h3>

<p>有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-edit.png" alt="img" /></p>

<p>我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-execute.png" alt="img" /></p>

<h3 id="section-4">给服务器做压力测试</h3>

<p>我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。</p>

<p>我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-repeat-1.png" alt="img" /></p>

<p>接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。</p>

<p><img src="http://blog.devtang.com/images/charles-repeat-2.png" alt="img" /></p>

<p>悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。</p>

<h3 id="section-5">修改服务器返回内容</h3>

<p>有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。</p>

<p>根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p>

<ol>
  <li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li>
  <li>Rewrite 功能适合对网络请求进行一些正则替换。</li>
  <li>Breakpoints 功能适合做一些临时性的修改。</li>
</ol>

<h3 id="map-">Map 功能</h3>

<p>Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。</p>

<p>在 Charles 的菜单中，选择 “Tools”–&gt;“Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。</p>

<p><img src="http://blog.devtang.com/images/charles-map.png" alt="img" /></p>

<p>对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 www.yuantiku.com（线上服务器）。</p>

<p><img src="http://blog.devtang.com/images/charles-map-remote.png" alt="img" /></p>

<p>对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。</p>

<p><img src="http://blog.devtang.com/images/charles-save-response.png" alt="img" /></p>

<p>下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。</p>

<p><img src="http://blog.devtang.com/images/charles-map-local.png" alt="img" /></p>

<h3 id="rewrite-">Rewrite 功能</h3>

<p>Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。</p>

<p>例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-rewrite-1.jpeg" alt="img" /></p>

<p>我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则：</p>

<p><img src="http://blog.devtang.com/images/charles-rewrite-2.png" alt="img" /></p>

<p>完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-rewrite-3.png" alt="img" /></p>

<h3 id="breakpoints-">Breakpoints 功能</h3>

<p>上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。</p>

<p>Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。</p>

<p>下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。</p>

<p><img src="http://blog.devtang.com/images/charles-breakpoint.png" alt="img" /></p>

<p>需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。</p>

<hr />
<p>文章转载自 <a href="http://blog.devtang.com/blog/2015/11/14/charles-introduction/">唐巧个人博客</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails-perftest 分析 Rails 引用的性能]]></title>
    <link href="http://helloyokoy.github.io/blog/rails-perftest/"/>
    <updated>2015-11-07T15:04:49+08:00</updated>
    <id>http://helloyokoy.github.io/blog/rails-perftest</id>
    <content type="html"><![CDATA[<p>这个是 Rails 官方的 Gem，可以直接集成到 Rails 里面</p>

<p>你可以写 Benchmark 的测试用例:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">require 'test_helper'
</span><span class="line">require 'rails/performance_test_help'
</span><span class="line">
</span><span class="line">class HomepageTest &lt; ActionDispatch::PerformanceTest
</span><span class="line">  # Refer to the documentation for all available options
</span><span class="line">  # self.profile_options = { runs: 5, metrics: [:wall_time, :memory],
</span><span class="line">  #                          output: 'tmp/performance', formats: [:flat] }
</span><span class="line">
</span><span class="line">  test "homepage" do
</span><span class="line">    get '/'
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>然后可以执行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ rake test:benchmark
</span><span class="line">HomepageTest#test_homepage (31 ms warmup)
</span><span class="line">           wall_time: 6 ms
</span><span class="line">              memory: 437.27 KB
</span><span class="line">             objects: 5,514
</span><span class="line">             gc_runs: 0
</span><span class="line">             gc_time: 19 ms</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你可以直接在命令行使用</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ perftest profiler 'User.first' --runs 3
</span><span class="line">ProfilerTest#test_user_first (3 ms warmup)
</span><span class="line">        process_time: 4 ms
</span><span class="line">              memory: 289 Bytes
</span><span class="line">             objects: 551</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你还可以用 Helper 在 View, Controler, Model 里面打点统计</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># app/controllers/topics_controller.rb
</span><span class="line">class TopicsController &lt; ApplicationController
</span><span class="line">  def index
</span><span class="line">    benchmark("  Benchmark: topics/index/suggest_topics") do
</span><span class="line">      @suggest_topics = Topic.without_hide_nodes.suggest.limit(3)
</span><span class="line">    end
</span><span class="line">    ...
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Rails log 将会输出</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># development.log
</span><span class="line">Started GET "/topics" for 127.0.0.1 at 2015-01-01 00:50:19 +0800
</span><span class="line">  ...
</span><span class="line">  Benchmark:  topics/index/suggest_topics (1.4ms)
</span><span class="line">  ...
</span><span class="line">Completed 200 OK in 121ms (Views: 108.1ms)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有更多功能待你发现哦!</p>

<hr />
<p><a href="https://github.com/rails/rails-perftest">https://github.com/rails/rails-perftest</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web开发cache]]></title>
    <link href="http://helloyokoy.github.io/blog/web-cache/"/>
    <updated>2015-11-04T16:55:48+08:00</updated>
    <id>http://helloyokoy.github.io/blog/web-cache</id>
    <content type="html"><![CDATA[<p>总结web应用中常用的各种cache</p>

<p>cache是提高应用性能重要的一个环节，写篇文章总结一下用过的各种对于动态内容的cache。
文章以Nginx，Rails，Mysql，Redis作为例子，换成其他web服务器，语言，数据库，缓存服务都是类似的。
以下是3层的示意图，方便后续引用：</p>

<pre><code>                      +-------+
1                     | Nginx |
                      +-+-+-+-+
                        | | |
        +---------------+ | +---------------+
        |                 |                 |
    +---+---+         +---+---+         +---+---+
2   |Unicorn|         |Unicorn|         |Unicorn|
    +---+---+         +---+---+         +---+---+
        |                 |                 |
        |                 |                 |
        |             +---+---+             |
3        +-------------+  D B  +-------------+
                      +-------+
</code></pre>

<!--more-->

<ol>
  <li>
    <h2 id="section">客户端缓存</h2>
  </li>
</ol>

<p>一个客户端经常会访问同一个资源，比如用浏览器访问网站首页或查看同一篇文章，或用app访问同一个api，如果该资源和他之前访问过的没有任何改变，就可以利用http规范中的304 Not Modified 响应头( http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 )，直接用客户端的缓存，而无需在服务器端再生成一次内容。
在Rails里面内置了fresh_when这个方法，一行代码就可以完成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class ArticlesController
</span><span class="line">  def show
</span><span class="line">    @article = Article.find(params[:id])
</span><span class="line">    fresh_when :last_modified =&gt; @article.updated_at.utc, :etag =&gt; @article
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下次用户再访问的时候，会对比request header里面的If-Modified-Since和If-None-Match，如果相符合，就直接返回304，而不再生成response body。</p>

<p>但是这样会遇到一个问题，假设我们的网站导航有用户信息，一个用户在未登陆专题访问了一下，然后登陆以后再访问，会发现页面上显示的还是未登陆状态。或者在app访问一篇文章，做了一下收藏，下次再进入这篇文章，还是显示未收藏状态。解决这个问题的方法很简单，将用户相关的变量也加入到etag的计算里面：</p>

<pre><code>fresh_when :etag =&gt; [@article.cache_key, current_user.id]
fresh_when :etag =&gt; [@article.cache_key, current_user_favorited] 另外提一个坑，如果nginx开启了gzip，对rails执行的结果进行压缩，会将rails输出的etag header干掉，nginx的开发人员说根据rfc规范，对proxy_pass方式处理必须这样（因为内容改变了），但是我个人认为没这个必要，于是用了粗暴的方法，直接将src/http/modules/ngx_http_gzip_filter_module.c这个文件里面的这行代码注释掉，然后重新编译nginx：

//ngx_http_clear_etag(r); 或者你可以选择不改变nginx源代码，将gzip off掉，将压缩用Rack中间件来处理：

config.middleware.use Rack::Deflater 除了在controller里面指定fresh_when以外，rails框架默认使用Rack::ETag middleware，它会自动给无etag的response加上etag，但是和fresh_when相比，自动etag能够节省的只是客户端时间，服务器端还是一样会执行所有的代码，用curl来对比一下。 Rack::ETag自动加入etag：
</code></pre>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">curl -v http://localhost:3000/articles/1
</span><span class="line">&lt; Etag: "bf328447bcb2b8706193a50962035619"
</span><span class="line">&lt; X-Runtime: 0.286958
</span><span class="line">curl -v http://localhost:3000/articles/1 --header 'If-None-Match: "bf328447bcb2b8706193a50962035619"'
</span><span class="line">&lt; X-Runtime: 0.293798</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用fresh_when：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">curl -v http://localhost:3000/articles/1 --header 'If-None-Match: "bf328447bcb2b8706193a50962035619"'
</span><span class="line">&lt; X-Runtime: 0.033884</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>
    <h2 id="nginx">Nginx缓存</h2>
  </li>
</ol>

<p>有一些资源可能会被调用很多，又无关用户状态，并且很少改变，比如新闻app上的列表api，购物网站上ajax请求分类菜单，可以考虑用Nginx来做缓存。
主要有2种实现方法：
####A. 动态请求静态文件化
在rails请求完成以后，将结果保存成静态文件，后续请求就会直接由nginx提供静态文件内容，用after_filter来实现一下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class CategoriesController &lt; ActionController::Base
</span><span class="line">  after_filter :generate_static_file, :only =&gt; [:index]
</span><span class="line">
</span><span class="line">  def index
</span><span class="line">    @categories = Category.all
</span><span class="line">  end
</span><span class="line">
</span><span class="line">  def generate_static_file
</span><span class="line">    File.open(Rails.root.join('public', 'categories'), 'w') do |f|
</span><span class="line">      f.write response.body
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外我们需要在任何分类更新的时候，删除掉这个文件，避免缓存不刷新的问题：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class Category &lt; ActiveRecord::Base
</span><span class="line">  after_save :delete_static_file
</span><span class="line">  after_destroy :delete_static_file
</span><span class="line">
</span><span class="line">  def delete_static_file
</span><span class="line">    File.delete Rails.root.join('public', 'categories')
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Rails 4之前，处理这种生成静态文件缓存可以用内置的caches_page， rails 4之后变成了一个独立gem actionpack-page_caching，和手工代码对比一下，</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class CategoriesController &lt; ActionController::Base
</span><span class="line">  caches_page :index
</span><span class="line">
</span><span class="line">  def update
</span><span class="line">    #...
</span><span class="line">    expire_page action: 'index'
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果只有一台服务器，这个方法简单又实用，但是如果有多台服务器，就会出现更新分类只能刷新自己本身这台服务器缓存的问题，可以用nfs来共享静态资源目录解决，或者用第2种：</p>

<h4 id="b-">B. 静态化到集中缓存服务</h4>
<p>首先我们得让Nginx有直接访问缓存的能力：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">upstream redis {
</span><span class="line">    server redis_server_ip:6379;
</span><span class="line">  }
</span><span class="line">
</span><span class="line">  upstream ruby_backend {
</span><span class="line">    server unicorn_server_ip1 fail_timeout=0;
</span><span class="line">    server unicorn_server_ip2 fail_timeout=0;
</span><span class="line">  }
</span><span class="line">
</span><span class="line">  location /categories {
</span><span class="line">    set $redis_key $uri;
</span><span class="line">    default_type   text/html;
</span><span class="line">    redis_pass redis;
</span><span class="line">    error_page 404 = @httpapp;
</span><span class="line">  }
</span><span class="line">
</span><span class="line">  location @httpapp {
</span><span class="line">    proxy_pass http://ruby_backend;
</span><span class="line">  }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Nginx首先会用请求的uri作为key去redis里面获取，如果获取不到（404）就转发给unicorn进行处理，然后改写generate_static_file和delete_static_file方法：</p>

<pre><code>redis_cache.set('categories', response.body)
  	
redis_cache.del('categories')
</code></pre>

<p>这样除了集中管理以外，还能够设置缓存的失效时间，对于一些更新无时效性要求的数据，就可以不用处理刷新机制，简单地固定时间刷新一次：</p>

<pre><code>redis_cache.setex('categories', 3.hours.to_i, response.body)
</code></pre>

<ol>
  <li>
    <h2 id="section-1">整页缓存</h2>
  </li>
</ol>

<p>Nginx缓存在处理带参数资源或者有用户状态的请求时候，就非常难以处理，这个时候可以用到整页缓存。
比如说分页请求列表，我们可以将page参数加入到cache_path：</p>

<pre><code>class CategoriesController
  	caches_action :index, :expires_in =&gt; 1.day, :cache_path =&gt; proc 	{"categories/index/#{params[:page].to_i}"}
end
</code></pre>

<p>比如说我们只需要针对rss输出进行缓存8小时：</p>

<pre><code>class ArticlesController
  	caches_action :index, :expires_in =&gt; 8.hours, :if =&gt; proc 	{request.format.rss?}
end 再比如说对于非登陆用户，我们可以缓存首页：

class HomeController
  	caches_action :index, :expires_in =&gt; 3.hours, :if =&gt; proc {!	user_signed_in?}
end
</code></pre>

<ol>
  <li>
    <h2 id="section-2">片段缓存</h2>
  </li>
</ol>

<p>如果说前面2种缓存能够用到的场景有限，那么片段缓存是适用性最广的。</p>

<h4 id="section-3">场景1：</h4>

<p>我们需要在每个页面一段广告代码，用来显示不同广告，如果没有使用片段缓存，那么每个页面都会要去查询广告的代码，并且花费一定时间去生成html代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class="line">  div.ad
</span><span class="line">    = advert.content</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>加了片段缓存以后，就可以少去这个查询：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- cache "adverts/#{request.controller_name}/#{request.action_name}", :expires_in =&gt; 1.day do
</span><span class="line">  - if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class="line">    div.ad
</span><span class="line">      = advert.content</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-4">场景2：</h4>
<p>阅读文章，文章的内容可能比较长时间都不会改变，经常变化可能是文章评论，就可以对文章主体部分加上片段缓存：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- cache "articles/#{@article.id}/#{@article.updated_at.to_i}" do
</span><span class="line">  div.article
</span><span class="line">    = @article.content.markdown2html</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>节约了生成markdown语法转换到html时间，这里用文章最后更新时间作为cache key的一部分，文章内容如果有改变，缓存自动失效，默认activerecord的cache_key方法也是用updated_at，你也可以加入更多的参数，比如article上有评论数的counter cache，更新评论数的时候不会更新文章时间，可以将这个counter也加入到key的一部分</p>

<h4 id="section-5">场景3：</h4>
<p>复杂页面结构的生成</p>

<p>数据结构比较复杂的页面，在生成的时候避免不了大量的查询和html渲染，用片段缓存，可以将这部分时间大大地节约，以我们网站游记页面 http://chanyouji.com/trips/109123 （请允许小小地打个广告，带点流量）来说：</p>

<p>需要获取天气数据，照片数据，文本数据等，同时还要生成meta，keyword等seo数据，而这些内容又是和其他动态内容交叉，片段缓存就可以分开多个：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- cache "trips/show/seo/#{@trip.fragment_cache_key}", :expires_in =&gt; 1.day do
</span><span class="line">  title #{trip_name @trip}
</span><span class="line">  meta name="description" content="..."
</span><span class="line">  meta name="keywords" content="..."
</span><span class="line">
</span><span class="line">body
</span><span class="line">  div
</span><span class="line">    ...
</span><span class="line">- cache "trips/show/viewer/#{@trip.fragment_cache_key}", :expires_in =&gt; 1.day do
</span><span class="line">  - @trip.eager_load_all</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>小贴士，我在trip对象里面加了一个eager_load_all方法，缓存没有命中的时候，查询的时候避免出现n+1问题：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def eager_load_all
</span><span class="line">    ActiveRecord::Associations::Preloader.new([self], {:trip_days =&gt; [:weather_station_data, :nodes =&gt; [:entry, :notes =&gt; [:photo, :video, :audio]]]}).run
</span><span class="line">  end</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-6">小技巧1：带条件的片段缓存</h4>

<p>和caches_action不同，rails自带的片段缓存是不支持条件的，比如说我们想未登陆用户给他用片段缓存，而登陆用户不使用，写起来就很麻烦，我们可以改写一下helper就可以了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def cache_if (condition, name = {}, cache_options = {}, &amp;block)
</span><span class="line">    if condition
</span><span class="line">      cache(name, cache_options, &amp;block)
</span><span class="line">    else
</span><span class="line">      yield
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">
</span><span class="line">
</span><span class="line">- cache_if !user_signed_in?, "xxx", :expires_in =&gt; 1.day do</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-7">小技巧2：关联对象的自动更新</h4>

<p>常使用对象update_at时间戳来作为cache key，可以在关联对象上加上touch选项，自动更新关联对象时间戳，比如我们可以在更新或者删除文章评论的时候，自动个更新：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class Article
</span><span class="line">  has_many :comments
</span><span class="line">end
</span><span class="line">
</span><span class="line">class Comment
</span><span class="line">  belongs_to :article, :touch =&gt; true
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>
    <h2 id="section-8">数据查询缓存</h2>
  </li>
</ol>

<p>通常来说web应用性能瓶颈都出现在DB IO上，做好数据查询缓存，减少数据库的查询次数，可以极大提高整体响应时间。
数据查询缓存分2种：</p>

<h4 id="a-">A. 同一个请求周期内的缓存</h4>

<p>举一个显示文章列表的例子，输出文章标题和文章类别，对应代码如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># controller
</span><span class="line">  def index
</span><span class="line">    @articles = Article.first(10)
</span><span class="line">  end
</span><span class="line">
</span><span class="line"># view
</span><span class="line">- @articles.each do |article|
</span><span class="line">  h1 = article.name
</span><span class="line">  span = article.category.name</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>会发生10条类似的sql查询：</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` = ?
</code></pre>

<p>rails内置了query cache</p>

<p><a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb</a>，</p>

<p>在同一个请求周期内，如果没有update/delete/insert的操作，会对相同的sql查询进行缓存，如果文章类别都是相同的话，真正去查询数据库只会有1次。</p>

<p>如果文章类别都不一样，就会出现N+1查询问题（常见的性能瓶颈），rails推荐的解决方法是用Eager Loading Associations</p>

<p><a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def index
</span><span class="line">    	@articles = Article.includes(:category).first(10)
</span><span class="line">  	end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>查询语句会变成</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` in (?,?,?...)
</code></pre>

<h4 id="b--1">B. 跨请求周期的缓存</h4>

<p>同请求周期缓存所带来性能优化是很有限的，很多时候我们需要用跨请求周期的缓存，将一些常用的数据（比如User model）缓存，对于active record来说，利用统一的查询接口来fetch cache，利用callback来expire cache，就很容易实现，而且有一些现成的gem可以来用。</p>

<p>比如说 identity_cache</p>

<p><a href="https://github.com/Shopify/identity_cache">https://github.com/Shopify/identity_cache</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class User &lt; ActiveRecord::Base
</span><span class="line">  include IdentityCache
</span><span class="line">end
</span><span class="line">
</span><span class="line">class Article &lt; ActiveRecord::Base
</span><span class="line">  include IdentityCache
</span><span class="line">  cached_belongs_to :user
</span><span class="line">end
</span><span class="line">
</span><span class="line">
</span><span class="line"># 都会命中缓存
</span><span class="line">User.fetch(1)
</span><span class="line">Article.find(2).user</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个gem的优点是代码实现简单，cache设置灵活，也方便扩展，缺点是需要用不同的查询方法名（fetch），以及额外的关系定义。</p>

<p>如果想在无数据缓存的应用无缝加入缓存功能，推荐@hooopo 做的second_level_cache</p>

<p><a href="https://github.com/hooopo/second_level_cache">https://github.com/hooopo/second_level_cache</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class User &lt; ActiveRecord::Base
</span><span class="line">  acts_as_cached(:version =&gt; 1, :expires_in =&gt; 1.week)
</span><span class="line">end
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line">#还是使用find方法，就会命中缓存
</span><span class="line">User.find(1)
</span><span class="line">#无需额外用不一样的belongs_to定义
</span><span class="line">Article.find(2).user</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>实现原理是扩展了active record底层arel sql ast处理</p>

<p><a href="https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb">https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb</a></p>

<p>它的优点是无缝接入，缺点是扩展比较困难，对于只获取少量字段的查询无法缓存。</p>

<ol>
  <li>
    <h2 id="section-9">数据库缓存</h2>
  </li>
</ol>

<p>编辑中</p>

<p>这6种缓存，分布在客户端到服务器端不同的位置，所能够节约的时间也正好从多到少依次排列。</p>

<hr />
<p>转载自  <a href="https://ruby-china.org/topics/19389">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 2 Plugin]]></title>
    <link href="http://helloyokoy.github.io/blog/sublime-text-2-plugin/"/>
    <updated>2015-11-01T19:58:52+08:00</updated>
    <id>http://helloyokoy.github.io/blog/sublime-text-2-plugin</id>
    <content type="html"><![CDATA[<p>Sublime Text 2是一个轻量、简洁、高效、跨平台的编辑器，方便的配色以及兼容vim快捷键等各种优点博得了很多前端开发人员的喜爱。之前也不并知道它有这么多插件的扩展与支持，直到vincent问到有没有在用cTags插件，才知道原来Sublime通过插件也可以实现一些大型IDE的功能，遂google一下，本篇Blog就来介绍下Sublime下经常使用的插件。</p>

<h4 id="package-control">安装包控制（Package Control）</h4>

<p>打开Sublime Text 2，点击 Tools -&gt; Command Palette 调出控制台Console；</p>

<p>将以下代码粘贴进命令行中并回车：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>重启 Sublime Text 2，如果在 Preferences -&gt; Package Settings中见到Package Control这一项，就说明安装成功了。</p>

<!--more-->

<h4 id="alignment">安装Alignment插件</h4>
<p>对于某些喜欢整齐的程序员来说，看到下面这种情况可能是让其无法忍受的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">var joe = 'joe';
</span><span class="line">var johnny = 'johnny';
</span><span class="line">var quaid = 'quaid';</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一定要改成这样才会安心：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">var joe    = 'joe';
</span><span class="line">var johnny = 'johnny';
</span><span class="line">var quaid  = 'quaid';</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Sublime Text 2 之中，一个 Sublime Alignment 插件也可以轻松实现。</p>

<ol>
  <li>
    <p>按下 Ctrl + Shift + P 调出命令面板。</p>
  </li>
  <li>
    <p>输入 install 调出 Package Control: Install Package 选项，按下回车。</p>
  </li>
  <li>
    <p>在列表中找到 Alignment，按下回车进行安装。</p>
  </li>
  <li>
    <p>重启 Sublime Text 2 使之生效。现在通过选中文本并按 Ctrl + Shift + A 就可以进行对齐操作了。</p>
  </li>
</ol>

<h4 id="vim">Vim模式</h4>

<p>是的，Sublime Text 2已经支持 Vim 的编辑模式了，如果更喜欢 Vim 的编辑模式，可以通过以下方法来激活 Vintage mode：</p>

<ol>
  <li>
    <p>按下 Ctrl + Shift + P 调出命令面板。</p>
  </li>
  <li>
    <p>输入 settings user 调出 Preferences：Settings - User，并按下回车。</p>
  </li>
  <li>
    <p>这时会打开一个 Preferences.sublime-settings 的文件， 如果是第一次修改，它应该是个空文件，把以下文本粘贴进去：</p>

    <p>{
  		“ignored_packages”: []
 }</p>
  </li>
  <li>
    <p>保存这个文件，这时按下 ESC 键，再按下一些你熟悉的 Vim 命令，是不是很有亲切感？</p>
  </li>
</ol>

<h4 id="soda-">安装 Soda 主题</h4>
<p>这里所讲的主题不同于针对代码的 Color Scheme，是指针对 Sublime 程序本身的主题，目前可以安装的是 Ian Hill 的 Soda。</p>

<p>因为源中已经添加，所以这款主题的安装同样可以通过 Package Control，非常方便。目前 Soda 主题提供了明暗两种风格。</p>

<p>激活方法，同样要修改 Preferences：Settings - User：</p>

<ol>
  <li>
    <p>按下 Ctrl + Shift + P 调出命令面板。</p>
  </li>
  <li>
    <p>输入 user settings 调出 Preferences：Settings - User，并按下回车。</p>
  </li>
  <li>
    <p>添加以下代码激活 Soda Light 主题：</p>

    <p>{
  		“theme”: “Soda Light.sublime-theme”
 }</p>

    <p>添加以下代码激活 Soda Dark 主题：</p>

    <p>{
  		“theme”: “Soda Dark.sublime-theme”
 }</p>
  </li>
  <li>
    <p>保存生效。</p>
  </li>
</ol>

<h4 id="ctags">安装cTags插件</h4>
<p>这个插件能跨文件跳转，实现像eclipse可那样以追踪函数的功能，从此更喜欢上Sublime了。安装方法:</p>

<ol>
  <li>
    <p>按下 Ctrl + Shift + P 调出命令面板。</p>
  </li>
  <li>
    <p>输入 install 调出 Package Control: Install Package 选项，按下回车。</p>
  </li>
  <li>
    <p>在列表中找到 ctags，按下回车进行安装。</p>
  </li>
  <li>
    <p>ubuntu下安装运行命令：sudo apt-get install exuberant-ctags。</p>
  </li>
  <li>
    <p>在sublime项目文件夹右键， 会出现Ctag:Rebuild Tags 的菜单。点击它，然后会生成.tags的文件。</p>
  </li>
</ol>

<p>然后在你代码中， 光标放在某个函数上， 点击ctrl+shift+鼠标左键 就可以跳转到函数声明的地方。</p>

<h4 id="zen-coding">Zen Coding</h4>
<p>如果经常要写一些前端的代码，这个插件也是必不可少的，还不知道ZenCoding的同学推荐去看一下：《Zen Coding: 一种快速编写HTML/CSS代码的方法》</p>

<h4 id="git">Git</h4>
<p>一个整合GIT和Sublime Text的插件，执行了很多你需要使用的命令。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Gems内存泄露]]></title>
    <link href="http://helloyokoy.github.io/blog/ruby-gems-memory-leak/"/>
    <updated>2015-10-25T15:01:34+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ruby-gems-memory-leak</id>
    <content type="html"><![CDATA[<p>请大家检查下 Gemfile.lock，若在使用如下版本的gem包，那么请及时更新</p>

<ul>
  <li>
    <p>therubyracer &lt; 0.12.2</p>
  </li>
  <li>
    <p>sidekiq &lt; 3.5.1</p>
  </li>
  <li>
    <p>celluloid &gt; 0.16.0, &lt; 0.17.2</p>
  </li>
  <li>
    <p>zipruby &lt;= 0.3.6</p>
  </li>
  <li>
    <p>redcarpet &lt; 3.3.3</p>
  </li>
  <li>
    <p>grape &lt; 0.2.5</p>
  </li>
</ul>

<p><a href="https://github.com/ASoftCo/leaky-gems">https://github.com/ASoftCo/leaky-gems</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Gems 推荐]]></title>
    <link href="http://helloyokoy.github.io/blog/rails-gems-recomend/"/>
    <updated>2015-10-09T12:31:27+08:00</updated>
    <id>http://helloyokoy.github.io/blog/rails-gems-recomend</id>
    <content type="html"><![CDATA[<p>Rails社区的gem库，按我感觉质量普遍比较高，这跟Rails社区的氛围有关，以下推荐的是我个人在项目中时常用到的并且比较主流的gem，想到哪儿写到哪儿，挂一漏万。</p>

<h4 id="bootstrapbootstrap-sass">1.bootstrap（bootstrap-sass）</h4>

<p>这个不用解释了吧，对于没有专业前端小伙伴的项目和团队是福音。而且对于想要学习前端技术的同学，bootstrap的源码非常值得进行深入的学习和理解。当然，缺点也是有的，就是大家的网站做出来都比较像，建议有条件的小伙伴使用的时候还是多进行一些个性化修改。</p>

<h4 id="capistranocapistrano--rubygemsorg">2.Capistrano（capistrano | RubyGems.org）</h4>

<p>Capistrano最初就是用来向服务器部署ruby应用的，当然现在也开始支持其他类型项目的部署。Capistrano是一种在多台服务器上运行脚本的开源工具，它主要用于部署web应用。它自动完成多台服务器上新版本的同步更新，包括数据库的改变。使用起来非常方便，基本也是Rails应用开发必备。</p>

<h4 id="bcryptbcrypt--rubygemsorg">3.bcrypt（bcrypt | RubyGems.org）</h4>

<p>bcrypt是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。在rails上使用起来相当简便，web开发一般是少不了的。</p>

<h4 id="sprocketssprockets--rubygemsorg">4.sprockets（sprockets | RubyGems.org）</h4>

<p>Sprockets 是一个 Ruby 库，用来检查 JavaScript 文件的相互依赖关系，用以优化网页中引入的js文件，以避免加载不必要的js文件，加快网页访问速度。这个现在貌似是rails工程默认自带gem，记不太清了，足见重要性。但是我在使用中发现有时候会跟bootstrap的js库发生冲突，主要是版本问题，有使用的小伙伴需要注意一下。</p>

<!--more-->

<h4 id="paperclippaperclip--rubygemsorg">5.Paperclip（paperclip | RubyGems.org）</h4>

<p>paperclip基本上已经是rails的御用图片上传gem了，功能强大使用方便，但是唯一不太好的就是图片剪裁上面功能比较有限。paperclip依赖于ImageMagic，大部分linux包管理器（如apt yum portage等）中应该都能找到这个软件包。</p>

<h4 id="rmagickrmagick--rubygemsorg">6.rmagick（rmagick | RubyGems.org）</h4>

<p>这个gem弥补了paperclip在图片剪裁上的不足。功能十分十分十分的强大，文档也很齐全，只不过是全英文，中文资料比较少。如果项目有要开发头像剪裁上传，那么用rmagic剪裁，paperclip上传是比较好的解决方案。</p>

<h4 id="friendlyidfriendlyid--rubygemsorg">7.friendly_id（friendly_id | RubyGems.org）</h4>

<p>现在大部分网站都已经是友好的url地址了，如果你的rails项目还用数字作为id进行查询那就太low了。</p>

<h4 id="willpaginatewillpaginate">8.will_paginate（will_paginate）</h4>

<p>老版本的will_paginate分业是基于plugin方式的，新版本的will_paginate已经抛弃了这样的做法，转而使用gem的方式。这样一来安装和使用更加方便，配合一些前端的分页加载库，会让分页加载功能开发非常快捷。</p>

<h4 id="ransackransack--rubygemsorg">9.ransack（ransack | RubyGems.org）</h4>

<p>搜索功能一般分为分词和不分词的，如果你只想做用户和文章标题检索之类的功能，那么不分词的搜索gem比较合适，类似的gem挺多的，我常用的是这个。</p>

<h4 id="sunspotsunspot--rubygemsorg">10.sunspot（sunspot | RubyGems.org）</h4>

<p>接上面，全文搜索的gem也不少，sunspot对于小型项目的话，稍微有些重。如果没有那么多要求的话，sphinx也可以考虑，速度快，占用资源低。</p>

<h4 id="gecodergeocoder--rubygemsorg">11.Gecoder（geocoder | RubyGems.org）</h4>

<p>说实话在web上做定位确实比较乏力，尽量还是用手机客户端吧</p>

<h4 id="pumapumapuma--github">12.puma（puma/puma · GitHub）</h4>

<p>对于想要处理并发请求的web项目，Puma 是和 Unicorn相竞争的 Web 服务器，它能够处理并发请求。Puma 使用线程，以及工作者进程，能够更多的利用可用的 CPU。在 Puma 中，如果整个基础代码是线程安全的，那么你可用利用线程。否则，在使用 Puma 的时候，你只能使用工作者进程进行拓展。Puma的设置也比较简单，官方有详细的使用文档，RubyChina也使用Puma，个人推荐。</p>

<h4 id="emojiwpetersonemoji--github">13.Emoji（wpeterson/emoji · GitHub）</h4>

<p>现在只要涉及社交的项目估计很少有不用表情的了，Emoji是个集成度比较高的Emoji表情转码库，使用方便，当然大部分情况下还是要配合前端使用。</p>

]]></content>
  </entry>
  
</feed>
