
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>BryanFu Blog</title>
	<meta name="author" content="BryanFu">

	
	<meta name="description" content="awesome-swift 其实这个系列的还有很多，极大的方便了开发者寻找自己需要的基础控件和工具。 本着记录和分享的态度，已下对本人觉得有必要深入了解，并可以使用在 swift 上的开源项目进行罗列。 Dollar github 地址： Dollar 推荐理由：操作数组的神器 简介： &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="BryanFu Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66019285-2', 'auto');
  ga('send', 'pageview');

</script>

</head>


<body>
	<header id="header" class="inner"><h1><a href="/">BryanFu Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">文章列表</a></li>
	<li><a href="/blog/categories/ios">iOS</a></li>
	<li><a href="/blog/categories/android">Android</a></li>
	<li><a href="/blog/categories/ruby">Ruby</a></li>
	<li><a href="/blog/categories/nodejs">NodeJS</a></li>
	<li><a href="/blog/categories/other">Other</a></li>
	<li><a href="/about">关于</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">文章列表</a></li>
	<li><a href="/blog/categories/ios">iOS</a></li>
	<li><a href="/blog/categories/android">Android</a></li>
	<li><a href="/blog/categories/ruby">Ruby</a></li>
	<li><a href="/blog/categories/nodejs">NodeJS</a></li>
	<li><a href="/blog/categories/other">Other</a></li>
	<li><a href="/about">关于</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:helloyokoy.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/helloyokoy" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:helloyokoy.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/swift-3-dot-0/">
		
			Swift 3.0</a>
	</h2>
	<div class="entry-content">
		<p><a href="https://github.com/matteocrippa/awesome-swift">awesome-swift</a></p>

<p>其实这个系列的还有很多，极大的方便了开发者寻找自己需要的基础控件和工具。</p>

<p>本着记录和分享的态度，已下对本人觉得有必要深入了解，并可以使用在 swift 上的开源项目进行罗列。</p>

<p>Dollar</p>

<p>github 地址： Dollar</p>

<p>推荐理由：操作数组的神器</p>

<p>简介：正如推荐的中所说，Dollar 是一个用来处理数组的工具集。
Dollar 很强大，她优雅的为我们提供了解决数组，字典等对象的基本操作。比如将数组划分成若干个子集，如果我们自己动手做，那少不了for循环加各种判断。但使用 Dollar 一行代码就能搞定。具体接口可以去 github 上查阅。</p>

<p>主要包括以下中对象的操作</p>

<p>Array
Dictionary
Object
Function
Chaining</p>

<p>SwiftyJSON</p>

<p>github 地址：SwiftyJSON</p>

<p>推荐理由： 用过，因为是swift编写的所以性能和理解上不存在问题</p>

<p>简介：是一个使用简单的处理 json 格式数据的工具
详细的介绍和使用方法可参看 SwiftyJSON DOC 。这里多说一句，SwiftyJSON 的主要目的简化 JSON 数据的解析过程。但建模型的时候还是需要依次获取 JSON 里的数据赋值给模型。当 JSON 数据参数很多的时候，编写起来会费劲。所以推荐与 ObjectMapper 一起使用。</p>

<p>ObjectMapper</p>

<p>github 地址：ObjectMapper</p>

<p>推荐理由： 用过，很方便而且直观。只需要在 model 中引用 ObjectMapper 用法即可</p>

<p>简介：让数据模型的构造如此简单
可能你会有疑问，竟然 ObjectMapper 能将 jsonString 直接转换成 model 那为什么还要使用上面的 SwiftyJSON . 这是因为我们的 JSON 数据中并不是所有内容都是我们需要的，我们可以通过 SwiftyJSON 先获取我们需要的数据块，然后在通过 ObjectMapper 获取 model。</p>

<p>Alamofire</p>

<p>github 地址：Alamofire</p>

<p>推荐理由：用过，OC 上广为流传的网络请求框架 AFNetworking 已经有20000+的star，但对于 swift 开发，个人理解还是要用 swift 的框架的工具比较合适。并且她有多个扩展的工具集，配合使用功能还是很强大的。</p>

<p>简介：无</p>

<p>Alamofire 扩展</p>

<p>AlamofireImage – AlamofireImage is an image component library for Alamofire。（用过，使用简单，加载性能也还不错，只是没有深入了解其缓存数据的问题）
AlamofireNetworkActivityIndicator – Controls the visibility of the network activity indicator on iOS using Alamofire
AlamofireObjectMapper – An extension to Alamofire which automatically converts JSON response data into swift objects using ObjectMapper.(个人觉得不是很好用，除非网络返回的 JSON 数据格式单一，不需要任何截取操作)</p>

<p>DEMO：</p>

<p>// HttpManager.swift
// 使用Alamfire网络请求
// success: (json: JSON)-&gt;Void, errors: ()-&gt;Void 这两个闭包用来处理成功和错误的操作
// url：访问地址；parameters；参数
func requestForGetWithParameters(url: String, parameters params: [String:String], success: (json: JSON)-&gt;Void, errors: ()-&gt;Void) {</p>

<pre><code>    // 使用 Alamofire 进行网络数据请求
    Alamofire.request(.GET, url, parameters: params).responseJSON {response in
        switch response.result {
        case .Success:
            if let value = response.result.value {
                let json = JSON(value)
                NSLog("JSON: \(json["result"])")
                guard let result = json["result"].string where result == "SUCCESS" else {
                    errors()
                    return
                }
                success(json: json)
            }
            break
        case .Failure(let error):
            NSLog("error,failure: \(error)")
            errors()
            break
        }
    }
}
</code></pre>

<p>// ViewController.swift 
 // 获取JSON数据，截取需要的数据，生成model
 func onLoadMore() {
        HttpManager.sharedInstance.requestForGetWithPageIndex(
            URL_HOME_ONE,
            pageIndex: pageIndex,
            success: { json in
                // 这里很重要，是用来SwiftyJSON和ObjectMapper生成model
                let home = Mapper<Home>().map(json["hpEntity"].rawValue)
                self.apps.append(home!)
                HomePageViewCell.layoutHeight(home!) //计算cell内容高度
                self.pageIndex++
                self.htv!.tableView?.reloadData()
            },
            error: {
                ProgressHUD.showWarningWithStatus("没有更多内容可加载！")
                // 滑动tableview到最后一个cell
                self.htv!.tableView?.selectRowAtIndexPath(NSIndexPath(forRow: 9, inSection: 0), animated: false, scrollPosition: UITableViewScrollPosition.Bottom)
        })
    }
就此，网络获取的请求、json 数据处理，model生成就完成了。其实还是挺方便的。</Home></p>

<p>SnapKit</p>

<p>github 地址：SnapKit</p>

<p>简介：SnapKit is a DSL to make Auto Layout easy。
doc：http://snapkit.io/docs/</p>

<p>因为没有详细研究过，所以不好多说。只简单谈一谈对Auto Layout的理解。Auto Layout 是 Apple 专门用来配合 IB(Inerface Builder) 解决多拼适配问题的（这样说当然也有不合适的地方）。通过 IB 设置控件之间的约束，使控件在不同设备上相对距离和大小一致。然而不管是通过 IB 还是代码实现这些约束，都不是一件容易的事情。尤其代码实现，对经验不足的人来说，简直是地狱。SnapKit 则对代码实现约束做了封装，对布局的理解简单化，也更直观。
SnapKit 虽然是利器，但用不好就会变凶器。试想一下如果布局复杂，那用代码实现会很恐怖。看过很多blog后，我有新的理解。那就是对布局模块化，简单化。尽量使用 IB 进行布局，对复杂的布局可以尝试 Container View 进行分割。SnapKit 则是用来微调和解决大视图模块之间无法用 IB 产生约束的情况。</p>

<p>Demo：</p>

<p>import SnapKit</p>

<p>class MyViewController: UIViewController {</p>

<pre><code>lazy var box = UIView()

override func viewDidLoad() {
    super.viewDidLoad()

    self.view.addSubview(box)
    box.snp_makeConstraints { (make) -&gt; Void in
       make.width.height.equalTo(50)
       make.center.equalTo(self.view)
    }
} }
</code></pre>

<p>Kingfisher</p>

<p>github 地址：Kingfisher</p>

<p>介绍：A lightweight and pure Swift implemented library for downloading and caching image from the web. 值得注意的是，他有良好的 Cache management。她是借鉴 SDWebImage 这个由 OC 编写的10000+star 图片加载框架。
推荐理由：比AlamofireImage强大，有更好的 cache management 方案。
Kingfisher 和 AlamofireImag 该如何选择？其实这是一个仁者见仁智者见智的问题。但说到功能强大当然是首选 Kingfisher。如果是简单图片展示不需要对图片进行过多操作 和 cache ， AlamofireImage 也是能解决问题。</p>

<p>以下引用 Kingfisher Doc：</p>

<p>Features</p>

<p>Everything in Kingfisher is asynchronous, not only downloading, but also caching. That means you never need to worry about blocking your UI thread.
Multiple-layer cache. Downloaded images will be cached in both memory and disk. So there is no need to download again, this could boost your app’s perceptual speed dramatically.
Cache management. You can set the max duration or size the cache takes. From this, the cache will be cleaned automatically to prevent taking too many resources.
Modern framework. Kingfisher uses NSURLSession and the latest technology of GCD, which makes it a strong and swift framework. It also provides you easy APIs to use.
Cancelable processing task. You can cancel the downloading process if it is not needed anymore.
Prefetching. You can prefetch and cache the images which might soon appear in the page. It will bring your users great experience.
Independent components. You can use the downloader or caching system separately. Or even create your own cache based on Kingfisher’s code.
Options to decompress the image in background before rendering it, which could improve the UI performance.
Categories over UIImageView, NSImage and UIButton for setting image from an URL directly. Use the same code across all Apple platforms.
Support GIF seamlessly. You could just download and set your GIF images as the same as you do for PNG/JPEG format.
HanekeSwift
github 地址：HanekeSwift
简介：A lightweight generic cache for iOS written in Swift with extra love for images
DEMO:</p>

<p>let cache = Cache<JSON>(name: "github")
let URL = NSURL(string: "https://api.github.com/users/haneke")!</JSON></p>

<p>cache.fetch(URL: URL).onSuccess { JSON in
    print(JSON.dictionary?[“bio”])
}
以下引用 HanekeSwift DOC:</p>

<p>Generic cache with out-of-the-box support for UIImage, NSData, JSON and String
First-level memory cache using NSCache
Second-level LRU disk cache using the file system
Asynchronous fetching of original values from network or disk
All disk access is performed in background
Thread-safe
Automatic cache eviction on memory warnings or disk capacity reached
Comprehensive unit tests
Extensible by defining custom formats, supporting additional types or implementing custom fetchers
Zero-config UIImageView and UIButton extensions to use the cache, optimized for UITableView and UICollectionView cell reuse
Background image resizing and decompression
可能你会问，HanekeSwift 和 Kingfisher 都是简化异步处理网络数据和图片的那该如何选择它们呢？首先从 star 数上看 HanekeSwift 3000+， Kingfisher 4000+ 其实差不多，毕竟到这个数量级看的已经不止是 star 数量，更多的是项目的活跃度。Kingfisher 更专注于 image 的加载和缓存，而 HanekeSwift 对 UIImage、NSData、JSON、String 都提供了很好的支持。所以如果是对多种数据希望通过统一的解决方案进行缓存管理， HanekeSwift 貌似会更合适。相反对 image 有较高的缓存管理要求，Kingfisher 则会更推荐。</p>

<p>TransitionTreasury</p>

<p>github地址：TransitionTreasury</p>

<p>简介：A viewController transition framework in Swift。我是被她绚丽的切换方式和简单的使用方法而迷倒。</p>

<p>使用说明：详细 Wiki
ios ViewController 的切换可以通过代码实现，也可以通过在 IB 中给ViewController 链接 Segue 来实现。两种方式各有优劣，也是根据个人习惯和实际需要来选择。TransitionTreasury 是通过代码来管理 ViewController 的跳转，使用起来比较简单。</p>

<p>作者提供的例子：</p>

<p>/// FirstViewController.swift
class FirstViewController: UIViewController {</p>

<pre><code>func push() {
    let vc = SecondViewController()
    navigationController?.tr_pushViewController(vc, method: TRPushTransitionMethod.Fade, completion: {
            print("Push finish")
        })
} }
</code></pre>

<p>/// SecondViewController.swift
class SecondViewController: UIViewController, NavgationTransitionable {</p>

<pre><code>var tr_pushTransition: TRNavgationTransitionDelegate?

func pop() {
    tr_popViewController()
} } 而对于 IB 中链接 Segue 来控制跳转，被认为是推荐的方式。比较好的库有 IBAnimatable ，该库的作者推崇 IB 的使用，对绘制界面能少用代码尽量不用
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">




2016 年11 月1 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/nodejs/">
		
			NodeJS 7.0</a>
	</h2>
	<div class="entry-content">
		<p><a href="https://github.com/nodejs/node/milestone/15?closed=1">https://github.com/nodejs/node/milestone/15?closed=1</a></p>

<blockquote>
  <p>We did change the naming of v6 from Stable to Current as well, so I am assuming that v7 will also be named as “Current” vs “Stable”</p>
</blockquote>

<ul>
  <li>已完成v8 5.4版本集成，也就是说支持async/await</li>
  <li>koa 2.x也将随之发布，妈妈再也不担心我用bable的async/await调试了</li>
  <li>upgrade libuv to 1.10.0</li>
  <li>using openssl 1.1.0</li>
</ul>

<p>异步流程async/await终于落地了</p>


		
		<a href="/blog/nodejs/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年10 月27 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/nodejs/'>nodejs</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/vapor-swift-server/">
		
			Vapor 用swift写服务端</a>
	</h2>
	<div class="entry-content">
		<p><img src="https://cloud.githubusercontent.com/assets/1342803/15592871/46decfda-2375-11e6-9494-a9bf4e6aaebf.png" alt="vapor" /></p>

<p>自从苹果官方发布了一个 Swift 的 Linux 开源版本之后，服务端 Swift 终于迎来了一个令人激动的前景。我的好奇心终于无法克制，是时候尝试一下服务端 Swift 了！</p>

<p><a href="http://vapor.codes/">http://vapor.codes/</a></p>


		
		<a href="/blog/vapor-swift-server/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年10 月9 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/jspatch/">
		
			JSPatch 介绍</a>
	</h2>
	<div class="entry-content">
		<h3 id="jspatch">什么是 JSPatch？</h3>

<p>JSPatch 是一个开源项目(<a href="https://github.com/bang590/JSPatch">Github链接</a>)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。</p>


		
		<a href="/blog/jspatch/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年6 月12 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/swiftkai-fa-ku/">
		
			Swift开发库</a>
	</h2>
	<div class="entry-content">
		<ol>
  <li>CryptoSwift</li>
</ol>

<p>swift加密库, 支持md5,sha1,sha224,sha256…</p>

<p>github地址: <a href="https://github.com/krzyzanowskim/CryptoSwift">https://github.com/krzyzanowskim/CryptoSwift</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085348448948.jpg" alt="jpg" /></p>


		
		<a href="/blog/swiftkai-fa-ku/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年6 月5 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/android-frame/">
		
			Android Frame</a>
	</h2>
	<div class="entry-content">
		<p><img src="http://img.blog.csdn.net/20160524172058595" alt="img" /></p>


		
		<a href="/blog/android-frame/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年5 月26 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/android/'>android</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/facebook-redex/">
		
			Facebook Redex</a>
	</h2>
	<div class="entry-content">
		<p><img src="http://img.blog.csdn.net/20160414083628369" alt="redex" /></p>

<p>去年，Facebook使用叫ReDex的字节码优化工具优化了他们的安卓应用的性能.</p>

<p>现在，ReDex已经开源了。安卓开发者可以免费地使用这个工具优化自己的应用。也可以将它用作其它安卓字节码优化工具的基础。</p>


		
		<a href="/blog/facebook-redex/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年4 月15 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/android/'>android</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/promisekit/">
		
			PromiseKit: 同时支持Objective-C和Swift的Promise类库</a>
	</h2>
	<div class="entry-content">
		<p>现代开发需要高度异步，开发工具所提供的异步编程功能是否强大、方便而又令人愉悦？PromiseKit是一款贴心的iOS异步开发类库，更同时支持Objective-C和Swift的promises完整实现。</p>

<p><img src="http://img.blog.csdn.net/20160308094646006" alt="PromiseKit" /></p>


		
		<a href="/blog/promisekit/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年3 月7 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/emmelearn/">
		
			Emmet 学习</a>
	</h2>
	<div class="entry-content">
		<h4 id="section">介绍</h4>

<p>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具:</p>

<p><img src="http://cdn.w3cplus.com/cdn/farfuture/jXcuIfm_Jn4-aJO7c59GOzDUd1163lwYGIWK3PIX2oE/mtime:1421034939/sites/default/files/styles/print_image/public/baiyaimages/emmet-p1.jpg" alt="icon" /></p>

<p>基本上，大多数的文本编辑器都会允许你存储和重用一些代码块，我们称之为“片段”。虽然片段能很好地推动你得生产力，但大多数的实现都有这样一个缺点：你必须先定义你得代码片段，并且不能再运行时进行拓展。</p>

<p>Emmet把片段这个概念提高到了一个新的层次：你可以设置CSS形式的能够动态被解析的表达式，然后根据你所输入的缩写来得到相应的内容。Emmet是很成熟的并且非常适用于编写HTML/XML 和 CSS 代码的前端开发人员，但也可以用于编程语言。</p>

<h4 id="section-1">使用示例：</h4>

<p>在编辑器中输入缩写代码：ul&gt;li*5 ，然后按下拓展键（默认为tab），即可得到代码片段：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;ul&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">    &lt;li&gt;&lt;/li&gt;
</span><span class="line">&lt;/ul&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>


		
		<a href="/blog/emmelearn/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年1 月20 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/other/'>other</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/wax-profile/">
		
			Wax 简介</a>
	</h2>
	<div class="entry-content">
		<blockquote>
  <p>开源Wax，Alibaba技术团队接力支持
还在为iOS发版受伤吗，无需发布Ａｐｐ新版本，动态修复线上问题的解决方案来了！</p>
</blockquote>

<h3 id="section">发版的痛</h3>

<p>去年无线Allin时每次手淘发版都需要经过个多月的煎熬，哪怕一个很小的需求改动也需要等待整个发版节奏。发版周期长、发版需求多、发版难是手淘这种超级app的特点，而审核时间长、升级速度慢、升级率低是App Store的通病，线上bug更是每个app都避免不了痛，而对于手淘亿级的UV来说，哪怕一个小小的bug都会影响成千上万的用户。对于这些困扰了多年的问题，急需一种无需发版即可动态修复线上问题的解决方案！</p>

<p><img src="http://img3.tbcdn.cn/L1/461/1/02ca09b2d15db2db0de408395e0dba1788b969f2?spm=5176.blog1480.yqblogcon1.5.aDhNu5" alt="img" /></p>

<p>Wax是什么？</p>

<p><img src="http://img4.tbcdn.cn/L1/461/1/aae0800e99288ec9f9516877fe69af2ce665c215?spm=5176.blog1480.yqblogcon1.6.aDhNu5" alt="img" /></p>

<p>还记得当年火爆无比的游戏《愤怒的小鸟》吗，它就是基于Wax框架编写的。Wax把Lua脚本语言与原生Objective-C底层runtime结合起来，使得你可以在Lua里面使用任何Objective-C类及框架。</p>

<h3 id="wax">为什么选择Wax？</h3>
<p><img src="http://img3.tbcdn.cn/L1/461/1/f1cbbd6b9c23b38ccd7783a9cf281d36033843a8?spm=5176.blog1480.yqblogcon1.7.aDhNu5" alt="logo" /></p>

<p>Lua是一个简洁、轻量、可扩展的脚本语言，它的体积小、速度快，在大量的游戏中使用，以实现游戏的可配置和可更新。我们可以把这个思路借鉴到app的开发中，由于Lua需要预先绑定很多C函数才可在脚本中使用，所以单独使用Lua无法做到高复用性。而Wax连接了Lua与Objective-C runtime，使得我们可以在Lua里调用和替换任意类的方法，甚至新增类、方法。这样一来就能在app不发布新版的情况下，通过远程下载脚本的方式修复线上app里的bug、甚至新增一些功能。</p>


		
		<a href="/blog/wax-profile/" class="more-link">阅读全文</a>
	</div>


<div class="meta">
	<div class="date">




2016 年1 月6 日</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">下一页</a>
    
    <div class="center"><a href="/blog/archives">文章列表</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2018

    BryanFu


<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256015915'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256015915%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script></footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->




	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-66019285-2']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>