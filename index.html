
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>BryanFu Blog</title>
	<meta name="author" content="BryanFu">

	
	<meta name="description" content="在这篇文章中，我将为你整理一下 iOS 开发中几种多线程方案，以及其使用方法和注意事项。当然也会给出几种多线程的案例，在实际使用中感受它们的区别。还有一点需要说明的是，这篇文章将会使用 Swift 和 Objective-c 两种语言讲解，双语幼儿园。OK，let&rsquo;t begin! &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="BryanFu Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript">

function addBlankTargetForLinks () {

  $('a[href^="http"]').each(function(){

      $(this).attr('target', '_blank');

  });

}

$(document).bind('DOMNodeInserted', function(event) {

  addBlankTargetForLinks();

});

</script>
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">BryanFu Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:helloyokoy.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/helloyokoy" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:helloyokoy.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/08/iosduo-xian-cheng/">
		
			IOS多线程</a>
	</h2>
	<div class="entry-content">
		<blockquote><p>在这篇文章中，我将为你整理一下 iOS 开发中几种多线程方案，以及其使用方法和注意事项。当然也会给出几种多线程的案例，在实际使用中感受它们的区别。还有一点需要说明的是，这篇文章将会使用 Swift 和 Objective-c 两种语言讲解，双语幼儿园。OK，let&rsquo;t begin!</p></blockquote>

<h2>概述</h2>

<hr />

<p>这篇文章中，我不会说多线程是什么、线程和进程的区别、多线程有什么用，当然我也不会说什么是串行、什么是并行等问题，这些我们应该都知道的。</p>

<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>

<pre><code>Pthreads
NSThread
GCD
NSOperation &amp; NSOperationQueue
</code></pre>

<p>所以接下来，我会一一讲解这些方案的使用方法和一些案例。在将这些内容的时候，我也会顺带说一些多线程周边产品。比如： 线程同步、 延时执行、 单例模式 等等。</p>

<h3>Pthreads</h3>

<p>其实这个方案不用说的，只是拿来充个数，为了让大家了解一下就好了。百度百科里是这么说的：</p>

<p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。</p>

<p>简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于 c语言 的框架，使用起来这酸爽！感受一下：</p>

<p>OBJECTIVE-C</p>

<p>当然第一步要包含头文件</p>

<pre><code>#import
</code></pre>

<p>然后创建线程，并执行任务</p>

<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
pthread_t thread;
//创建一个线程并自动执行
pthread_create(&amp;thread, NULL, start, NULL);
}
void *start(void *data) {
NSLog(@"%@", [NSThread currentThread]);
return NULL;
}
</code></pre>

<p>打印输出：</p>

<pre><code>2015-07-27 23:57:21.689 testThread[10616:2644653] {number = 2, name = (null)}
</code></pre>

<p>看代码就会发现他需要 c语言函数，这是比较蛋疼的，更蛋疼的是你需要手动处理线程的各个状态的转换即管理生命周期，比如，这段代码虽然创建了一个线程，但并没有销毁。</p>

<p>SWIFT</p>

<p>很遗憾，在我目前的 swift1.2 中无法执行这套方法，原因是这个函数需要传入一个函数指针 CFunctionPointer类型，但是目前 swift 无法将方法转换成此类型。听说 swift 2.0 引入一个新特性 @convention&copy;, 可以完成 Swift 方法转换成 c 语言指针的。在这里可以看到</p>

<p>那么，Pthreads 方案的多线程我就介绍这么多，毕竟做 iOS 开发几乎不可能用到。但是如果你感兴趣的话，或者说想要自己实现一套多线程方案，从底层开始定制，那么可以去搜一下相关资料。</p>

<h3>NSThread</h3>

<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法。</p>

<h5>创建并启动</h5>

<p>先创建线程类，再启动
OBJECTIVE-C</p>

<pre><code>// 创建
NSThread *thread = [[NSThread alloc] initWithTarget:self    selector:@selector(run:) object:nil];
// 启动
[thread start];
</code></pre>

<p>SWIFT</p>

<pre><code>//创建
let thread = NSThread(target: self, selector: "run:", object: nil)
//启动
thread.start()
</code></pre>

<h5>创建并自动启动</h5>

<p>OBJECTIVE-C</p>

<pre><code>[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];
</code></pre>

<p>SWIFT</p>

<pre><code>NSThread.detachNewThreadSelector("run:", toTarget: self, withObject: nil)
</code></pre>

<p>使用 NSObject 的方法创建并自动启动</p>

<p>OBJECTIVE-C</p>

<pre><code>[self performSelectorInBackground:@selector(run:) withObject:nil];
</code></pre>

<p>SWIFT</p>

<p>很遗憾 too! 苹果认为 performSelector: 不安全，所以在 Swift 去掉了这个方法。</p>

<pre><code>Note: The performSelector: method and related selector-invoking methods are not imported in Swift because they are inherently unsafe.
</code></pre>

<h5>其他方法</h5>

<p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法大家可以去类的定义里去看。</p>

<p>OBJECTIVE-C</p>

<pre><code>//取消线程
- (void)cancel;
//启动线程
- (void)start;
//判断某个线程的状态的属性
@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isCancelled) BOOL cancelled;
//设置和获取线程名字
-(void)setName:(NSString *)n;
-(NSString *)name;
//获取当前线程信息
+ (NSThread *)currentThread;
//获取主线程信息
+ (NSThread *)mainThread;
//使当前线程暂停一段时间，或者暂停到某个时刻
+ (void)sleepForTimeInterval:(NSTimeInterval)time;
+ (void)sleepUntilDate:(NSDate *)date;
</code></pre>

<p>SWIFT</p>

<p>Swift的方法名字和OC的方法名都一样，我就不浪费空间列举出来了。</p>

<p>其实，NSThread 用起来也挺简单的，因为它就那几种方法。同时，我们也只有在一些非常简单的场景才会用 NSThread, 毕竟它还不够智能，不能优雅地处理多线程中的其他高级概念。所以接下来要说的内容才是重点。</p>

<h3>GCD</h3>

<p>Grand Central Dispatch，听名字就霸气。它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案，老少咸宜，实在是居家旅行、杀人灭口，必备良药。不好意思，有点中二，咱们继续。</p>

<h5>任务和队列</h5>

<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。</p>

<p>任务：即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： 同步执行 和 异步执行，他们之间的区别是 是否会创建新的线程。
同步执行：只要是同步执行的任务，都会在当前线程执行，不会另开线程。</p>

<p>异步执行：只要是异步执行的任务，都会另开线程，在别的线程执行。</p>

<p>更新：</p>

<p>这里说的并不准确，同步（sync） 和 异步（async） 的主要区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕！</p>

<p>如果是 同步（sync） 操作，它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行。</p>

<p>如果是 异步（async）操作，当前线程会直接往下执行，它不会阻塞当前线程。</p>

<p>队列：用于存放任务。一共有两种队列， 串行队列 和 并行队列。
串行队列 中的任务会根据队列的定义 FIFO 的执行，一个接一个的先进先出的进行执行。</p>

<p>更新：放到串行队列的任务，GCD 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。</p>

<p>并行队列 中的任务根据同步或异步有不同的执行方式。虽然很绕，但请看下表：</p>

<p>更新：放到串行队列的任务，GCD 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，GCD 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。</p>

<h5>创建队列</h5>

<p>主队列：这是一个特殊的 串行队列。什么是主队列，大家都知道吧，它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。</p>

<p>  //OBJECTIVE-C
  dispatch_queue_t queue = ispatch_get_main_queue();
  //SWIFT
  let queue = ispatch_get_main_queue()
自己创建的队列：凡是自己创建的队列都是 串行队列。其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空。大家可以看xcode的文档查看参数意义。
更新：自己可以创建 串行队列, 也可以创建 并行队列。看下面的代码（代码已更新），它有两个参数，第一个上面已经说了，第二个才是最重要的。
第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>

<pre><code>//OBJECTIVE-C
dispatch_queue_t queue = dispatch_queue_create("tk.bourne.testQueue", NULL);
//SWIFT
let queue = dispatch_queue_create("tk.bourne.testQueue", nil);
</code></pre>

<p>全局并行队列：这应该是唯一一个并行队列，只要是并行任务一般都加入到这个队列。</p>

<pre><code>//OBJECTIVE-C
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//SWIFT
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
</code></pre>

<h5>创建任务</h5>

<p>同步任务：不会另开线程 (SYNC)</p>

<p>OBJECTIVE-C</p>

<pre><code>dispatch_sync(, ^{
  //code here
  NSLog(@"%@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>dispatch_sync(, { () -&gt; Void in
  //code here
  println(NSThread.currentThread())
})
</code></pre>

<p>异步任务：会另开线程 (ASYNC)</p>

<p>OBJECTIVE-C</p>

<pre><code>dispatch_async(, ^{
  //code here
  NSLog(@"%@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>dispatch_async(, { () -&gt; Void in
  //code here
  println(NSThread.currentThread())
})
</code></pre>

<p>更新：</p>

<p>为了更好的理解同步和异步，和各种队列的使用，下面看两个示例：</p>

<p>示例一：</p>

<p>以下代码在主线程调用，结果是什么？</p>

<pre><code>NSLog("之前 - %@", NSThread.currentThread())
dispatch_sync(dispatch_get_main_queue(), { () -&gt; Void in 
    NSLog("sync - %@", NSThread.currentThread())
})
NSLog("之后 - %@", NSThread.currentThread())
</code></pre>

<p>答案：</p>

<p>只会打印第一句：之前 - {number = 1, name = main} ，然后主线程就卡死了，你可以在界面上放一个按钮，你就会发现点不了了。</p>

<p>解释：</p>

<p>同步任务会阻塞当前线程，然后把 Block 中的任务放到指定的队列中执行，只有等到 Block 中的任务完成后才会让当前线程继续往下运行。</p>

<p>那么这里的步骤就是：打印完第一句后，dispatch_sync 立即阻塞当前的主线程，然后把 Block 中的任务放到 main_queue 中，可以 main_queue 中的任务会被取出来放到主线程中执行，但主线程这个时候已经被阻塞了，所以 Block 中的任务就不能完成，它不完成，dispatch_sync 就会一直阻塞主线程，这就是死锁现象。导致主线程一直卡死。</p>

<p>示例二：</p>

<p>以下代码会产生什么结果？</p>

<pre><code>let queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL)
    NSLog("之前 - %@", NSThread.currentThread())
    dispatch_async(queue, { () -&gt; Void in
    NSLog("sync之前 - %@", NSThread.currentThread())
    dispatch_sync(queue, { () -&gt; Void in
         NSLog("sync - %@", NSThread.currentThread())
    })
    NSLog("sync之后 - %@", NSThread.currentThread())
    })
NSLog("之后 - %@", NSThread.currentThread())
</code></pre>

<p>答案：</p>

<pre><code>2015-07-30 02:06:51.058 test[33329:8793087] 之前 - {number = 1, name = main}

2015-07-30 02:06:51.059 test[33329:8793356] sync之前 - {number = 2, name = (null)}

2015-07-30 02:06:51.059 test[33329:8793087] 之后 - {number = 1, name = main}
</code></pre>

<p>很明显 sync - %@ 和 sync之后 - %@ 没有被打印出来！这是为什么呢？我们再来分析一下：</p>

<p>分析：</p>

<p>我们按执行顺序一步步来哦：</p>

<p>使用 DISPATCH_QUEUE_SERIAL 这个参数，创建了一个 串行队列。
打印出 之前 - %@ 这句。
dispatch_async 异步执行，所以当前线程不会被阻塞，于是有了两条线程，一条当前线程继续往下打印出 之后 - %@这句, 另一台执行 Block 中的内容打印 sync之前 - %@ 这句。因为这两条是并行的，所以打印的先后顺序无所谓。</p>

<p>注意，高潮来了。现在的情况和上一个例子一样了。dispatch_sync同步执行，于是它所在的线程会被阻塞，一直等到 sync 里的任务执行完才会继续往下。于是 sync 就高兴的把自己 Block 中的任务放到 queue 中，可谁想 queue 是一个串行队列，一次执行一个任务，所以 sync 的 Block 必须等到前一个任务执行完毕，可万万没想到的是 queue 正在执行的任务就是被 sync 阻塞了的那个。于是又发生了死锁。所以 sync 所在的线程被卡死了。剩下的两句代码自然不会打印。
队列组</p>

<p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。下面是使用方法，这是一个很实用的功能。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建队列组
dispatch_group_t group = dispatch_group_create();
//2.创建队列
dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue, ^{
for (NSInteger i = 0; i &lt; 3; i++) {
    NSLog(@"group-01 - %@", [NSThread currentThread]);
}
});
//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue(), ^{
for (NSInteger i = 0; i &lt; 8; i++) {
    NSLog(@"group-02 - %@", [NSThread currentThread]);
}
});
//3.3.执行5次循环
dispatch_group_async(group, queue, ^{
for (NSInteger i = 0; i &lt; 5; i++) {
    NSLog(@"group-03 - %@", [NSThread currentThread]);
}
});
//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
NSLog(@"完成 - %@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建队列组
let group = dispatch_group_create()
//2.创建队列
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue) { () -&gt; Void in
for _ in 0.. Void in
for _ in 0.. Void in
for _ in 0.. Void in
NSLog("完成 - %@", NSThread.currentThread())
}
</code></pre>

<p>打印结果</p>

<pre><code>2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] 完成 - {number = 1, name = main}
</code></pre>

<p>这些就是 GCD 的基本功能，但是它的能力远不止这些，等讲完 NSOperation 后，我们再来看看它的一些其他方面用途。而且，只要你想象力够丰富，你可以组合出更好的用法。</p>

<p>更新：关于GCD，还有两个需要说的：</p>

<pre><code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法重点是你传入的 queue，当你传入的 queue 是通过 DISPATCH_QUEUE_CONCURRENT 参数自己创建的 queue 时，这个方法会阻塞这个 queue（注意是阻塞 queue ，而不是阻塞当前线程），一直等到这个 queue 中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue 中排在它后面的任务继续执行。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_async 一样了。</p>

<pre><code>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法的使用和上一个一样，传入 自定义的并发队列（DISPATCH_QUEUE_CONCURRENT），它和上一个方法一样的阻塞 queue，不同的是 这个方法还会 阻塞当前线程。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_sync 一样了。</p>

<h3>NSOperation和NSOperationQueue</h3>

<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>

<p>将要执行的任务封装到一个 NSOperation 对象中。
将此任务添加到一个 NSOperationQueue 对象中。
然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>

<h5>添加任务</h5>

<p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>

<p>NSInvocationOperation : 需要传入一个方法名。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建NSInvocationOperation对象
NSInvocationOperation *operation = [[NSInvocationOperation alloc]   initWithTarget:self selector:@selector(run) object:nil];
</code></pre>

<p>  //2.开始执行
  [operation start];
SWIFT</p>

<p>在 Swift 构建的和谐社会里，是容不下 NSInvocationOperation 这种不是类型安全的败类的。苹果如是说。这里有相关解释</p>

<p>NSBlockOperation
OBJECTIVE-C</p>

<pre><code>//1.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
  NSLog(@"%@", [NSThread currentThread]);
}];
//2.开始任务
[operation start];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建NSBlockOperation对象
let operation = NSBlockOperation { () -&gt; Void in
  println(NSThread.currentThread())
}
//2.开始任务
operation.start()
</code></pre>

<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程 执行这些任务，注意下面的打印结果：</p>

<p>OBJECTIVE-C</p>

<pre><code>  //1.创建NSBlockOperation对象
  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@"%@", [NSThread currentThread]);
  }];
  //添加多个Block
  for (NSInteger i = 0; i &lt; 5; i++) {
      [operation addExecutionBlock:^{
          NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
      }];
  }
  //2.开始任务
  [operation start];
</code></pre>

<p>SWIFT</p>

<pre><code>    //1.创建NSBlockOperation对象
    let operation = NSBlockOperation { () -&gt; Void in
        NSLog("%@", NSThread.currentThread())
    }
    //2.添加多个Block
    for i in 0.. Void in
            NSLog("第%ld次 - %@", i, NSThread.currentThread())
        }
    }
    //2.开始任务
    operation.start()
</code></pre>

<p>打印输出</p>

<pre><code>2015-07-28 17:50:16.585 test[17527:4095467] 第2次 -{number = 1, name = main}
2015-07-28 17:50:16.585 test[17527:4095666] 第1次 -{number = 4, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095665]{number = 3, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095662] 第0次 -{number = 2, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095666] 第3次 -{number = 4, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095467] 第4次 -{number = 1, name = main}
</code></pre>

<p>NOTE：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>

<pre><code>‘*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added after the operation has started executing or finished'
</code></pre>

<p>NOTE：大家可能发现了一个问题，为什么我在 Swift 里打印输出使用 NSLog() 而不是 println() 呢？原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。它会把需要输出的每个字符一个一个的输出到控制台。普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 println() 同时打印，就会导致控制台上的字符混乱的堆在一起，而NSLog() 就没有这个问题。到底是什么样子的呢？你可以把上面 NSLog() 改为 println() ，然后一试便知。</p>

<h5>自定义Operation</h5>

<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。所以这个功能提供给高级玩家，我在这里就不说了，等我需要用到时在研究它，到时候可能会再做更新。</p>

<h5>创建队列</h5>

<p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 同步执行 的。就算是 addExecutionBlock 方法，也会在 当前线程和其他线程 中执行，也就是说还是会占用当前线程。这是就要用到队列 NSOperationQueue 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 start() 方法</p>

<p>主队列</p>

<p>细心的同学就会发现，每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>

<pre><code>//OBJECTIVE-C
NSOperationQueue *queue = [NSOperationQueue mainQueue];
//SWIFT
let queue = NSOperationQueue.mainQueue()
</code></pre>

<p>其他队列
因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>

<p>注意：其他队列的任务会在其他线程并行执行。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建一个其他队列    
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
//2.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"%@", [NSThread currentThread]);
}];
//3.添加多个Block
for (NSInteger i = 0; i &lt; 5; i++) {
[operation addExecutionBlock:^{
    NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
}];
}
//4.队列添加任务
[queue addOperation:operation];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建其他队列
let queue = NSOperationQueue()
//2.创建NSBlockOperation对象
let operation = NSBlockOperation { () -&gt; Void in
NSLog("%@", NSThread.currentThread())
}
//3.添加多个Block
for i in 0.. Void in
    NSLog("第%ld次 - %@", i, NSThread.currentThread())
}
}
//4.队列添加任务
queue.addOperation(operation)
</code></pre>

<p>打印输出</p>

<pre><code>2015-07-28 20:26:28.463 test[18622:4443534]{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第2次 -{number = 2, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443535] 第0次 -{number = 4, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443533] 第1次 -{number = 3, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443534] 第3次 -{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第4次 -{number = 2, name = (null)}
</code></pre>

<p>OK, 这时应该发问了，大家将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有并行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>

<p>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛！</p>

<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>

<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.任务一：下载图片
NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"下载图片 - %@", [NSThread currentThread]);
[NSThread sleepForTimeInterval:1.0];
}];
//2.任务二：打水印
NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"打水印   - %@", [NSThread currentThread]);
[NSThread sleepForTimeInterval:1.0];
}];
//3.任务三：上传图片
NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"上传图片 - %@", [NSThread currentThread]);
[NSThread sleepForTimeInterval:1.0];
}];
//4.设置依赖
[operation2 addDependency:operation1];      //任务二依赖任务一
[operation3 addDependency:operation2];      //任务三依赖任务二
//5.创建队列并加入任务
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperations:@[operation3, operation2, operation1]  waitUntilFinished:NO];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.任务一：下载图片
let operation1 = NSBlockOperation { () -&gt; Void in
NSLog("下载图片 - %@", NSThread.currentThread())
NSThread.sleepForTimeInterval(1.0)
}
//2.任务二：打水印
let operation2 = NSBlockOperation { () -&gt; Void in
NSLog("打水印   - %@", NSThread.currentThread())
NSThread.sleepForTimeInterval(1.0)
}
//3.任务三：上传图片
let operation3 = NSBlockOperation { () -&gt; Void in
NSLog("上传图片 - %@", NSThread.currentThread())
NSThread.sleepForTimeInterval(1.0)
}
//4.设置依赖
operation2.addDependency(operation1)    //任务二依赖任务一
operation3.addDependency(operation2)    //任务三依赖任务二
//5.创建队列并加入任务
let queue = NSOperationQueue()
queue.addOperations([operation3, operation2, operation1],   waitUntilFinished: false)
</code></pre>

<p>打印结果</p>

<pre><code>2015-07-28 21:24:28.622 test[19392:4637517] 下载图片 -{number = 2, name = (null)}
2015-07-28 21:24:29.622 test[19392:4637515] 打水印 -{number = 3, name = (null)}
2015-07-28 21:24:30.627 test[19392:4637515] 上传图片 -{number = 3, name = (null)}
</code></pre>

<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。
可以使用 removeDependency 来解除依赖关系。
可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。
其他方法</p>

<p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>

<pre><code>NSOperation

BOOL executing; //判断任务是否正在执行
BOOL finished; //判断任务是否完成
void (^completionBlock)(void); //用来设置完成后需要执行的操作
- (void)cancel; //取消任务
- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕
NSOperationQueue

NSUInteger operationCount; //获取队列的任务数
- (void)cancelAllOperations; //取消队列中所有的任务
- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕
[queue setSuspended:YES]; // 暂停queue
[queue setSuspended:NO]; // 继续queue
</code></pre>

<p>好啦，到这里差不多就讲完了。当然，我讲的并不完整，可能有一些知识我并没有讲到，但作为常用方法，这些已经足够了。不过我在这里只是告诉你了一些方法的功能，只是怎么把他们用到合适的地方，就需要多多实践了。下面我会说一些关于多线程的案例，是大家更加什么地了解。</p>

<h3>其他用法</h3>

<p>在这部分，我会说一些和多线程知识相关的案例，可能有些很简单，大家早都知道的，不过因为这篇文章讲的是多线程嘛，所以应该尽可能的全面嘛。还有就是，我会尽可能的使用多种方法实现，让大家看看其中的区别。</p>

<h5>线程同步</h5>

<p>所谓线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>

<p>互斥锁 ：给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。
OBJECTIVE-C</p>

<pre><code>@synchronized(self) {
//需要执行的代码块
}
SWIFT


objc_sync_enter(self)
//需要执行的代码块
objc_sync_exit(self)
</code></pre>

<p>同步执行 ：我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 GCD 和 NSOperation 两种方案，我都写出来。
OBJECTIVE-C</p>

<pre><code>//GCD
//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中
dispatch_sync(queue, ^{
  NSInteger ticket = lastTicket;
  [NSThread sleepForTimeInterval:0.1];
  NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
  ticket -= 1;
  lastTicket = ticket;
});
//NSOperation &amp; NSOperationQueue
//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中
//       2. 设置 queue 的 maxConcurrentOperationCount 为 1
//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的  waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。   waitUntilFinished 要在添加到队列之后！
 NSBlockOperation *operation = [NSBlockOperation    blockOperationWithBlock:^{
  NSInteger ticket = lastTicket;
  [NSThread sleepForTimeInterval:1];
  NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
  ticket -= 1;
  lastTicket = ticket;
}];
[queue addOperation:operation];
[operation waitUntilFinished];
//后续要做的事
</code></pre>

<p>SWIFT</p>

<p>这里的 swift 代码，我就不写了，因为每句都一样，只是语法不同而已，照着 OC 的代码就能写出 Swift 的。这篇文章已经老长老长了，我就不浪费篇幅了，又不是高中写作文。</p>

<h5>延迟执行</h5>

<p>所谓延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>

<h6>perform</h6>

<p>OBJECTIVE-C</p>

<pre><code> // 3秒后自动调用self的run:方法，并且传递参数：@"abc"
[self performSelector:@selector(run:) withObject:@"abc" afterDelay:3];
</code></pre>

<p>SWIFT</p>

<p>之前就已经说过，Swift 里去掉了这个方法。</p>

<h6>GCD</h6>

<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用，这里只写 OC 的，Swift 的是一样的。</p>

<p>OBJECTIVE-C</p>

<pre><code>// 创建队列
dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
// 设置延时，单位秒
double delay = 3; 
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
// 3秒后需要执行的任务
});
</code></pre>

<h6>NSTimer</h6>

<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法，不过这里直说延迟执行的用法。同样只写 OC 版的，Swift 也是相同的。</p>

<p>OBJECTIVE-C</p>

<pre><code>[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@"abc" repeats:NO];
</code></pre>

<h5>单例模式</h5>

<p>至于什么是单例模式，我也不多说，我只说说一般怎么实现。在 Objective-C 中，实现单例的方法已经很具体了，虽然有别的方法，但是一般都是用一个标准的方法了，下面来看看。</p>

<p>OBJECTIVE-C</p>

<pre><code>@interface Tool : NSObject
+ (instancetype)sharedTool;
@end
@implementation Tool
static id _instance;
+ (instancetype)sharedTool {
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    _instance = [[Tool alloc] init];
});
return _instance;
}
@end
</code></pre>

<p>这里之所以将单例模式，是因为其中用到了 GCD 的 dispatch_once 方法。下面看 Swift 中的单例模式，在Swift中单例模式非常简单！想知道怎么从 OC 那么复杂的方法变成下面的写法的，请看这里</p>

<p>SWIFT</p>

<pre><code>class Tool: NSObject {
static let sharedTool = Tool()
// 私有化构造方法，阻止其他对象使用这个类的默认的'()'构造方法
private override init() {}
}
</code></pre>

<h5>从其他线程回到主线程的方法</h5>

<p>我们都知道在其他线程操作完成后必须到主线程更新UI。所以，介绍完所有的多线程方案后，我们来看看有哪些方法可以回到主线程。</p>

<p>NSThread</p>

<pre><code>//Objective-C
[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
//Swift
//swift 取消了 performSelector 方法。
</code></pre>

<p>GCD</p>

<pre><code>//Objective-C
dispatch_async(dispatch_get_main_queue(), ^{
});
//Swift
dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
})
</code></pre>

<p>NSOperationQueue</p>

<pre><code>//Objective-C
[[NSOperationQueue mainQueue] addOperationWithBlock:^{
}];
//Swift
NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in
}
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">




Aug 8th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
	<div class="comments"><a href="/blog/2015/08/08/iosduo-xian-cheng/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/08/zhi-ming-iosying-yong-bei-hou-de-di-san-fang-xiang-mu/">
		
			知名ios应用背后的第三方项目</a>
	</h2>
	<div class="entry-content">
		<blockquote><p>知名应用程序的设计和技术一直都是开发者需要学习的，同样这些应用所使用的开源框架也是不可忽视的一部分。此前《iOS第三方开源库的吐槽和备忘》中作者ibireme列举了国内多款知名应用所使用的开源框架，并对其中一些框架进行了分析，同样国外开发者@iOSCowboy也在博客中给我们列出了国外多款知名应用使用的开源框架。另外txx&rsquo;s blog中详细介绍了Facebook Paper使用的第三方库。</p></blockquote>

<h3>Instagram</h3>

<hr />

<p><em>AFNetworking: 适用于iOS和OS X的网络框架。</em></p>

<p>Appirater: 提醒用户打分。</p>

<p>ASIHTTPRequest：简单使用CFNetwork API封装进行HTTP网络请求，用Objective-C编写，可应用在Mac OSX和iOS开发中。</p>

<p>CocoaHTTPServer: 用于Mac OS X和iOS应用程序的轻量级、可嵌入的HTTP服务器框架。</p>

<p><em>Cocoa Lumberjack:适用于Mac和iOS的日志框架，集简单、快速、强大以及灵活于一身。</em></p>

<p><em>MBProgressHUD: 用多种样式展示半透明的HUD，并带有指示器和标签，自定义功能强大。</em></p>

<p>PLCrashReporter (Github mirror): 进程内崩溃报告框架。</p>

<p>QSUtilities: 实用工具、控件以及其他辅助类的集合。</p>

<p>SocketRocket: Objective-C WebSocket客户端库。 <a href="https://github.com/square/SocketRocket">https://github.com/square/SocketRocket</a></p>

<p><em>XBImageFilters:允许实时过滤摄像头拍摄的照片，使用OpenGL ES 2 来快速处理各种图片效果。</em></p>

<h3>Foursquare</h3>

<hr />

<p>Facebook SDK for iOS: 集成Facebook,构建强大的社交app。</p>

<p>FSNetworking: Foursquare iOS网络库。</p>

<p>kingpin: MapKit/MKAnnotation pin 聚合库，主要用来在地图上面添加锚点。</p>

<p><em>AFNetworking:适用于iOS和OS X的网络框架。</em></p>

<p>SKBounceAnimation: CAKeyframeAnimation子类，可快速简单地设置弹动的数量，开始和结束的值，以及创建动画。</p>

<p>DB5: 通过Plist配置文件。</p>

<h3>LinkedIn</h3>

<hr />

<p><em>BlocksKit: blocks工具包。</em></p>

<p><em>SDWebImage: 提供一个UIImageVIew类以支持远程加载网络图片。具有缓存管理、异步图片下载等功能，支持GIF动画，使用GCD和ARC。</em></p>

<p>DTCOreText:文字效果代码类库。在UITextView上实现丰富的文字效果，比如文字大小、颜色、字体、下划线，链接，给文字加上图片、视频，文字任意间距等等。实现类似于CSS网页的文字效果。</p>

<h3>Shazam</h3>

<hr />

<p>AudioStreamer:Mac OS X和iPhone上适用的流媒体音频播放器，可播放来自网络上的音乐。</p>

<p>ColorArt: iTunes 11风格的颜色匹配代码。</p>

<p>objc-geohash: Objective-C GeoHash库，通过经纬度获得哈希表。</p>

<p>FormatterKit: 收集了精心构思的NSFormatter子类。</p>

<p>UIView+Glow: UIView的一个类别，可添加对制作发光视图的支持，以突出屏幕上重要的部分，方便用户与之进行交互。</p>

<p><em>WEbViewJavascriptBridge: 在使用UIWebView时，它优雅地实现了JS与ios 的ObjC 原生代码之间的互调，支持消息发送、接收、消息处理器的注册与调用以及设置消息处理的回调。</em></p>

<h3>Skype</h3>

<hr />

<p><em>AFNetworking: 适用于iOS和OS X的网络框架。</em></p>

<p>Hockey SDK: HockeyApp service官方iOS SDK。</p>

<p>PLCrashReporter (Github mirror): 进程内的崩溃报告框架。</p>

<p><em>TTTAttributedLabel是一个文字视图开源组件，是UILabel的替代元件，可以以简单的方式展现渲染的属性字符串。另外，还支持链接植入，不管是手动还是使用UIDataDetectorTypes自动把电话号码、事件、地址以及其他信息变成链接。</em></p>

<p><em>SDWebImage: 提供一个UIImageVIew类以支持远程加载网络图片。具有缓存管理、异步图片下载等功能，支持GIF动画，使用GCD和ARC。</em></p>

<p><em>Cocoa Lumberjack: 适用于Mac和iOS的日志框架，集简单、快速、强大以及灵活于一身。</em></p>

<p>MWPhotoBrowser: 一个简单的带有栅格视图的iOS照片浏览器，可添加标题和选择多个图片。照片浏览器效果类似iOS原生的照片应用,可显示来自手机的图片或者是网络图片，也可自动从网络下载图片并进行缓存，还可图片进行缩放等。</p>

<p>BlocksKit: Objective-C blocks工具包。</p>

<h3>Spotify</h3>

<hr />

<p><em>FMDB: SQLite API封装库。</em></p>

<p>MAObjCRuntime:将运行时API封装成ObjC。</p>

<p>Nu: 编程语言。</p>

<p>PLCrashReporter (Github mirror):进程内崩溃报告框架。</p>

<p>SBJSON:Objective-C 实现的一个严格的JSON 解析器和生成器。</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Aug 8th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
	<div class="comments"><a href="/blog/2015/08/08/zhi-ming-iosying-yong-bei-hou-de-di-san-fang-xiang-mu/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/08/iosdi-san-fang-ku-he-cha-jian/">
		
			IOS第三方库和插件</a>
	</h2>
	<div class="entry-content">
		<h2>前言</h2>

<hr />

<blockquote><p>第三方库是现在的程序员离不开的东西 不光是APP开发 基本上所有的商业项目 都会或多或少的使用到第三方库</p></blockquote>

<p>Xcode基本是Mac/iOS程序员的必备工具(AppCode我没用过 不知道有多少人用?) 但是能说有多好用..这就仁者见仁了(跟Visual Studio是没得比了) 不过在用了插件以后 倒也能让生产力提升一大截</p>

<p>接下来我会介绍一些我本人常用的第三方库和插件 也许不多 但是一定是久经考验 用了一定不会错</p>

<h2>介绍</h2>

<hr />

<h3>第三方库</h3>

<hr />

<h4>CocoaPod</h4>

<p>CocoaPod并不是iOS上的第三方库 而是大名鼎鼎的第三方库的管理工具</p>

<p>在CocoaPod没有出现之前 第三方库的管理是非常痛苦的 尤其是一些大型的库(比如nimbus) 每次对库进行更新 都可能会非常的痛苦</p>

<p>CocoaPod的出现解决了这些问题 以Framework的方式引入第三方库 极大的节约了集成的时间 而且通吃Objective-C和Swift(Swift上的Cathatage我没有实际用过 但是它的那种集成方式还是比CocoaPod麻烦点)</p>

<h4>iCarousel</h4>

<p>在iOS 4.x的时代(我也是从4.0开始接触iOS开发的) Coverflow的效果可谓是风靡一时 初出茅庐的我当年对如何实现几乎是束手无策(当年所有的电影资讯类的APP 如布丁爱生活等 都需要实现Coverflow选片的效果 碰巧我也要做一个) iCarousel的出现替我解决了一个大的难题</p>

<p>从此iCarousel成为了我每个项目的必备良药(也是我最喜欢的库) 不管是Coverflow还是轮播广告 都能轻描淡写的搞定 其内置的十来种显示类型 基本可以解决90%的UI需求 而其强大的自定义功能 则可以解决剩余的10% :)</p>

<p>不熟悉的朋友可以尝试一下其精美的demo(pod try iCarousel) 所有的功能都在demo中一览无余</p>

<p>作者nicklockwood也是一个高产的大神 同时维护着数量众多且优质的开源库(比如iVersion iRate) 大家不妨去看一看 淘一淘</p>

<h4>AFNetworking/Alamofire</h4>

<p>HTTP框架的龙头老大 当年在与ASIHTTPRequest的竞争中笑到了最后(当然也是因为ASIHTTPRequest的作者不维护了 不过国内很多公司 因为历史原因都在自行维护) 由于及时维护和拥抱语言的新特性 迅速被大家所接受和喜爱</p>

<p>相信每个人都用过 这里就不赘述了</p>

<h4>MKNetworkKit</h4>

<p>如果说AFNetworking是老大 那么MKNetworkKit可以说是小弟了 不过也因为比AFNetworking轻量的原因 也获得了许多开发者的青睐</p>

<p>当年因为ASIHTTPRequest停止维护了 在机缘巧合之下 我在AFNetworking和MKNetworkKit之间选择了后者 并在很多项目中进行了使用</p>

<p>不过也许是因为AFNetworking发展得更快更迅速 而作者本人是单兵作战的原因 作者也基本放弃了更新(版本号在停留在0.8x) 十分可惜</p>

<h4>SDWebImage</h4>

<p>图片异步下载和缓存管理的集大成者 UITableView的黄金搭档 其代码被开发者研究分享过无数次喵大的Kingfisher(可以说是Swift版的SDWebImage)也是深受其影响</p>

<p>异步下载AFNetworking和MKNetworkKit都有实现 数据缓存也有FastImageCache与TMCache等 但是将其融会贯通的 唯有SDWebImage了</p>

<p>除了简单的使用sd_setImageWithURL之外 SDImageCache也是可以独立使用的 功能也相当之强大</p>

<h4>ZXingObjC</h4>

<p>zxing是Google出品的二维码扫描组件 原本是Java编写的 现在也有了各种语言的移植版 而ZXingObjC就是其中之一</p>

<p>zxing支持各种主流的一维码二维码扫描 简单易用 小厂如果要实现二维码扫描这个功能 基本都会选择zxing</p>

<p>不过iOS7已内置了二维码摄像头扫描 而iOS8也已内置了二维码静态图扫描 以后可能再也不需要用到ZXing了 :(</p>

<h4>MBProgressHUD</h4>

<p>简单易用且稳定的HUD组件 半透明黑底白字的风格也经久不衰 loading提示的最佳选择</p>

<p>Masonry/SnapKit</p>

<p>最好用的Autolayout手写库(Cartography也不错啦 但是还是用不惯) 帮助我轻易的跨越了Autolayout这道坎</p>

<p>我也曾多次在文章中提到过关于Masonry的使用方法 如果还没有用过的朋友 不妨看一看</p>

<h4>pop</h4>

<p>Facebook的工程师一直是神一般的存在 对开源社区的贡献也是巨大的 极大的推动了各种变成语言的发展 比如HipHop之于PHP react之于JavaScript pop之于Objective-C等等</p>

<p>不管是HipHop react Facebook的工程师总是抱着颠覆的态度来开源 pop也不例外 这点之前我也简单介绍过 而以pop为基础的paper一发布就震惊整个APP届 在这点上pop也是厥功甚伟</p>

<p>pop对自定义动画也支持得很好 我也以pop的自定义动画为基础写过MMTweanAnimation</p>

<h4>ReactiveCocoa</h4>

<p>说起来惭愧 大名鼎鼎的RAC 我只使用了点皮毛(只拿来做输入验证了)</p>

<p>暂时还没有进行深层次的使用 对RAC的理解也停留在表面阶段 不过这篇文章介绍得非常详细 值得一看</p>

<h4>GPUImage</h4>

<p>如果你要做图像(照片或者视频)的相关处理 或者只是简单的想做个像Camera360一样的拍照滤镜 那么你一定要研究一下GPUImage</p>

<p>如它的名字所述 GPUImage是基于GPU的图像处理框架 我们都知道 GPU是提升性能的关键 这也就是GPUImage如此重要 如此受欢迎的原因</p>

<h4>Lumberjack</h4>

<p>log系统是每个项目都应该有的东西 而Lumberjack是log系统中的翘楚</p>

<p>你可以简单的把它当成NSLog的替代品(简单来说 Lumberjack比NSLog速度更快) 或者根据你的需要来打造一个更强大的日志系统</p>

<h4>NSLogger</h4>

<p>从名字可以看出 NSLogger也是一个log系统 其特点是附带了一个功能强大的Desktop Viewer 可以让你方便的查看APP产生的日志(支持分级筛选等等 甚至可以直接log一张图片)</p>

<h4>AwesomeMenu</h4>

<p>当年横空出世的Path 其优美的设计 精彩的动画 不知让多少人嘴巴都合不拢 而最赞的 就是它的弹出菜单 一时成为了每个APP争相模仿的对象</p>

<p>有了AwesomeMenu 你可以轻易的实现它</p>

<h4>MMDrawerController</h4>

<p>普通的侧滑菜单 用MMDrawerController就搞定了</p>

<h4>realm</h4>

<p>作为数据存储的一等公民 CoreData的地位不言而喻 不过也因为使用起来不够方便 才会出现MagicalRecord这种辅助类 甚至fmdb这种基于纯sqlite的库</p>

<p>而realm以挑战者的身份闪亮登场 不仅读取性能更快(据说数倍于CoraData) 接口简单易用(以对象的形式使用数据 这点和leancloud的思路很相似) 并且还跨平台(iOS/Android均可使用 OC/Swift/Java都支持)</p>

<p>如果你习惯使用Mantle之类的Modal转换的话Realm-JSON肯定能讨你欢心</p>

<p>作为YCombinator的孵化项目 其质量还是能得以保证的 至少我试用下来 确实给我以很大的惊喜 不管是API的设计 还是数据对象的定义 就连数据库的版本升级 都非常的方便)</p>

<h3>Xcode插件</h3>

<hr />

<h4>Alcatraz</h4>

<p>与CocoaPod类似 Alcatraz是Xcode的插件管理器 能够让你方便的管理Xcode的插件(不仅可以管理插件 还可以管理主题等等)</p>

<h4>FuzzyAutocomplete</h4>

<p>如果只让我选一个插件留下 那必须是FuzzyAutocomplete 强大的模糊匹配输入 让你写代码的时候再也不用费脑子去记住名字那么长的对象或者函数名了 好用到让你想哭</p>

<h4>XAlign</h4>

<p>作为有洁癖的码农 看到不对齐的代码一定是不能忍的 XAlign可以轻松解决你的烦恼</p>

<h4>VVDocumenter-Xcode</h4>

<p>喵大的又一力作 能够识别当前函数的参数和返回类型 帮助你快速编写符合规范的注释(目前是以Javadoc为标准)</p>

<h4>deriveddata-exterminator</h4>

<p>如果你老是遇到Xcode抽风 提示你要因为某个原因要删除某个目录下的文件 否则编译不过 那你一定会被这个插件感动 因为说明了遇到这个事的人不只你一个</p>

<h4>Xcode-Quick-Localization</h4>

<p>多语言在iOS开发中一直不是很方便 有了它 你可以省不少事</p>

<h4>Backlight-for-XCode</h4>

<p>就如果Xcode默认的80个字的分页提示一样 高亮当前正在编辑的一行 也是一种友好的提示 喜不喜欢也就因人而异了</p>

<h2>小结</h2>

<hr />

<p>以上的介绍 都是从我自身的使用经验触发的 可能大部分大家都用过了 而我也将会持续的更新这份列表 只要有优秀使用的东东 我都会添加进来</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Aug 8th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
	<div class="comments"><a href="/blog/2015/08/08/iosdi-san-fang-ku-he-cha-jian/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/08/octopressda-jian-jiao-cheng/">
		
			Octopress搭建教程</a>
	</h2>
	<div class="entry-content">
		<h2>1.安装Octopress</h2>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
cd octopress
bundle update    # 安装依赖的组件
rake install     # 安装默认的Octopress主题
</code></pre>

<h2>2.配置Git</h2>

<p>值得注意的是这里git的origin已经存在，并且指向octopress的master分支的，这里为了方便进行了更改：</p>

<pre><code>git remote rm origin
git remote add origin git@github.io:helloyokoy/stormzhang.github.com.git
git remote add octopress git://github.com/imathis/octopress.git  # 为了octopress的升级而添加
</code></pre>

<h2>3.配置github</h2>

<p>在github上创建一个仓库，注意仓库名称要以下这种格式yourname.github.io，这样代码发布后自动这个url就可以访问了（此处一定要注意哦，我刚开始没注意，死活没得到想要的效果）。</p>

<p>例如你的 GitHub 帐号是 jack 就将 Repository 命名为 jack.github.io， 完成后会得到一组 GitHub Pages URL <a href="http://yourname.github.io/">http://yourname.github.io/</a> (注意不能用 https协议，必须用 http协议)。</p>

<p>设定 GitHub Pages</p>

<pre><code>rake setup_github_pages
以上执行后会要求 read/write url for repository ：
</code></pre>

<p>git@github.com:yourname/yourname.github.io.git</p>

<pre><code>rake generate
rake deploy
</code></pre>

<h2>4.将 source 也加入 git</h2>

<pre><code>git add .
git commit -m 'initial source commit'
git push origin source
</code></pre>

<h2>5.更新 Octopress</h2>

<pre><code>git remote add octopress git://github.com/imathis/  octopress.git
git pull octopress master     # Get the latest Octopress
bundle install                # Keep gems updated
rake update_source            # update the template's   source
rake update_style             # update the template's style
</code></pre>

<h2>6.发表新文章</h2>

<pre><code>rake new_post["新文章名称"]
rake preview
用浏览器打开 http://localhost:4000 就可以看到效果了。
</code></pre>

<h2>7.发布</h2>

<pre><code>rake gen_deploy
rake deploy                 #若发布后无效果可试试此命令
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">




Aug 8th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/octopress/'>octopress</a>


</div>
	
	<div class="comments"><a href="/blog/2015/08/08/octopressda-jian-jiao-cheng/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/08/xin-wen-zhang-ming-cheng/">
		
			Markdown简介</a>
	</h2>
	<div class="entry-content">
		<h3>1. 标题设置（让字体变大，和word的标题意思一样）</h3>

<hr />

<p>在Markdown当中设置标题，有两种方式：</p>

<p>第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。</p>

<p>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p>

<h3>2. 块注释（blockquote）</h3>

<hr />

<p>通过在文字开头添加“>”表示块注释。（当>和文字之间添加五个blank时，块注释的文字会有变化。）</p>

<h3>3. 斜体</h3>

<hr />

<p>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p>

<h3>4. 粗体</h3>

<hr />

<p>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p>

<h3>5. 无序列表</h3>

<hr />

<p>在文字开头添加(<em>, +, and -)实现无序列表。但是要注意在(</em>, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）</p>

<h3>6. 有序列表</h3>

<hr />

<p>使用数字后面跟上句号。（还要有空格）</p>

<h3>7. 链接（Links）</h3>

<hr />

<p>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。</p>

<p>内联方式：</p>

<pre><code>This is an [example link](http://example.com/).
</code></pre>

<p>引用方式：</p>

<pre><code>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].  

[1]: http://google.com/        "Google" 
[2]: http://search.yahoo.com/  "Yahoo Search" 
[3]: http://search.msn.com/    "MSN Search"
</code></pre>

<h3>8. 图片（Images）</h3>

<hr />

<p>图片的处理方式和链接的处理方式，非常的类似。</p>

<p>内联方式：</p>

<pre><code>    ![alt text](/path/to/img.jpg "Title")
</code></pre>

<p>引用方式：</p>

<pre><code>    ![alt text][id] 

    [id]: /path/to/img.jpg "Title"
</code></pre>

<h3>9. 代码（HTML中所谓的Code）</h3>

<hr />

<p>实现方式有两种：</p>

<p>第一种：简单文字出现一个代码框。</p>

<pre><code>`&lt;blockquote&gt;`。（`不是单引号而是左上角的ESC下面~中的`）
</code></pre>

<p>第二种：大片文字需要实现代码框。</p>

<pre><code>使用Tab和四个空格。
</code></pre>

<h3>10. 脚注（footnote）</h3>

<hr />

<p>实现方式如下：</p>

<pre><code>hello[^hello]

[^hello]: hi
</code></pre>

<h3>11. 下划线</h3>

<hr />

<p>在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）</p>

		
		
	</div>


<div class="meta">
	<div class="date">




Aug 8th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/markdown/'>markdown</a>


</div>
	
	<div class="comments"><a href="/blog/2015/08/08/xin-wen-zhang-ming-cheng/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    BryanFu

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'helloyokoy';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>