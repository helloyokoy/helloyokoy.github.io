<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：android | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2018-01-22T17:07:24+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Framework]]></title>
    <link href="http://helloyokoy.github.io/blog/android-framework/"/>
    <updated>2016-05-26T14:47:35+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-framework</id>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160524172058595" alt="img" /></p>

<!--more-->

<ul>
  <li>缓存</li>
</ul>

<p>DiskLruCache:	Java实现基于LRU的磁盘缓存</p>

<ul>
  <li>图片加载</li>
</ul>

<p>Android Universal Image Loader:	一个强大的加载，缓存，展示图片的库</p>

<p>Picasso:	一个强大的图片下载与缓存的库</p>

<p>Fresco:	一个用于管理图像和他们使用的内存的库</p>

<p>Glide:	一个图片加载和缓存的库</p>

<ul>
  <li>图片处理</li>
</ul>

<p>Picasso-transformations	: 一个为Picasso提供多种图片变换的库</p>

<p>Glide-transformations:	一个为Glide提供多种图片变换的库</p>

<p>Android-gpuimage: 	基于OpenGL的Android过滤器</p>

<ul>
  <li>网络请求</li>
</ul>

<p>Android Async HTTP:	Android异步HTTP库</p>

<p>AndroidAsync: 	异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。</p>

<p>OkHttp: 	一个Http与Http/2的客户端</p>

<p>Retrofit:	类型安全的Http客户端</p>

<p>Volley: Google推出的Android异步网络请求框架和图片加载框架</p>

<ul>
  <li>网络解析</li>
</ul>

<p>Gson:	一个Java序列化/反序列化库，可以将JSON和java对象互相转换</p>

<p>Jackson:	Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象</p>

<p>Fastjson:	Java上一个快速的JSON解析器/生成器</p>

<p>HtmlPaser: 一种用来解析单个独立html或嵌套html的方式</p>

<p>Jsoup:	一个以最好的DOM，CSS和jQuery解析html的库</p>

<ul>
  <li>数据库</li>
</ul>

<p>OrmLite:	JDBC和Android的轻量级ORM java包</p>

<p>Sugar:	用超级简单的方法处理Android数据库</p>

<p>GreenDAO:	一种轻快地将对象映射到SQLite数据库的ORM解决方案</p>

<p>ActiveAndroid: 以活动记录方式为Android SQLite提供持久化</p>

<p>SQLBrite:	SQLiteOpenHelper 和ContentResolver的轻量级包装</p>

<p>Realm 移动数据库：一个SQLite和ORM的替换品</p>

<ul>
  <li>依赖注入</li>
</ul>

<p>ButterKnife:	将Android视图和回调方法绑定到字段和方法上</p>

<p>Dagger2:	一个Android和java快速依赖注射器。</p>

<p>AndroidAnotations:	快速安卓开发。易于维护</p>

<p>RoboGuice: Android平台的Google Guice</p>

<ul>
  <li>图表</li>
</ul>

<p>WilliamChart:	创建图表的Android库</p>

<p>HelloCharts:	兼容到API8的Android图表库</p>

<p>MPAndroidChart:	一个强大的Android图表视图/图形库</p>

<ul>
  <li>后台处理</li>
</ul>

<p>Tape:	一个轻快的，事务性的，基于文件的FIFO的库</p>

<p>Android Priority Job Queue: 一个专门为Android轻松调度任务的工作队列</p>

<ul>
  <li>事件总线</li>
</ul>

<p>EventBus:	安卓优化的事件总线，简化了活动、片段、线程、服务等的通信</p>

<p>Otto:	一个基于Guava的增强的事件总线</p>

<ul>
  <li>响应式编程</li>
</ul>

<p>RxJava: JVM上的响应式扩展</p>

<p>RxJavaJoins:	为RxJava提供Joins操作</p>

<p>RxAndroid: Android上的响应式扩展，在RxJava基础上添加了Android线程调度</p>

<p>RxBinding: 提供用RxJava绑定Android UI的API</p>

<p>Agera:	Android上的响应式编程</p>

<ul>
  <li>Log框架</li>
</ul>

<p>Logger: 简单，漂亮，强大的Android日志工具
Hugo: 在调试版本上注解的触发方法进行日志记录
Timber: 一个小的，可扩展的日志工具</p>

<ul>
  <li>测试框架</li>
</ul>

<p>Mockito:	Java编写的Mocking单元测试框架</p>

<p>Robotium:	Android UI 测试</p>

<p>Robolectric:	Android单元测试框架</p>

<p>Android自带很多测试工具：JUnit，Monkeyrunner，
UiAutomator，Espresso等</p>

<ul>
  <li>调试框架</li>
</ul>

<p>Stetho: 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试</p>

<ul>
  <li>性能优化</li>
</ul>

<p>LeakCanary:	内存泄漏检测工具</p>

<p>ACRA:	Android应用程序崩溃报告</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebook Redex]]></title>
    <link href="http://helloyokoy.github.io/blog/facebook-redex/"/>
    <updated>2016-04-15T17:08:14+08:00</updated>
    <id>http://helloyokoy.github.io/blog/facebook-redex</id>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160414083628369" alt="redex" /></p>

<p>去年，Facebook使用叫ReDex的字节码优化工具优化了他们的安卓应用的性能.</p>

<p>现在，ReDex已经开源了。安卓开发者可以免费地使用这个工具优化自己的应用。也可以将它用作其它安卓字节码优化工具的基础。</p>

<!--more-->

<p>在Facebook工程博客的一篇文章中指出，.DEX（安卓的可执行文件的形式）文件中的类，并不是按照应用启动时候加载的顺序加载的，而是按照编译工具指定的顺序加载的。</p>

<p>ReDex使用程序运行时产生的运行数据判定哪些类应该在.DEX文件中被优先载入。“想要最小化从内存中读取数据的次数，最好从启动的时候就载入字节码。”Facebook称，他们使用ReDex对应用优化之后，对存储的读取减少了25%，运行速度提高了30%。</p>

<p>关于这个速度，Facebook称，在存储较慢的老旧机器上效果非常明显，但是对于新的收集，性能也有明显的提高。Facebook在一台搭载了安卓4.4的全新的Nexus4上（有35%的安卓设备运行这个版本）测试，启动时间从2秒降至1.6秒。</p>

<p>Runtime分析可以用来删除无关的元数据和接口，但是开发者也可以自定义优化的行为。比如，有些方法即使没有直接被调用，也可以让它们保留下来。</p>

<p>这个优化是在应用编译完成之后进行的。也就是说，理论上你也可以结合其他优化，比如对Java进行虚拟机层的优化和语言的优化，像即将到来的Java 9的语言模块特性等等。</p>

<p>优化Java的字节码文件并不是一种新技术。还有其他的开源项目，例如ProGuard就可以通过删除运行时没有使用的代码进行优化。但是它并不能像ReDex那样按照执行顺序来重新组织类。</p>

<hr />
<p>原文链接：  <a href="http://www.infoworld.com/article/3055222/android/">http://www.infoworld.com/article/3055222/android/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Genymotion模拟器]]></title>
    <link href="http://helloyokoy.github.io/blog/android-genymotion/"/>
    <updated>2015-09-04T19:48:35+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-genymotion</id>
    <content type="html"><![CDATA[<h4 id="genymotion">Genymotion简介</h4>
<p>Genymotion是一套完整的工具，它提供了Android虚拟环境。如果你没有物理机器，又不想忍受官方模拟器的折磨，Genymotion会是你非常不错的选择， 它简直就是开发者、测试人员、推销者甚至是游戏玩家的福音。</p>

<!--more-->

<p><img src="http://owx2ayke3.bkt.clouddn.com/18-1-22/69740245.jpg" alt="icon" /></p>

<p>Genymotion支持Windows、Linux和Mac OS，容易安装和使用，下面就然我们一起来体验神器给我们带来的快感吧。</p>

<h4 id="genymotion-1">Genymotion特性</h4>

<p>最好的Android模拟体验</p>

<ul>
  <li>
    <p>支持OpenGL加速，提供最好的3D性能体验</p>
  </li>
  <li>
    <p>可以从Google Play安装应用</p>
  </li>
  <li>
    <p>支持全屏并改善了使用感受</p>
  </li>
</ul>

<p>全控制</p>

<ul>
  <li>
    <p>可同时启动多个模拟器</p>
  </li>
  <li>
    <p>支持传感器管理，如电池状态、GPS、Accelerator加速器</p>
  </li>
  <li>
    <p>支持Shell控制模拟器</p>
  </li>
</ul>

<p>完全兼容ADB，您可以从主机控制您的模拟器</p>

<p>管理设备</p>

<ul>
  <li>
    <p>易安装</p>
  </li>
  <li>
    <p>兼容Microsoft Windows 32/64 bits, Mac OSX 10.5+ and Linux 32/64 bits</p>
  </li>
  <li>
    <p>可以配置模拟器参数，如屏幕分辨率、内存大小、CPU数量</p>
  </li>
  <li>
    <p>轻松下载、部署最新的Genymotion虚拟设备。</p>
  </li>
</ul>

<p>从Eclipse启动虚拟设备</p>

<ul>
  <li>使用Genymotion测试您的应用</li>
</ul>

<h4 id="section">安装与配置</h4>

<p>安装基本是一路next，虽然Genymotion是免费版的，但是要求注册个账号才可以配置模拟器，配置好启动真是神速啊。</p>

<h4 id="eclipse">Eclipse插件安装</h4>

<p>Genymotion还支持Eclipse IDE，这大大方便了我们使用Genymotion来开发应用。安装方式：</p>

<ul>
  <li>
    <p>启动Eclipse，Help-&gt;Install New Software…-&gt;Add</p>
  </li>
  <li>
    <p>填写一下信息：</p>

    <p>Name: Genymobile</p>

    <p>Location: http://plugins.genymotion.com/eclipse</p>
  </li>
</ul>

<p>接下来跟安装adt的流程一样，指导完成
最后附上官网地址：<a href="http://www.genymotion.com/">http://www.genymotion.com/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Https请求no Peer Certificate解决方案]]></title>
    <link href="http://helloyokoy.github.io/blog/android-httpsqing-qiu-no-peer-certificatejie-jue-fang-an/"/>
    <updated>2015-08-12T16:30:44+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-httpsqing-qiu-no-peer-certificatejie-jue-fang-an</id>
    <content type="html"><![CDATA[<h3 id="section">解决方案一</h3>
<hr />

<p>写了一个自定义类继承SSLSocketFactory：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>import java.io.IOException;
</span><span class='line'>import java.net.Socket;
</span><span class='line'>import java.net.UnknownHostException;
</span><span class='line'>import java.security.KeyManagementException;
</span><span class='line'>import java.security.KeyStore;
</span><span class='line'>import java.security.KeyStoreException;
</span><span class='line'>import java.security.NoSuchAlgorithmException;
</span><span class='line'>import java.security.UnrecoverableKeyException;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>import javax.net.ssl.SSLContext;
</span><span class='line'>import javax.net.ssl.TrustManager;
</span><span class='line'>import javax.net.ssl.X509TrustManager;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>import org.apache.http.conn.ssl.SSLSocketFactory;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public class SSLSocketFactoryEx extends SSLSocketFactory {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>SSLContext sslContext = SSLContext.getInstance(“TLS”);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public SSLSocketFactoryEx(KeyStore truststore) 
</span><span class='line'>                        throws NoSuchAlgorithmException, KeyManagementException,
</span><span class='line'>                        KeyStoreException, UnrecoverableKeyException {
</span><span class='line'>                super(truststore);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>TrustManager tm = new X509TrustManager() {
</span><span class='line'>                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {return null;}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@Override&lt;br />
</span><span class='line'>public void checkClientTrusted(
</span><span class='line'>   java.security.cert.X509Certificate[] chain, String authType)
</span><span class='line'>                                            throws java.security.cert.CertificateException {}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@Override&lt;br />
</span><span class='line'>public void checkServerTrusted(
</span><span class='line'>   java.security.cert.X509Certificate[] chain, String authType)
</span><span class='line'>                                            throws java.security.cert.CertificateException {}
</span><span class='line'>        };&lt;br />
</span><span class='line'>        sslContext.init(null, new TrustManager[] { tm }, null);&lt;br />
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@Override&lt;br />
</span><span class='line'>public Socket createSocket(Socket socket, String host, int port,boolean autoClose) throws IOException, UnknownHostException {&lt;br />
</span><span class='line'>  return sslContext.getSocketFactory().createSocket(socket, host, port,autoClose);&lt;br />
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@Override&lt;br />
</span><span class='line'>public Socket createSocket() throws IOException {&lt;br />
</span><span class='line'>    return sslContext.getSocketFactory().createSocket();&lt;br />
</span><span class='line'>}&lt;br />
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<!--more-->

<p>再来看看如何做回调：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public static HttpClient getNewHttpClient() {&lt;br />
</span><span class='line'> try {&lt;br />
</span><span class='line'>  KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());&lt;br />
</span><span class='line'>  trustStore.load(null, null);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>SSLSocketFactory sf = new SSLSocketFactoryEx(trustStore);&lt;br />
</span><span class='line'>  sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>HttpParams params = new BasicHttpParams();&lt;br />
</span><span class='line'>  HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);&lt;br />
</span><span class='line'>  HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>SchemeRegistry registry = new SchemeRegistry();&lt;br />
</span><span class='line'>  registry.register(new Scheme(“http”, PlainSocketFactory.getSocketFactory(), 80));&lt;br />
</span><span class='line'>  registry.register(new Scheme(“https”, sf, 443));&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry); &lt;br />
</span><span class='line'>   return new DefaultHttpClient(ccm, params);&lt;br />
</span><span class='line'>  } catch (Exception e) {&lt;br />
</span><span class='line'>   return new DefaultHttpClient();&lt;br />
</span><span class='line'>  }&lt;br />
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>现在就可以拿这个HTTPClient去请求数据了</p>

<h3 id="section-1">解决方案二</h3>
<hr />

<p><a href="http://www.cnblogs.com/P_Chou/archive/2010/12/27/https-ssl-certification.html" title="Title">http://www.cnblogs.com/P_Chou/archive/2010/12/27/https-ssl-certification.html</a>讲的非常清楚https-ssl的认证过程，膜拜下该作者</p>

<p>1.浏览器访问https地址，保存提示的证书到本地，放到android项目中的assets目录。</p>

<p>2.导入证书，代码如下。</p>

<p>3.把证书添加为信任。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>String requestHTTPSPage(String mUrl) {
</span><span class='line'>  InputStream ins = null;
</span><span class='line'>  String result = “”;
</span><span class='line'>  try {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>ins = context.getAssets().open(“app_pay.cer”); //下载的证书放到项目中的assets目录中
</span><span class='line'>   CertificateFactory cerFactory = CertificateFactory
</span><span class='line'>                    .getInstance(“X.509”);
</span><span class='line'>   Certificate cer = cerFactory.generateCertificate(ins);
</span><span class='line'>   KeyStore keyStore = KeyStore.getInstance(“PKCS12”, “BC”);
</span><span class='line'>   keyStore.load(null, null);
</span><span class='line'>   keyStore.setCertificateEntry(“trust”, cer);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>SSLSocketFactory socketFactory = new SSLSocketFactory(keyStore);
</span><span class='line'>   Scheme sch = new Scheme(“https”, socketFactory, 443);
</span><span class='line'>   HttpClient mHttpClient = new DefaultHttpClient();
</span><span class='line'>   mHttpClient.getConnectionManager().getSchemeRegistry()
</span><span class='line'>                    .register(sch);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>BufferedReader reader = null;
</span><span class='line'>     try {
</span><span class='line'>         Log.d(TAG, “executeGet is in,murl:” + mUrl);
</span><span class='line'>         HttpGet request = new HttpGet();
</span><span class='line'>         request.setURI(new URI(mUrl));
</span><span class='line'>         HttpResponse response = mHttpClient.execute(request);
</span><span class='line'>         if (response.getStatusLine().getStatusCode() != 200) {
</span><span class='line'>            request.abort();
</span><span class='line'>            return result;
</span><span class='line'>         }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>reader = new BufferedReader(new InputStreamReader(response
</span><span class='line'>                        .getEntity().getContent()));
</span><span class='line'>  StringBuffer buffer = new StringBuffer();
</span><span class='line'>  String line = null;
</span><span class='line'>  while ((line = reader.readLine()) != null) {
</span><span class='line'>                    buffer.append(line);
</span><span class='line'>  }
</span><span class='line'>  result = buffer.toString();
</span><span class='line'>  Log.d(TAG, “mUrl=” + mUrl + “\nresult = “ + result);
</span><span class='line'>  } catch (Exception e) {
</span><span class='line'>    e.printStackTrace();
</span><span class='line'>  } finally {
</span><span class='line'>     if (reader != null) {
</span><span class='line'>        reader.close();
</span><span class='line'>     }
</span><span class='line'> }
</span><span class='line'> } catch (Exception e) {
</span><span class='line'>   // TODO: handle exception
</span><span class='line'> } finally {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>try {
</span><span class='line'>    if (ins != null)
</span><span class='line'>       ins.close();
</span><span class='line'>  } catch (IOException e) {
</span><span class='line'>     e.printStackTrace();
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>  return result;
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Screen Adaption 屏幕适配]]></title>
    <link href="http://helloyokoy.github.io/blog/android-screen-adaption/"/>
    <updated>2015-07-15T12:18:16+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-screen-adaption</id>
    <content type="html"><![CDATA[<p>众所周知，Android机型尺寸各种各样，于是屏幕适配就成了Android开发中很重要的一环。Android屏幕适配可能一些开发者都会遇到这样的问题，今天就来分享下屏幕适配，你会发现其实Android屏幕适配也可以很简单。</p>

<h2 id="section">基本概念</h2>
<p>Android屏幕适配必须要理解的一些概念，这部分可能比较枯燥，但是俗话说的好“工欲善其事，必先利器”，翻译过来就是“有什么样的枪，决定你打什么样的鸟”，一旦这些概念你理解掌握了，屏幕适配你自然而然就觉得简单多了。</p>

<ul>
  <li>
    <p>px</p>

    <p>是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素。</p>

    <p>在设计领域中，像素是用来计算数码影像的最小单位。计算机中显示的图像并非连续的线条组成，而是由许多肉眼看不见的小点组成。如果把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小点所组成，这些小点就是构成影像的最小单位“像素”。由于是最小的独立显示单位，px均为整数，不会出现0.5px的情况。如：</p>
  </li>
</ul>

<!--more-->

<p>看这个色彩鲜艳的LED灯（原图大小）</p>

<p><img src="http://stormzhang.com/image/pixel_origin.png" alt="img" /></p>

<p>你能想象这才是他的本来面目吗？（放大之后）</p>

<p><img src="http://stormzhang.com/image/pixel_scale.jpeg" alt="img" /></p>

<ul>
  <li>
    <p>in</p>

    <p>表示英寸，是屏幕的物理尺寸。每英寸等于2.54厘米。例如我们经常说的手机屏幕大小有，5（英）寸、4（英）寸就是指这个单位。这些尺寸是屏幕的对角线长度。如果手机的屏幕是4英寸，表示手机的屏幕（可视区域）对角线长度是4 X 2.54 = 10.16厘米。</p>
  </li>
  <li>
    <p>dpi</p>

    <p>dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。比如320X480分辨率的手机，宽2英寸，高3英寸, 每英寸包含的像素点的数量为320/2=160dpi（横向）或480/3=160dpi（纵向），160就是这部手机的dpi，横向和纵向的这个值都是相同的，原因是大部分手机屏幕使用正方形的像素点。</p>
  </li>
  <li>
    <p>density</p>

    <p>屏幕密度，density和dpi的关系为 density = dpi/160</p>
  </li>
  <li>
    <p>dp</p>

    <p>也即dip，设备独立像素，device independent pixels的缩写，Android特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。</p>
  </li>
  <li>
    <p>sp</p>

    <p>和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</p>
  </li>
</ul>

<h2 id="android-drawable">Android Drawable</h2>
<p>我们新建一个Android项目后应该可以看到很多drawable文件夹，分别对应不同的dpi</p>

<ul>
  <li>
    <p>drawable-ldpi (dpi=120, density=0.75)</p>
  </li>
  <li>
    <p>drawable-mdpi (dpi=160, density=1)</p>
  </li>
  <li>
    <p>drawable-hdpi (dpi=240, density=1.5)</p>
  </li>
  <li>
    <p>drawable-xhdpi (dpi=320, density=2)</p>
  </li>
  <li>
    <p>drawable-xxhdpi (dpi=480, density=3)</p>
  </li>
</ul>

<p>市面上的一些Android教程大多都是教的是为每种dpi都出一套图片资源，这个固然是一种解决办法，但同时也是一种非常笨的方法，为美工或者设计增加了不少的工作量不说，同时也会让你的apk包变的很大。那么有没有什么好的方法既能保证屏幕适配，又可以最小占用设计资源，同时最好又只使用一套dpi的图片资源呢？下面就来讲解下项目中总结出来的这个方法。</p>

<p>首先必须清楚一个自动渲染的概念，Android SDK会自动屏幕尺寸选择对应的资源文件进行渲染，如SDK检测到你手机dpi是160的话会优先到drawable-mdpi文件夹下找对应的图片资源，注意只是优先，假设你手机dpi是160，但是你只在xhpdi文件夹下有对应的图片资源文件，程序一样可以正常运行。所以理论上来说只需要提供一种规格的图片资源就ok了，如果只提供ldpi规格的图片，对于大分辨率的手机如果把图片放大就会不清晰，所以需要提供一套你需要支持的最大dpi的图片，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。</p>

<h2 id="xhdpi">xhdpi成为首选</h2>
<p>上面说了只需要提供一套大的dpi的图片就ok了，现在市面手机分辨率最大可达到1080X1920的分辨率，如Nexus5，dpi属于xxhdpi，但是毕竟还没普及，目前市面上最普遍的高端机的分辨率还多集中在720X1080范围，也就是多集中在xhdpi，所以目前来看xhpdi规格的图片成为了首选。当然随着技术规格的提高以后发展，以后可能市场上xxdpi的手机会越来越普遍，但这是后话。</p>

<h2 id="section-1">设计资源紧张怎么办？</h2>
<p>在现在的App开发中，基本都会有iOS和Android版本，有些公司为了保持App不同版本的体验交互一致，还有些公司的设计资源可能比较紧张，这些情况下iOS和Android版本基本是一个设计师主导，而大多数情况下设计师可能更会以iPhone手机为基础进行设计，包括后期的切图之类的。这个时候身为Android开发人员你是否还要求设计师单独为Android端切一套图片资源呢？这会让你们的设计师崩溃的，下面就来告诉一个项目中总结的更棒的方法。</p>

<p>相信设计师们一般都会用最新的iPhone5（5s和5的尺寸以及分辨率都一样）来做原型设计，而iPhone5的屏幕分辨率为640X1164, 屏幕尺寸为4英寸，根据勾股定理(a^2 + b^2 = c^2)640^2+1164^2=1764496, 然后再对其开根号可求出屏幕对角线的分辨率为：1328，除以4可得出iphone5的dpi：1328/4≈332 可以看出iPhone5的屏幕的dpi约等于320, 刚好属于xhdpi，所以你可以很自豪的像你们的设计师说不用专门为Android端切图，直接把iPhone的那一套切好的图片资源放入drawable-xhdpi文件夹里就ok了。</p>

<h2 id="wrapcontent-vs-dp">wrap_content VS dp</h2>
<p>wrap_content和dp都是在Android开发中应该经常用到的，然后它们冥冥中是有关系的。</p>

<p>假设你看了这篇文章后都是统一有xhdpi的资源，那么你用wrap_content完全没有问题，Android会自动为其他规格的dpi屏幕适配,比如你在xhdpi放了一张120X120px大小的图片，那么在在hdpi屏幕上显示的就只有120/2*1.5=90px大小，但是如果你不小心同样把这张图片也放入了mdpi了，这个时候用wrap_content显示就会有问题，具体看下面的例子：</p>

<p>例如假设你只在drawable_xhdpi文件夹下放了test图片，xhdpi的设备会去xhdpi文件夹下找到test图片并直接显示，而mdpi的设备优先会去mdpi文件夹里查找test图片，但是没找到，最后在xhdpi文件夹下找到，然后会自动根据density计算并缩放显示出来，实际显示出来的大小是120/2=60px, 所以整体的显示比例才会看起来比较正常</p>

<p>mdpi</p>

<p><img src="http://stormzhang.com/image/mdpi_test.png" alt="img" /></p>

<p>xhdpi</p>

<p><img src="http://stormzhang.com/image/xhdpi_test.png" alt="img" /></p>

<p>但是如果你在mdpi文件夹里也放入了同样的图片，那么mdpi的设备会直接去mdpi文件夹里寻找到test图片，并直接显示，而这时候显示不会缩放，实际显示大小就是120X120,在mdpi的屏幕上看起来就会比较大，如图：</p>

<p><img src="http://stormzhang.com/image/mdpi_test2.png" alt="img" /></p>

<p>通过上面整个过程，大家应该理解了Android加载资源的整个过程, wrap_content同样可以用dp来代替，就拿上面这个例子，在xhdpi文件夹内放入了一张120X120像素的test图片，宽高直接除density就得出dp的数值，即这种情况下以下代码是等同的.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/test" />
</span><span class='line'>
</span><span class='line'>&lt;ImageView android:layout_width="60dp" android:layout_height="60dp" android:src="@drawable/test" />
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="section-2">总结</h2>
<p>相信通过以上的讲解，对Android UI中的一些基本概念有个很好的理解，实际开发工作中也有一些高效的方法可以参考，应该可以应对大部分的屏幕适配工作。但是项目中仍然有一些比较特殊的适配需求满足不了，以后会针对一些特殊的需求进行示例讲解。</p>
]]></content>
  </entry>
  
</feed>
