<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：android | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2015-11-04T19:46:12+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android 开发遇到的坑]]></title>
    <link href="http://helloyokoy.github.io/blog/android-mistake/"/>
    <updated>2015-10-12T14:21:57+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-mistake</id>
    <content type="html"><![CDATA[<p>作为一个有三、四年Android应用开发经验的码农，自然会遇到很多坑，下面是我能够想起的一些坑（实践证明不记笔记可不是个好习惯），后面有想到其它坑会陆续补上。</p>

<ul>
  <li>
    <p>在Android library中不能使用switch-case语句访问资源ID：
<a href="http://zmywly8866.github.io/2014/12/24/android-can-not-use-switch-to-load-resource-in-libproject-solution.html">在Android library中不能使用switch-case语句访问资源ID的原因分析及解决方案</a></p>
  </li>
  <li>
    <p>不能在Activity没有完全显示时显示PopupWindow和Dialog：<a href="http://stackoverflow.com/questions/4187673/problems-creating-a-popup-window-in-android-activity">popupwindow - Problems creating a Popup Window in Android Activity</a></p>
  </li>
  <li>
    <p>在多进程之间不要用SharedPreferences共享数据，虽然可以（MODE_MULTI_PROCESS），但极不稳定：<a href="http://stackoverflow.com/questions/22129717/mode-multi-process-for-sharedpreferences-isnt-working">android - MODE_MULTI_PROCESS for SharedPreferences isn’t working</a></p>
  </li>
</ul>

<!--more-->

<ul>
  <li>
    <p>有些时候不能使用Application的Context，不然会报错（比如启动Activity，显示Dialog等）：
<img src="https://pic3.zhimg.com/e3f3236cbd96c69cdea10d014bacbeae_b.png" alt="icon" /></p>
  </li>
  <li>
    <p>同一个应用的JNI代码，不要轻易换NDK编译的版本，否则会有很多问题（主要是一些方法实现不一样，并且高版本对代码的检测更严格），比如r8没有问题，但到r9就有问题了，这是个大坑；</p>
  </li>
  <li>
    <p>Android的JNI代码中，有返回类型的函数没有返回值编译的时候也不会报错；</p>
  </li>
  <li>
    <p>当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率；</p>
  </li>
  <li>
    <p>谨慎使用Android的透明主题，透明主题会导致很多问题，比如：如果新的Activity采用了透明主题，那么当前Activity的onStop方法不会被调用；在设置为透明主题的Activity界面按Home键时，可能会导致刷屏不干净的问题；进入主题为透明主题的界面会有明显的延时感；</p>
  </li>
  <li>
    <p>不要在非UI线程中初始化ViewStub，否则会返回null；</p>
  </li>
  <li>
    <p>公共接口一定要考虑到代码重入的情况，能设计为单例就尽量用单例；</p>
  </li>
  <li>
    <p>不要通过Bundle传递大块的数据，否则会报TransactionTooLargeException异常：<a href="http://stackoverflow.com/questions/12819617/issue-passing-large-data-to-second-activity">java - Issue: Passing large data to second Activity</a></p>
  </li>
  <li>
    <p>尽量不要通过Application缓存数据，这不稳定：
<a href="http://zmywly8866.github.io/2014/12/26/android-do-not-store-data-in-the-application-object.html">不要在Android的Application对象中缓存数据!</a></p>
  </li>
  <li>
    <p>尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错；</p>
  </li>
  <li>
    <p>9图不能通过tinypng压缩，不然会有问题；</p>
  </li>
  <li>
    <p>genymotion模拟器快是因为它是基于x86架构的，如果你的应用中用到了so，但没有x86架构的so，只能放弃使用它；Android Studio的模拟器也一样；</p>
  </li>
  <li>
    <p>Eclipse的Android开发环境配置好后不要轻易升级ADT和build tools，不然会浪费你很多时间，还有就是一个workspace中的工程不要太多，不然每次启动都会很慢；</p>
  </li>
  <li>
    <p>Android studio每个版本、gradle每个版本差别都比较大（我是这样认为的），对于jni代码的编译建议在Eclipse中进行，如果在Android studio中开发jni会浪费很多时间，主要是编译脚本的配置比较麻烦；</p>
  </li>
  <li>
    <p>Eclipse中的Lint太不靠谱，特别是主工程中依赖library的时候，很多提示都是有问题的，建议使用Android Studio的工程清理工具，特别推荐；</p>
  </li>
  <li>
    <p>AsyncTask默认自己维护一个静态的线程池，而该线程池只允许同时执行一个线程，也就是说，不管多少个AsyncTask,只要是调用execute()方法，都是共享这个默认进程池的，你的任务必须在之前的任务执行完以后，才能执行。<a href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html">调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案</a></p>
  </li>
</ul>

<hr />
<p>著作权归作者所有。</p>

<p>商业转载请联系作者获得授权，非商业转载请注明出处。</p>

<p>作者：张明云</p>

<p>链接：http://www.zhihu.com/question/27818921/answer/70279930</p>

<p>来源：知乎</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android https请求no peer certificate解决方案]]></title>
    <link href="http://helloyokoy.github.io/blog/android-httpsqing-qiu-no-peer-certificatejie-jue-fang-an/"/>
    <updated>2015-08-12T16:30:44+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-httpsqing-qiu-no-peer-certificatejie-jue-fang-an</id>
    <content type="html"><![CDATA[<h3 id="section">解决方案一</h3>
<hr />

<p>写了一个自定义类继承SSLSocketFactory：</p>

<pre><code>import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;

public class SSLSocketFactoryEx extends SSLSocketFactory {
    
    SSLContext sslContext = SSLContext.getInstance("TLS");
    
    public SSLSocketFactoryEx(KeyStore truststore) 
                    throws NoSuchAlgorithmException, KeyManagementException,
                    KeyStoreException, UnrecoverableKeyException {
            super(truststore);
            
            TrustManager tm = new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {return null;}  

        @Override  
        public void checkClientTrusted(
                        java.security.cert.X509Certificate[] chain, String authType)
                                        throws java.security.cert.CertificateException {}  

        @Override  
        public void checkServerTrusted(
                        java.security.cert.X509Certificate[] chain, String authType)
                                        throws java.security.cert.CertificateException {}
    };  
    sslContext.init(null, new TrustManager[] { tm }, null);  
}  

@Override  
public Socket createSocket(Socket socket, String host, int port,boolean autoClose) throws IOException, UnknownHostException {  
        return sslContext.getSocketFactory().createSocket(socket, host, port,autoClose);  
}  

@Override  
public Socket createSocket() throws IOException {  
    return sslContext.getSocketFactory().createSocket();  
}  
}
</code></pre>

<!--more-->

<p>再来看看如何做回调：</p>

<pre><code>public static HttpClient getNewHttpClient() {  
    try {  
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());  
        trustStore.load(null, null);  
        
        SSLSocketFactory sf = new SSLSocketFactoryEx(trustStore);  
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);  

        HttpParams params = new BasicHttpParams();  
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);  
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);  

        SchemeRegistry registry = new SchemeRegistry();  
        registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));  
        registry.register(new Scheme("https", sf, 443));  

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);  

        return new DefaultHttpClient(ccm, params);  
    } catch (Exception e) {  
        return new DefaultHttpClient();  
    }  
}  
</code></pre>

<p>现在就可以拿这个HTTPClient去请求数据了</p>

<h3 id="section-1">解决方案二</h3>
<hr />

<p><a href="http://www.cnblogs.com/P_Chou/archive/2010/12/27/https-ssl-certification.html" title="Title">http://www.cnblogs.com/P_Chou/archive/2010/12/27/https-ssl-certification.html</a>讲的非常清楚https-ssl的认证过程，膜拜下该作者</p>

<p>1.浏览器访问https地址，保存提示的证书到本地，放到android项目中的assets目录。</p>

<p>2.导入证书，代码如下。</p>

<p>3.把证书添加为信任。</p>

<pre><code>String requestHTTPSPage(String mUrl) {
    InputStream ins = null;
    String result = "";
    try {
        ins = context.getAssets().open("app_pay.cer"); //下载的证书放到项目中的assets目录中
        CertificateFactory cerFactory = CertificateFactory
                .getInstance("X.509");
        Certificate cer = cerFactory.generateCertificate(ins);
        KeyStore keyStore = KeyStore.getInstance("PKCS12", "BC");
        keyStore.load(null, null);
        keyStore.setCertificateEntry("trust", cer);
 
        SSLSocketFactory socketFactory = new SSLSocketFactory(keyStore);
        Scheme sch = new Scheme("https", socketFactory, 443);
        HttpClient mHttpClient = new DefaultHttpClient();
        mHttpClient.getConnectionManager().getSchemeRegistry()
                .register(sch);
 
        BufferedReader reader = null;
        try {
            Log.d(TAG, "executeGet is in,murl:" + mUrl);
            HttpGet request = new HttpGet();
            request.setURI(new URI(mUrl));
            HttpResponse response = mHttpClient.execute(request);
            if (response.getStatusLine().getStatusCode() != 200) {
                request.abort();
                return result;
            }
 
            reader = new BufferedReader(new InputStreamReader(response
                    .getEntity().getContent()));
            StringBuffer buffer = new StringBuffer();
            String line = null;
            while ((line = reader.readLine()) != null) {
                buffer.append(line);
            }
            result = buffer.toString();
            Log.d(TAG, "mUrl=" + mUrl + "\nresult = " + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                reader.close();
            }
        }
    } catch (Exception e) {
        // TODO: handle exception
    } finally {
        try {
            if (ins != null)
                ins.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return result;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fresco介绍]]></title>
    <link href="http://helloyokoy.github.io/blog/frescojie-shao/"/>
    <updated>2015-08-09T17:09:42+08:00</updated>
    <id>http://helloyokoy.github.io/blog/frescojie-shao</id>
    <content type="html"><![CDATA[<p><img src="http://frescolib.org/static/fresco-logo.png" alt="icon" title="icon" /></p>

<h3 id="fresco">关于 Fresco</h3>
<p>Fresco 是一个强大的图片加载组件。</p>

<p>Fresco 中设计有一个叫做 image pipeline 的模块。它负责从网络，从本地文件系统，本地资源加载图片。为了最大限度节省空间和CPU时间，它含有3级缓存设计（2级内存，1级文件）。</p>

<p>Fresco 中设计有一个叫做 Drawees 模块，方便地显示loading图，当图片不再显示在屏幕上时，及时地释放内存和空间占用。</p>

<p>Fresco 支持 Android2.3(API level 9) 及其以上系统。</p>

<!--more-->

<h3 id="section">特性</h3>

<h4 id="section-1">内存管理</h4>

<p>解压后的图片，即Android中的Bitmap，占用大量的内存。大的内存占用势必引发更加频繁的GC。在5.0以下，GC将会显著地引发界面卡顿。</p>

<p>在5.0以下系统，Fresco将图片放到一个特别的内存区域。当然，在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>

<p>Fresco 在低端机器上表现一样出色，你再也不用因图片内存占用而思前想后。</p>

<h4 id="section-2">图片的渐进式呈现</h4>
<p>渐进式的JPEG图片格式已经流行数年了，渐进式图片格式先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片，这对于移动设备，尤其是慢网络有极大的利好，可带来更好的用户体验。</p>

<p>Android 本身的图片库不支持此格式，但是Fresco支持。使用时，和往常一样，仅仅需要提供一个图片的URI即可，剩下的事情，Fresco会处理。</p>

<h4 id="gifwebp">Gif图和WebP格式</h4>
<p>是的，支持加载Gif图，支持WebP格式。</p>

<h4 id="section-3">图像的呈现</h4>
<p>Fresco 的 Drawees 设计，带来一些有用的特性：</p>

<ul>
  <li>自定义居中焦点(对人脸等图片显示非常有帮助)</li>
  <li>圆角图，当然圆圈也行。</li>
  <li>下载失败之后，点击重现下载</li>
  <li>自定义占位图，自定义overlay, 或者进度条</li>
  <li>指定用户按压时的overlay</li>
</ul>

<h4 id="section-4">图像的加载</h4>
<p>Fresco 的 image pipeline 设计，允许用户在多方面控制图片的加载：</p>

<ul>
  <li>为同一个图片指定不同的远程路径，或者使用已经存在本地缓存中的图片</li>
  <li>先显示一个低解析度的图片，等高清图下载完之后再显示高清图</li>
  <li>加载完成回调通知</li>
  <li>对于本地图，如有EXIF缩略图，在大图加载完成之前，可先显示缩略图</li>
  <li>缩放或者旋转图片</li>
  <li>处理已下载的图片</li>
  <li>WebP 支持</li>
</ul>

<h3 id="section-5">了解更多</h3>
<ul>
  <li>相关博客: <a href="https://code.facebook.com/posts/366199913563917" title="Title">Fresco的发布</a></li>
  <li><a href="http://www.fresco-cn.org/docs/download-fresco.html" title="Title">下载</a>Fresco</li>
  <li><a href="http://www.fresco-cn.org/docs/index.html" title="Title">文档</a></li>
  <li><a href="https://github.com/facebook/fresco" title="Title">GitHub</a>的源码</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eventbus介绍]]></title>
    <link href="http://helloyokoy.github.io/blog/eventbusjie-shao/"/>
    <updated>2015-05-10T21:37:33+08:00</updated>
    <id>http://helloyokoy.github.io/blog/eventbusjie-shao</id>
    <content type="html"><![CDATA[<p><img src="https://github.com/greenrobot/EventBus/raw/master/EventBus-Publish-Subscribe.png" alt="icon" title="icon" /></p>

<blockquote>
  <p>EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。</p>
</blockquote>

<h3 id="eventbus">1.下载EventBus的类库</h3>

<p>源码：<a href="https://github.com/greenrobot/EventBus" title="url">https://github.com/greenrobot/EventBus</a></p>

<!--more-->

<h3 id="section">2.基本使用</h3>

<ol>
  <li>
    <p>自定义一个类，可以是空类，比如：</p>

    <pre><code> public class AnyEventType {  
     public AnyEventType(){}  
 }  
</code></pre>
  </li>
  <li>
    <p>在要接收消息的页面注册：</p>

    <pre><code> eventBus.register(this);  
</code></pre>
  </li>
  <li>
    <p>发送消息</p>

    <pre><code> eventBus.post(new AnyEventType event);  
</code></pre>
  </li>
  <li>
    <p>接受消息的页面实现(共有四个函数，各功能不同，这是其中之一，可以选择性的实现，这里先实现一个)：</p>

    <pre><code> public void onEvent(AnyEventType event) {}  
</code></pre>
  </li>
  <li>
    <p>解除注册</p>

    <pre><code> eventBus.unregister(this);  
</code></pre>
  </li>
</ol>

<p>详细教程: <a href="http://blog.csdn.net/harvic880925/article/details/40660137" title="url">http://blog.csdn.net/harvic880925/article/details/40660137</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android开源框架]]></title>
    <link href="http://helloyokoy.github.io/blog/androidkai-yuan-kuang-jia/"/>
    <updated>2015-05-09T17:42:35+08:00</updated>
    <id>http://helloyokoy.github.io/blog/androidkai-yuan-kuang-jia</id>
    <content type="html"><![CDATA[<h3 id="volley">1、volley</h3>

<p>项目地址 https://github.com/smanikandan14/Volley-demo</p>

<ol>
  <li>JSON，图像等的异步下载；</li>
  <li>网络请求的排序（scheduling）</li>
  <li>网络请求的优先级处理</li>
  <li>缓存</li>
  <li>多级别取消请求</li>
  <li>和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）</li>
</ol>

<h3 id="android-async-http">2、android-async-http</h3>

<p>项目地址：https://github.com/loopj/android-async-http</p>

<p>文档介绍：http://loopj.com/android-async-http/</p>

<ol>
  <li>在匿名回调中处理请求结果</li>
  <li>在UI线程外进行http请求</li>
  <li>文件断点上传</li>
  <li>智能重试</li>
  <li>默认gzip压缩</li>
  <li>支持解析成Json格式</li>
  <li>可将Cookies持久化到SharedPreferences
<!--more-->
###3、Afinal框架</li>
</ol>

<p>项目地址：https://github.com/yangfuhai/afinal</p>

<p>主要有四大模块：</p>

<ol>
  <li>数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。</li>
  <li>注解模块：android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。</li>
  <li>网络模块：通过httpclient进行封装http数据请求，支持ajax方式加载，支持下载、上传文件功能。</li>
  <li>图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（android2.3以后google已经不建议使用弱引用，android2.3后强行回收软引用和弱引用，详情查看android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，在imageview显示图片的时候播放动画等（默认是渐变动画显示）。</li>
  <li>
    <h3 id="xutils">4、xUtils框架</h3>
  </li>
</ol>

<p>项目地址：https://github.com/wyouflf/xUtils</p>

<p>主要有四大模块：</p>

<ol>
  <li>数据库模块：android中的orm框架，一行代码就可以进行增删改查；
         支持事务，默认关闭；
         可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；
         支持绑定外键，保存实体时外键关联实体自动保存或更新；
         自动加载外键关联实体，支持延时加载；
         支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。</li>
  <li>注解模块：android中的ioc框架，完全注解方式就可以进行UI，资源和事件绑定；
         新的事件绑定方式，使用混淆工具混淆后仍可正常工作；
         目前支持常用的20种事件绑定，参见ViewCommonEventListener类和包com.lidroid.xutils.view.annotation.event。</li>
  <li>网络模块：支持同步，异步方式的请求；
         支持大文件上传，上传大文件不会oom；
         支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；
         下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；
         返回文本内容的请求(默认只启用了GET请求)支持缓存，可设置默认过期时间和针对当前请求的过期时间。</li>
  <li>图片缓存模块：加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象；
         支持加载网络图片和本地图片；
         内存管理使用lru算法，更好的管理bitmap内存；
         可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等…</li>
</ol>

<h3 id="thinkandroid">5、ThinkAndroid</h3>

<p>项目地址：https://github.com/white-cat/ThinkAndroid</p>

<p>主要有以下模块：</p>

<ol>
  <li>MVC模块：实现视图与模型的分离。</li>
  <li>ioc模块：android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。</li>
  <li>数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。</li>
  <li>http模块：通过httpclient进行封装http数据请求，支持异步及同步方式加载。</li>
  <li>缓存模块：通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置</li>
  <li>图片缓存模块：imageview加载图片的时候无需考虑图片加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。</li>
  <li>配置器模块：可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。</li>
  <li>日志打印模块：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印</li>
  <li>下载器模块:可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。</li>
  <li>网络状态检测模块：当网络状态改变时，对其进行检</li>
</ol>

<h3 id="loonandroid">6、LoonAndroid</h3>

<p>项目地址：https://github.com/gdpancheng/LoonAndroid</p>

<p>主要有以下模块：</p>

<ol>
  <li>自动注入框架（只需要继承框架内的application既可）</li>
  <li>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）</li>
  <li>网络请求模块（继承了基本上现在所有的http请求）</li>
  <li>eventbus（集成一个开源的框架）</li>
  <li>验证框架（集成开源框架）</li>
  <li>json解析（支持解析成集合或者对象）</li>
  <li>数据库（不知道是哪位写的 忘记了）</li>
  <li>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）</li>
  <li>自动更新模块</li>
  <li>一系列工具类</li>
</ol>

]]></content>
  </entry>
  
</feed>
