<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：android | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2018-01-21T16:29:44+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android frame]]></title>
    <link href="http://helloyokoy.github.io/blog/android-frame/"/>
    <updated>2016-05-26T14:47:35+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-frame</id>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160524172058595" alt="img" /></p>

<!--more-->

<ul>
  <li>缓存</li>
</ul>

<p>DiskLruCache:	Java实现基于LRU的磁盘缓存</p>

<ul>
  <li>图片加载</li>
</ul>

<p>Android Universal Image Loader:	一个强大的加载，缓存，展示图片的库</p>

<p>Picasso:	一个强大的图片下载与缓存的库</p>

<p>Fresco:	一个用于管理图像和他们使用的内存的库</p>

<p>Glide:	一个图片加载和缓存的库</p>

<ul>
  <li>图片处理</li>
</ul>

<p>Picasso-transformations	: 一个为Picasso提供多种图片变换的库</p>

<p>Glide-transformations:	一个为Glide提供多种图片变换的库</p>

<p>Android-gpuimage: 	基于OpenGL的Android过滤器</p>

<ul>
  <li>网络请求</li>
</ul>

<p>Android Async HTTP:	Android异步HTTP库</p>

<p>AndroidAsync: 	异步Socket，HTTP(客户端+服务器)，WebSocket，和socket.io库。基于NIO而不是线程。</p>

<p>OkHttp: 	一个Http与Http/2的客户端</p>

<p>Retrofit:	类型安全的Http客户端</p>

<p>Volley: Google推出的Android异步网络请求框架和图片加载框架</p>

<ul>
  <li>网络解析</li>
</ul>

<p>Gson:	一个Java序列化/反序列化库，可以将JSON和java对象互相转换</p>

<p>Jackson:	Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象</p>

<p>Fastjson:	Java上一个快速的JSON解析器/生成器</p>

<p>HtmlPaser: 一种用来解析单个独立html或嵌套html的方式</p>

<p>Jsoup:	一个以最好的DOM，CSS和jQuery解析html的库</p>

<ul>
  <li>数据库</li>
</ul>

<p>OrmLite:	JDBC和Android的轻量级ORM java包</p>

<p>Sugar:	用超级简单的方法处理Android数据库</p>

<p>GreenDAO:	一种轻快地将对象映射到SQLite数据库的ORM解决方案</p>

<p>ActiveAndroid: 以活动记录方式为Android SQLite提供持久化</p>

<p>SQLBrite:	SQLiteOpenHelper 和ContentResolver的轻量级包装</p>

<p>Realm 移动数据库：一个SQLite和ORM的替换品</p>

<ul>
  <li>依赖注入</li>
</ul>

<p>ButterKnife:	将Android视图和回调方法绑定到字段和方法上</p>

<p>Dagger2:	一个Android和java快速依赖注射器。</p>

<p>AndroidAnotations:	快速安卓开发。易于维护</p>

<p>RoboGuice: Android平台的Google Guice</p>

<ul>
  <li>图表</li>
</ul>

<p>WilliamChart:	创建图表的Android库</p>

<p>HelloCharts:	兼容到API8的Android图表库</p>

<p>MPAndroidChart:	一个强大的Android图表视图/图形库</p>

<ul>
  <li>后台处理</li>
</ul>

<p>Tape:	一个轻快的，事务性的，基于文件的FIFO的库</p>

<p>Android Priority Job Queue: 一个专门为Android轻松调度任务的工作队列</p>

<ul>
  <li>事件总线</li>
</ul>

<p>EventBus:	安卓优化的事件总线，简化了活动、片段、线程、服务等的通信</p>

<p>Otto:	一个基于Guava的增强的事件总线</p>

<ul>
  <li>响应式编程</li>
</ul>

<p>RxJava: JVM上的响应式扩展</p>

<p>RxJavaJoins:	为RxJava提供Joins操作</p>

<p>RxAndroid: Android上的响应式扩展，在RxJava基础上添加了Android线程调度</p>

<p>RxBinding: 提供用RxJava绑定Android UI的API</p>

<p>Agera:	Android上的响应式编程</p>

<ul>
  <li>Log框架</li>
</ul>

<p>Logger: 简单，漂亮，强大的Android日志工具
Hugo: 在调试版本上注解的触发方法进行日志记录
Timber: 一个小的，可扩展的日志工具</p>

<ul>
  <li>测试框架</li>
</ul>

<p>Mockito:	Java编写的Mocking单元测试框架</p>

<p>Robotium:	Android UI 测试</p>

<p>Robolectric:	Android单元测试框架</p>

<p>Android自带很多测试工具：JUnit，Monkeyrunner，
UiAutomator，Espresso等</p>

<ul>
  <li>调试框架</li>
</ul>

<p>Stetho: 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试</p>

<ul>
  <li>性能优化</li>
</ul>

<p>LeakCanary:	内存泄漏检测工具</p>

<p>ACRA:	Android应用程序崩溃报告</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[facebook redex]]></title>
    <link href="http://helloyokoy.github.io/blog/facebook-redex/"/>
    <updated>2016-04-15T17:08:14+08:00</updated>
    <id>http://helloyokoy.github.io/blog/facebook-redex</id>
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160414083628369" alt="redex" /></p>

<p>去年，Facebook使用叫ReDex的字节码优化工具优化了他们的安卓应用的性能.</p>

<p>现在，ReDex已经开源了。安卓开发者可以免费地使用这个工具优化自己的应用。也可以将它用作其它安卓字节码优化工具的基础。</p>

<!--more-->

<p>在Facebook工程博客的一篇文章中指出，.DEX（安卓的可执行文件的形式）文件中的类，并不是按照应用启动时候加载的顺序加载的，而是按照编译工具指定的顺序加载的。</p>

<p>ReDex使用程序运行时产生的运行数据判定哪些类应该在.DEX文件中被优先载入。“想要最小化从内存中读取数据的次数，最好从启动的时候就载入字节码。”Facebook称，他们使用ReDex对应用优化之后，对存储的读取减少了25%，运行速度提高了30%。</p>

<p>关于这个速度，Facebook称，在存储较慢的老旧机器上效果非常明显，但是对于新的收集，性能也有明显的提高。Facebook在一台搭载了安卓4.4的全新的Nexus4上（有35%的安卓设备运行这个版本）测试，启动时间从2秒降至1.6秒。</p>

<p>Runtime分析可以用来删除无关的元数据和接口，但是开发者也可以自定义优化的行为。比如，有些方法即使没有直接被调用，也可以让它们保留下来。</p>

<p>这个优化是在应用编译完成之后进行的。也就是说，理论上你也可以结合其他优化，比如对Java进行虚拟机层的优化和语言的优化，像即将到来的Java 9的语言模块特性等等。</p>

<p>优化Java的字节码文件并不是一种新技术。还有其他的开源项目，例如ProGuard就可以通过删除运行时没有使用的代码进行优化。但是它并不能像ReDex那样按照执行顺序来重新组织类。</p>

<hr />
<p>原文链接：  <a href="http://www.infoworld.com/article/3055222/android/">http://www.infoworld.com/article/3055222/android/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 轻量缓存框架 ASimpleCache]]></title>
    <link href="http://helloyokoy.github.io/blog/anroi-asimplecache/"/>
    <updated>2015-10-14T20:28:27+08:00</updated>
    <id>http://helloyokoy.github.io/blog/anroi-asimplecache</id>
    <content type="html"><![CDATA[<p>做Android应用开发的同学们相信对“缓存”这个词不陌生，缓存可能有多方面的概念，这里大概列举下程序开发的缓存大概有哪些：</p>

<ol>
  <li>
    <p>服务端控制缓存
如volley请求库，便是通过服务端的“Cache-Control”和“max-age”来告诉客户端有没有缓存以及缓存的时间，也是推荐的使用方式，但是需要服务端配合，比较灵活。</p>
  </li>
  <li>
    <p>客户端直接控制缓存</p>
  </li>
</ol>

<p>有些时候不需要服务端来支持的话，客户端可以直接做一层缓存，思路就是请求之后把数据缓存在本地，最常见的是直接以文件缓存在本地就好了，当然你可以缓存在本地的sqlite，以sqlite文件的形式缓存数据处理更灵活点，然后客户端自己处理缓存的时间，过期则直接清除数据。对于一些不太经常变化的页面，采用这种缓存可以减少客户端流量，同时减少服务器并发量。</p>

<p>对于一些新闻类或者timeline这种，数据变化是非常频繁的，针对这种情况可能就不太适合设置缓存时间，这种情况可以考虑让页面每次进来都会自动刷新一次以获取最新数据，如果网络不好或者断开时可以直接读取本地缓存，增加用户体验。当然如果想要更复杂的处理可以配合时间来判断当前页面要不要刷新。</p>

<!--more-->

<p>今天就介绍一种简易的缓存框架，使用起来非常简单。</p>

<h4 id="asimplecache">ASimpleCache</h4>

<p>ASimpleCache 是一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来）。</p>

<h4 id="section">它可以缓存什么东西？</h4>

<p>普通的字符串、JsonObject、JsonArray、Bitmap、Drawable、序列化的java对象，和 byte数据。</p>

<h4 id="asimplecache-1">如何使用 ASimpleCache？</h4>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>ACache mCache = ACache.get(this);
</span><span class='line'>mCache.put(“test_key1”, “test value”);
</span><span class='line'>mCache.put(“test_key2”, “test value”, 10);//保存10秒，如果超过10秒去获取这个key，将为null
</span><span class='line'>mCache.put(“test_key3”, “test value”, 2 * ACache.TIME_DAY);//保存两天，如果超过两天去获取这个key，将为null&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>获取数据</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>ACache mCache = ACache.get(this);
</span><span class='line'>String value = mCache.getAsString(“test_key1”);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>最后此项目的开源地址： <a href="https://github.com/yangfuhai/ASimpleCache">ASimpleCache</a></p>

<hr />
<p>转载自 <a href="http://stormzhang.com/android/2014/10/17/android-simple-cache/">strom博客</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发遇到的坑]]></title>
    <link href="http://helloyokoy.github.io/blog/android-mistake/"/>
    <updated>2015-10-12T14:21:57+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-mistake</id>
    <content type="html"><![CDATA[<p>作为一个有三、四年Android应用开发经验的码农，自然会遇到很多坑，下面是我能够想起的一些坑（实践证明不记笔记可不是个好习惯），后面有想到其它坑会陆续补上。</p>

<ul>
  <li>
    <p>在Android library中不能使用switch-case语句访问资源ID：
<a href="http://zmywly8866.github.io/2014/12/24/android-can-not-use-switch-to-load-resource-in-libproject-solution.html">在Android library中不能使用switch-case语句访问资源ID的原因分析及解决方案</a></p>
  </li>
  <li>
    <p>不能在Activity没有完全显示时显示PopupWindow和Dialog：<a href="http://stackoverflow.com/questions/4187673/problems-creating-a-popup-window-in-android-activity">popupwindow - Problems creating a Popup Window in Android Activity</a></p>
  </li>
  <li>
    <p>在多进程之间不要用SharedPreferences共享数据，虽然可以（MODE_MULTI_PROCESS），但极不稳定：<a href="http://stackoverflow.com/questions/22129717/mode-multi-process-for-sharedpreferences-isnt-working">android - MODE_MULTI_PROCESS for SharedPreferences isn’t working</a></p>
  </li>
</ul>

<!--more-->

<ul>
  <li>
    <p>有些时候不能使用Application的Context，不然会报错（比如启动Activity，显示Dialog等）：
<img src="https://pic3.zhimg.com/e3f3236cbd96c69cdea10d014bacbeae_b.png" alt="icon" /></p>
  </li>
  <li>
    <p>同一个应用的JNI代码，不要轻易换NDK编译的版本，否则会有很多问题（主要是一些方法实现不一样，并且高版本对代码的检测更严格），比如r8没有问题，但到r9就有问题了，这是个大坑；</p>
  </li>
  <li>
    <p>Android的JNI代码中，有返回类型的函数没有返回值编译的时候也不会报错；</p>
  </li>
  <li>
    <p>当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率；</p>
  </li>
  <li>
    <p>谨慎使用Android的透明主题，透明主题会导致很多问题，比如：如果新的Activity采用了透明主题，那么当前Activity的onStop方法不会被调用；在设置为透明主题的Activity界面按Home键时，可能会导致刷屏不干净的问题；进入主题为透明主题的界面会有明显的延时感；</p>
  </li>
  <li>
    <p>不要在非UI线程中初始化ViewStub，否则会返回null；</p>
  </li>
  <li>
    <p>公共接口一定要考虑到代码重入的情况，能设计为单例就尽量用单例；</p>
  </li>
  <li>
    <p>不要通过Bundle传递大块的数据，否则会报TransactionTooLargeException异常：<a href="http://stackoverflow.com/questions/12819617/issue-passing-large-data-to-second-activity">java - Issue: Passing large data to second Activity</a></p>
  </li>
  <li>
    <p>尽量不要通过Application缓存数据，这不稳定：
<a href="http://zmywly8866.github.io/2014/12/26/android-do-not-store-data-in-the-application-object.html">不要在Android的Application对象中缓存数据!</a></p>
  </li>
  <li>
    <p>尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错；</p>
  </li>
  <li>
    <p>9图不能通过tinypng压缩，不然会有问题；</p>
  </li>
  <li>
    <p>genymotion模拟器快是因为它是基于x86架构的，如果你的应用中用到了so，但没有x86架构的so，只能放弃使用它；Android Studio的模拟器也一样；</p>
  </li>
  <li>
    <p>Eclipse的Android开发环境配置好后不要轻易升级ADT和build tools，不然会浪费你很多时间，还有就是一个workspace中的工程不要太多，不然每次启动都会很慢；</p>
  </li>
  <li>
    <p>Android studio每个版本、gradle每个版本差别都比较大（我是这样认为的），对于jni代码的编译建议在Eclipse中进行，如果在Android studio中开发jni会浪费很多时间，主要是编译脚本的配置比较麻烦；</p>
  </li>
  <li>
    <p>Eclipse中的Lint太不靠谱，特别是主工程中依赖library的时候，很多提示都是有问题的，建议使用Android Studio的工程清理工具，特别推荐；</p>
  </li>
  <li>
    <p>AsyncTask默认自己维护一个静态的线程池，而该线程池只允许同时执行一个线程，也就是说，不管多少个AsyncTask,只要是调用execute()方法，都是共享这个默认进程池的，你的任务必须在之前的任务执行完以后，才能执行。<a href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html">调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案</a></p>
  </li>
</ul>

<hr />
<p>著作权归作者所有。</p>

<p>商业转载请联系作者获得授权，非商业转载请注明出处。</p>

<p>作者：张明云</p>

<p>链接：http://www.zhihu.com/question/27818921/answer/70279930</p>

<p>来源：知乎</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Genymotion模拟器]]></title>
    <link href="http://helloyokoy.github.io/blog/android-genymotion/"/>
    <updated>2015-09-04T19:48:35+08:00</updated>
    <id>http://helloyokoy.github.io/blog/android-genymotion</id>
    <content type="html"><![CDATA[<p>相信很多Android开发者一定受够了速度慢、体验差效率及其地下的官方模拟器了,自己在平时的开发中几乎是不会用模拟器的，等的时间太久了，但是在一些尺寸适配或是兼容性测试的时候没有足够多的机器进行测试，这个时候就必须得用模拟器来代替了。用的久了真的不堪忍受那龟速般的模拟器，好在今天发现了一款神级模拟器Genymotion，就像发现新大陆般喜爱，下面就来介绍下。</p>

<h4 id="genymotion">Genymotion简介</h4>
<p>Genymotion是一套完整的工具，它提供了Android虚拟环境。如果你没有物理机器，又不想忍受官方模拟器的折磨，Genymotion会是你非常不错的选择， 它简直就是开发者、测试人员、推销者甚至是游戏玩家的福音。</p>

<!--more-->

<p><img src="http://a1.jikexueyuan.com/home/201501/16/5bbe/54b88953518c6.jpg" alt="icon" /></p>

<p>Genymotion支持Windows、Linux和Mac OS，容易安装和使用，下面就然我们一起来体验神器给我们带来的快感吧。</p>

<h4 id="genymotion-1">Genymotion特性</h4>
<p>最好的Android模拟体验</p>

<ul>
  <li>
    <p>支持OpenGL加速，提供最好的3D性能体验</p>
  </li>
  <li>
    <p>可以从Google Play安装应用</p>
  </li>
  <li>
    <p>支持全屏并改善了使用感受</p>
  </li>
</ul>

<p>全控制</p>

<ul>
  <li>
    <p>可同时启动多个模拟器</p>
  </li>
  <li>
    <p>支持传感器管理，如电池状态、GPS、Accelerator加速器</p>
  </li>
  <li>
    <p>支持Shell控制模拟器</p>
  </li>
</ul>

<p>完全兼容ADB，您可以从主机控制您的模拟器</p>

<p>管理设备</p>

<ul>
  <li>
    <p>易安装</p>
  </li>
  <li>
    <p>兼容Microsoft Windows 32/64 bits, Mac OSX 10.5+ and Linux 32/64 bits</p>
  </li>
  <li>
    <p>可以配置模拟器参数，如屏幕分辨率、内存大小、CPU数量</p>
  </li>
  <li>
    <p>轻松下载、部署最新的Genymotion虚拟设备。</p>
  </li>
</ul>

<p>从Eclipse启动虚拟设备</p>

<ul>
  <li>使用Genymotion测试您的应用</li>
</ul>

<h4 id="section">安装与配置</h4>

<p>安装基本是一路next，虽然Genymotion是免费版的，但是要求注册个账号才可以配置模拟器，配置好启动真是神速啊。</p>

<h4 id="eclipse">Eclipse插件安装</h4>

<p>Genymotion还支持Eclipse IDE，这大大方便了我们使用Genymotion来开发应用。安装方式：</p>

<ul>
  <li>
    <p>启动Eclipse，Help-&gt;Install New Software…-&gt;Add</p>
  </li>
  <li>
    <p>填写一下信息：</p>

    <p>Name: Genymobile</p>

    <p>Location: http://plugins.genymotion.com/eclipse</p>
  </li>
</ul>

<p>接下来跟安装adt的流程一样，指导完成
最后附上官网地址：<a href="http://www.genymotion.com/">http://www.genymotion.com/</a></p>
]]></content>
  </entry>
  
</feed>
