<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ios | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2015-12-10T16:36:29+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[xcode plugin ]]></title>
    <link href="http://helloyokoy.github.io/blog/xcode-plugin/"/>
    <updated>2015-12-10T16:17:52+08:00</updated>
    <id>http://helloyokoy.github.io/blog/xcode-plugin</id>
    <content type="html"><![CDATA[<p>新版 xcode 插件 不能用 解决方法</p>

<pre><code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID`
</code></pre>

<p>xcode 插件管理器</p>

<pre><code>Alcatraz
</code></pre>

<p>xcode 常用插件</p>

<pre><code>xtodo 
fuzzyautocompelte
codepilot
xcodeboost
xalign
KSimageNamed
xcolors
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS self 和 下划线 _ 区别]]></title>
    <link href="http://helloyokoy.github.io/blog/ios-self/"/>
    <updated>2015-12-05T15:48:50+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ios-self</id>
    <content type="html"><![CDATA[<pre><code>@property (nonatomic,copy) NSString *propertyName;
</code></pre>

<p>self.propertyName是对属性的访问；使用_propertyName是对局部变量的访问。</p>

<p>所有被声明为属性的成员，在iOS5 之前需要使用编译器指令@synthesize 来告诉编译器帮助生成属性的getter,setter方法。
之后这个指令可以不用人为指定了，默认情况下编译器会帮我们生成。</p>

<p>编译器在生成getter,setter方法时是有优先级的，它首先查找当前的类中用户是否已定义属性的getter,setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。</p>

<p>也就是说你在使用self.propertyName 时是在调用一个getter方法。</p>

<pre><code>self.propertyName 会让计数器＋1;_propertyName却不会。  

_propertyName是类似于self-&gt;_propertyName。
</code></pre>

<p>用self.propertyName 是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下划线的时候忽视了self这个指针，后者容易在block中造成循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Charles]]></title>
    <link href="http://helloyokoy.github.io/blog/charles/"/>
    <updated>2015-11-26T21:34:03+08:00</updated>
    <id>http://helloyokoy.github.io/blog/charles</id>
    <content type="html"><![CDATA[<p><img src="http://blog.devtang.com/images/charles-promo.png" alt="ad" /></p>

<p>Charles 正版<a href="http://item.taobao.com/item.htm?&amp;id=524230901640">五折优惠活动</a>（限时：2015 年 11 月 14 日 – 30 日），仅限中国区购买，点击购买。在活动期结束后，价格将从 169 元上涨到 199 元。</p>

<h3 id="section">简介</h3>

<p><img src="http://blog.devtang.com/images/charles-logo.png" alt="img" /></p>

<p>Charles 是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p>

<p><a href="http://blog.devtang.com/images/charles-logo.png">Charles</a> 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p>

<p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p>

<p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p>

<p>Charles 主要的功能包括：</p>

<p>截取 Http 和 Https 网络封包。</p>

<ol>
  <li>支持重发网络请求，方便后端调试。</li>
  <li>支持修改网络请求参数。</li>
  <li>支持网络请求的截获并动态修改。</li>
  <li>支持模拟慢速网络。</li>
</ol>

<!--more-->

<h3 id="charles">安装 Charles</h3>

<p>去 Charles 的官方网站（<a href="http://www.charlesproxy.com">http://www.charlesproxy.com</a>）下载最新版的 Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。</p>

<h3 id="charles-">将 Charles 设置成系统代理</h3>

<p>之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。</p>

<p>启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-pro-3.png" alt="img" /></p>

<p>之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。</p>

<p>需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p>

<p>Charles 主界面介绍</p>

<p><img src="http://blog.devtang.com/images/charles-pro-4.png" alt="img" /></p>

<p>Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。</p>

<ol>
  <li>Structure 视图将网络请求按访问的域名分类。</li>
  <li>Sequence 视图将网络请求按访问的时间排序。</li>
</ol>

<p>大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p>

<p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p>

<h3 id="section-1">过滤网络请求</h3>

<p>通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法：</p>

<p>方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuantiku.com , 那么只需要在 Filter 栏中填入 yuantiku 即可。</p>

<p>方法二：在 Charles 的菜单栏选择 “Proxy”–&gt;“Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-filter-setting.jpg" alt="img" /></p>

<p>通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。</p>

<p>方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-focus.png" alt="img" /></p>

<p>这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。</p>

<h3 id="iphone-">截取 iPhone 上的网络封包</h3>

<p>Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。</p>

<p>Charles 上的设置</p>

<p>要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”–&gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示:</p>

<p><img src="http://blog.devtang.com/images/charles-proxy-setting.jpg" alt="img" /></p>

<p>iPhone 上的设置</p>

<p>首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-local-ip.png" alt="img" /></p>

<p>在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-iphone-setting.jpg" alt="img" /></p>

<p>设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。</p>

<h3 id="https-">截取 Https 通讯信息</h3>

<p>安装证书</p>

<p>如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p>

<p>首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-pro-1.png" alt="img" /></p>

<p>需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-ssl-add-host.jpg" alt="img" /></p>

<p>这样，对于该 Host 的所有 SSL 请求可以被截取到了。</p>

<h3 id="https--1">截取移动设备中的 Https 通讯信息</h3>

<p>如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” –&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-pro-2.png" alt="img" /></p>

<p>按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。</p>

<h3 id="section-2">模拟慢速网络</h3>

<p>在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。</p>

<p>在 Charles 的菜单上，选择 “Proxy”–&gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-throttle-setting.jpg" alt="img" /></p>

<p>如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p>

<h3 id="section-3">修改网络请求内容</h3>

<p>有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-edit.png" alt="img" /></p>

<p>我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-execute.png" alt="img" /></p>

<h3 id="section-4">给服务器做压力测试</h3>

<p>我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。</p>

<p>我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-repeat-1.png" alt="img" /></p>

<p>接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。</p>

<p><img src="http://blog.devtang.com/images/charles-repeat-2.png" alt="img" /></p>

<p>悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。</p>

<h3 id="section-5">修改服务器返回内容</h3>

<p>有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。</p>

<p>根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：</p>

<ol>
  <li>Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。</li>
  <li>Rewrite 功能适合对网络请求进行一些正则替换。</li>
  <li>Breakpoints 功能适合做一些临时性的修改。</li>
</ol>

<h3 id="map-">Map 功能</h3>

<p>Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。</p>

<p>在 Charles 的菜单中，选择 “Tools”–&gt;“Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。</p>

<p><img src="http://blog.devtang.com/images/charles-map.png" alt="img" /></p>

<p>对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 www.yuantiku.com（线上服务器）。</p>

<p><img src="http://blog.devtang.com/images/charles-map-remote.png" alt="img" /></p>

<p>对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图所示），然后稍加修改，成为我们的目标映射文件。</p>

<p><img src="http://blog.devtang.com/images/charles-save-response.png" alt="img" /></p>

<p>下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。</p>

<p><img src="http://blog.devtang.com/images/charles-map-local.png" alt="img" /></p>

<h3 id="rewrite-">Rewrite 功能</h3>

<p>Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。</p>

<p>例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示：</p>

<p><img src="http://blog.devtang.com/images/charles-rewrite-1.jpeg" alt="img" /></p>

<p>我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则：</p>

<p><img src="http://blog.devtang.com/images/charles-rewrite-2.png" alt="img" /></p>

<p>完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/charles-rewrite-3.png" alt="img" /></p>

<h3 id="breakpoints-">Breakpoints 功能</h3>

<p>上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。</p>

<p>Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。</p>

<p>下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。</p>

<p><img src="http://blog.devtang.com/images/charles-breakpoint.png" alt="img" /></p>

<p>需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。</p>

<hr />
<p>文章装载自 <a href="http://blog.devtang.com/blog/2015/11/14/charles-introduction/">唐巧个人博客</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSLog 和 LLDB]]></title>
    <link href="http://helloyokoy.github.io/blog/nslog-and-lldb/"/>
    <updated>2015-11-26T18:38:31+08:00</updated>
    <id>http://helloyokoy.github.io/blog/nslog-and-lldb</id>
    <content type="html"><![CDATA[<h3 id="section">前言</h3>

<p>打Log是我们debug时最简单朴素的方法，NSLog对于objc开发就像printf对于c一样重要。但在使用NSLog打印大量Log，尤其是在游戏开发时（如每一帧都打印数据），NSLog会明显的拖慢程序的运行速度（游戏帧速严重下滑）。本文探究了一下NSLog如此之慢的原因，并尝试使用lldb断点调试器替代NSLog进行debug log。</p>

<h3 id="section-1">小测试</h3>

<p>测试下分别使用NSLog和printf打印10000次耗费的时间。CFAbsoluteTimeGetCurrent()函数可以打印出当前的时间戳，精度还是很高的，于是乎测试代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>CFAbsoluteTime startNSLog = CFAbsoluteTimeGetCurrent(); 
</span><span class='line'>for (int i = 0; i &lt; 10000; i++) { 
</span><span class='line'>    NSLog(@”%d”, i); 
</span><span class='line'>} 
</span><span class='line'>CFAbsoluteTime endNSLog = CFAbsoluteTimeGetCurrent();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>CFAbsoluteTime startPrintf = CFAbsoluteTimeGetCurrent(); 
</span><span class='line'>for (int i = 0; i &lt; 10000; i++) { 
</span><span class='line'>    printf(“%d\n”, i); 
</span><span class='line'>} 
</span><span class='line'>CFAbsoluteTime endPrintf = CFAbsoluteTimeGetCurrent();&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog(@”NSLog time: %lf, printf time: %lf”, endNSLog - startNSLog, endPrintf - startPrintf);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>这个时间和机器肯定有关系，只看它们的差别就好。为了全面性，尝试了三种平台：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>NSLog time: 4.985445, printf time: 0.084193 // mac 
</span><span class='line'>NSLog time: 5.562460, printf time: 0.019408 // 模拟器 
</span><span class='line'>NSLog time: 10.471490, printf time: 0.090503 // 真机调试(iphone5)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>可以发现，在mac上（模拟器其实也算是mac吧）速度差别达到了60倍左右，而真机调试甚至达到了离谱的100多倍。</p>

<p><!--more--></p>

<h3 id="section-2">探究原因</h3>

<p>基本上这种事情一定可以在Apple文档中找到，看NSLog的文档，第一句话就说：Logs an error message to the Apple System Log facility.，所以首先，NSLog就不是设计作为普通的debug log的，而是error log；其次，NSLog也并非是printf的简单封装，而是Apple System Log(后面简称ASL)的封装。</p>

<h3 id="asl">ASL</h3>

<p>ASL是个啥？从官方手册上，或者从终端执行man 3 asl都可以看到说明：</p>

<blockquote>
  <p>These routines provide an interface to the Apple System Log facility. They are intended to be a replacement for the syslog(3) API, which will continue to be supported for backwards compatibility.</p>
</blockquote>

<p>大概就是个系统级别的log工具吧，syslog的替代版，提供了一系列强大的log功能。不过一般我们接触不到，NSLog就对它提供了高层次的封装，如这篇文档所提到的：</p>

<blockquote>
  <p>You can use two interfaces in OS X to log messages: ASL and Syslog. You can also use a number of higher-level approaches such as NSLog. However, because most daemons are not linked against Foundation or the Application Kit, the low-level APIs are often more appropriate</p>
</blockquote>

<p>一些底层相关的守护进程(deamons)不会link如Foundation等高层框架，所以asl用在这儿正合适；而对于应用层的用NSLog。</p>

<p>在CocoaLumberjack的文档中也说了NSLog效率低下的问题：</p>

<blockquote>
  <p>NSLog does 2 things:</p>
</blockquote>

<blockquote>
  <ul>
    <li>It writes log messages to the Apple System Logging (asl) facility. This allows log messages to show up in Console.app.</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>It also checks to see if the application’s stderr stream is going to a terminal (such as when the application is being run via Xcode). If so it writes the log message to stderr (so that it shows up in the Xcode console).</li>
  </ul>
</blockquote>

<blockquote>
  <p>To send a log message to the ASL facility, you basically open a client connection to the ASL daemon and send the message. BUT - each thread must use a separate client connection. So, to be thread safe, every time NSLog is called it opens a new asl client connection, sends the message, and then closes the connection.</p>
</blockquote>

<p>意识大概是说，NSLog会向ASL写log，同时向Terminal写log，而且同时会出现在Console.app中（Mac自带软件，用NSLog打出的log在其中全部可见）；不仅如此，每一次NSLog都会新建一个ASL client并向ASL守护进程发起连接，log之后再关闭连接。所以说，当这个过程出现N次时，消耗大量资源导致程序变慢也就不奇怪了。</p>

<h3 id="section-3">时间和进程信息</h3>

<p>主要原因已经找到，还有个值得注意的问题是NSLog每次会将当前的系统时间，进程和线程信息等作为前缀也打印出来，如：</p>

<pre><code>2012-34-56 12:34:56.789 XXXXXXXX[36818:303] xxxxxx
</code></pre>

<p>当然这些也可能是作为ASL的参数创建的，但不论如何，一定是有消耗的（虽然这个prefix十有八九不是我们需要的看到的）</p>

<h3 id="section-4">如何是好</h3>

<p>NSLog有这样的消耗问题，那该怎么办呢？</p>

<ol>
  <li>
    <p>拒绝残留的Log。现在项目都是多人共同开发，我们应该只把Log作为错误日志或者重要信息的日志使用，commit前请把自己调试的log去掉（尤其是在循环里写log的小伙伴，简直不能一起快乐的玩耍了）</p>
  </li>
  <li>
    <p>release版本中消除Log。debug归debug，再慢也不能波及到release版本，用预编译宏过滤下就好。</p>
  </li>
  <li>
    <p>是时候换个Log系统了，如CocoaLumberjack，自建一个简单的当然也挺好（其实为了项目需要自己也写了个小log系统，实现可以按名字和级别显示log和一些扩展功能，以后有机会分享下）</p>
  </li>
</ol>

<p>不过个人认为debug时最好还是用调试器进行调试（尤其是只需要知道某个变量值的时候）</p>

<h3 id="lldblog">尝试使用断点+lldb调试器打Log</h3>

<p>关于强大的lldb调试器用一个专题来讲都是应该，现在只了解一些皮毛，不过就算皮毛的功能也可以替代NSLog这种方法进行调试了，重要的一点是：使用断点log不需要重新编译工程，况且和Xcode已经结合的很好，在此先只说打Log这件事。</p>

<p>简单断点+po(p)</p>

<p>断点时可以在xcode的lldb调试区使用po或p命令打印对象或变量，对于当前栈帧中引用到的变量都是可见的，所以说假如只是看一眼某个对象运行到这儿是不是存在，是什么值的话，设个断点就够了，况且IDE已经把这个功能集成，鼠标放变量上就可以了。</p>

<p>lldb一些常用调试技巧可以这篇入门<a href="http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/">教程</a></p>

<p>Condition和Action断点</p>

<p>断点不止能把程序断住，触发时也按一定条件，而且可以执行（一个或多个）Action，在断点上右键选择Edit Breakpoint，弹出的断点设置中可以添加一些Action：</p>

<p><img src="http://www.cocoachina.com/cms/uploads/allimg/140530/8370_140530114340_1.jpg" alt="img" /></p>

<p>其中专门有一项就是Log Message，做个小测试：
for (int i = 0; i &lt; 10; i++) 
{ 
    // break point here 
} 
设置断点后编辑断点：</p>

<p>输入框下面就有支持的格式，表达式(或变量)可以使用@exp@这种格式包起来。于是乎输出：</p>

<pre><code>break at: 'main()',  count: 4, sunnyxx says : 3 
break at: 'main()',  count: 5, sunnyxx says : 4 
break at: 'main()',  count: 6, sunnyxx says : 5 
</code></pre>

<p>正如所料。更多的调试技巧还需要深入研究，不过可以肯定的是，比起单纯的使用NSLog，使用好的工具可以让我们debug的效率更高</p>

<h3 id="section-5">总结</h3>

<ol>
  <li>
    <p>NSLog耗费比较大的资源</p>
  </li>
  <li>
    <p>NSLog被设计为error log，是ASL的高层封装</p>
  </li>
  <li>
    <p>在项目中避免提交commit自己的Debug log，release版本更要注意去除NSLog，可以使用自建的log系统或好用的log系统来替代NSLog</p>
  </li>
</ol>

<p>4、debug不应只局限于log满天飞，lldb断点调试是一个优秀的debug方法，需要再深入研究下</p>

<h3 id="references">References</h3>

<p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html</a></p>

<p><a href="http://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/">http://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/</a></p>

<p><a href="https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance">https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance</a></p>

<p><a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1</a></p>

<p><a href="http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/">http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surge]]></title>
    <link href="http://helloyokoy.github.io/blog/surge/"/>
    <updated>2015-11-02T11:24:57+08:00</updated>
    <id>http://helloyokoy.github.io/blog/surge</id>
    <content type="html"><![CDATA[<p>iOS 9 有个激动人心的新特性 Network Extension 弥补了 iOS 长久以来无法定制底层网络 app 的不足。APN 代理不安全，成本高；虚拟专网速度不佳，爱掉线，阻塞问题严重…</p>

<p><img src="https://g.owind.com/content/images/2015/10/surgelogo.jpg" alt="alt text" title="surge" /></p>

<p>那么对于专业用户来说比较完美的方案必须是安全的，可低成本的，最大网络速度，无连接状态，国内外分流完美的 iOS 方案，那么现在这个堕落的愿望已经实现了，感谢苹果公司这么给(chi)力(dao)的 API 和 app 开发大牛。</p>

<p>Surge.app （App Store）是一款给专业用户使用的网络调试工具，使用比较复杂。它的工作原理是使用 packet tunnel provider，然后给系统套上一个代理，后端转发支持 http 代理，SSL 代理，和 Socks 代理。如果 app 尊重系统代理，就会走这个代理，如果不尊重，我们也可以通过规则强制流量走系统 tun 设备达到支持全部 app 的目的。用代理的好处是可以跟踪和调试网络，容易分流，ACL 功能更多，弹性更大更方便。</p>

<!--more-->

<p>简单的开始可以直接导入一份 conf 文件（URL 或者 iTunes），例如<a href="https://gist.github.com/janlay/b57476c72a93b7e622a6" title="link">这里</a>的，对于不求甚解的用户来说你可以直接使用完事（但是你还是要改改服务器地址用户名什么的。。或者直接从供应商处获取导入 URL）。</p>

<p>配置的结构大概是这样，对于专业用户来说，理解应该不难</p>

<p><figure class='code'><figcaption><span> (rules)</span> <a href='/downloads/code/rules'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'><span class="k">[General]</span>
</span><span class='line'><span class="c1"># warning, notify, info, verbose</span>
</span><span class='line'><span class="na">loglevel</span> <span class="o">=</span> <span class="s">notify</span>
</span><span class='line'>
</span><span class='line'><span class="k">[Proxy]</span>
</span><span class='line'><span class="c1"># http, https, socks5</span>
</span><span class='line'><span class="c1"># SSLedge 使用 https，老式 APNp 用 http</span>
</span><span class='line'><span class="na">Proxy</span> <span class="o">=</span> <span class="s">https, server, port, username, password, ciphers </span>
</span><span class='line'>
</span><span class='line'><span class="k">[Rule]</span>
</span><span class='line'><span class="c1"># 域名关键字，干掉不想要的请求</span>
</span><span class='line'><span class="err">DOMAIN-KEYWORD,umeng.co,REJECT</span>
</span><span class='line'><span class="err">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 常用网站优先匹配，加快速度。使用代理转发，完全没有 CDN 被干扰的问题~</span>
</span><span class='line'><span class="err">DOMAIN-SUFFIX,cn,DIRECT</span>
</span><span class='line'><span class="err">DOMAIN-SUFFIX,qq.com,DIRECT</span>
</span><span class='line'><span class="err">DOMAIN-SUFFIX,ls.apple.com,DIRECT</span>
</span><span class='line'><span class="err">DOMAIN-SUFFIX,apple.com,Proxy</span>
</span><span class='line'><span class="err">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 强制这些不尊重系统代理的请求走 packet-tunnel-provider，解决 Twitter.app 和 Mail.app 收发邮件问题</span>
</span><span class='line'><span class="err">DOMAIN-KEYWORD,twitter,Proxy,force-remote-dns</span>
</span><span class='line'><span class="err">DOMAIN-KEYWORD,gmail,Proxy,force-remote-dns</span>
</span><span class='line'><span class="c1"># instagram.app 也没问题</span>
</span><span class='line'><span class="err">DOMAIN-KEYWORD,instagram,Proxy,force-remote-dns</span>
</span><span class='line'><span class="c1"># Telegram.app 也没问题</span>
</span><span class='line'><span class="err">IP-CIDR,91.108.56.0/22,Proxy,force-remote-dns</span>
</span><span class='line'><span class="err">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># LAN</span>
</span><span class='line'><span class="err">IP-CIDR,192.168.0.0/16,DIRECT</span>
</span><span class='line'><span class="err">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 其余的请求使用 GEOIP 判断服务器所在地，如果是国内的，走直连，搞定</span>
</span><span class='line'><span class="err">GEOIP,CN,DIRECT</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 最后 Matchall，丢给代理</span>
</span><span class='line'><span class="err">FINAL,Proxy</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>通过规则定义和组合，必然可以满足专业用户的需求，非常强大。配置可以使用 app 自带的 GUI，当然也有文本编辑方式。</p>

<p>由于 Surge 的核心和是个 http proxy，有些处理不了的请求我们可以强制 bypass 掉，走系统接口，这个可以在代理设置-高级处设置，如果你不太懂，请不要随意设置。</p>

]]></content>
  </entry>
  
</feed>
