<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ios | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2017-04-28T22:33:21+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[swift 3.0]]></title>
    <link href="http://helloyokoy.github.io/blog/swift-3-dot-0/"/>
    <updated>2016-11-01T23:03:06+08:00</updated>
    <id>http://helloyokoy.github.io/blog/swift-3-dot-0</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/matteocrippa/awesome-swift">awesome-swift</a></p>

<p>其实这个系列的还有很多，极大的方便了开发者寻找自己需要的基础控件和工具。</p>

<p>本着记录和分享的态度，已下对本人觉得有必要深入了解，并可以使用在 swift 上的开源项目进行罗列。</p>

<p>Dollar</p>

<p>github 地址： Dollar</p>

<p>推荐理由：操作数组的神器</p>

<p>简介：正如推荐的中所说，Dollar 是一个用来处理数组的工具集。
Dollar 很强大，她优雅的为我们提供了解决数组，字典等对象的基本操作。比如将数组划分成若干个子集，如果我们自己动手做，那少不了for循环加各种判断。但使用 Dollar 一行代码就能搞定。具体接口可以去 github 上查阅。</p>

<p>主要包括以下中对象的操作</p>

<p>Array
Dictionary
Object
Function
Chaining</p>

<p>SwiftyJSON</p>

<p>github 地址：SwiftyJSON</p>

<p>推荐理由： 用过，因为是swift编写的所以性能和理解上不存在问题</p>

<p>简介：是一个使用简单的处理 json 格式数据的工具
详细的介绍和使用方法可参看 SwiftyJSON DOC 。这里多说一句，SwiftyJSON 的主要目的简化 JSON 数据的解析过程。但建模型的时候还是需要依次获取 JSON 里的数据赋值给模型。当 JSON 数据参数很多的时候，编写起来会费劲。所以推荐与 ObjectMapper 一起使用。</p>

<p>ObjectMapper</p>

<p>github 地址：ObjectMapper</p>

<p>推荐理由： 用过，很方便而且直观。只需要在 model 中引用 ObjectMapper 用法即可</p>

<p>简介：让数据模型的构造如此简单
可能你会有疑问，竟然 ObjectMapper 能将 jsonString 直接转换成 model 那为什么还要使用上面的 SwiftyJSON . 这是因为我们的 JSON 数据中并不是所有内容都是我们需要的，我们可以通过 SwiftyJSON 先获取我们需要的数据块，然后在通过 ObjectMapper 获取 model。</p>

<p>Alamofire</p>

<p>github 地址：Alamofire</p>

<p>推荐理由：用过，OC 上广为流传的网络请求框架 AFNetworking 已经有20000+的star，但对于 swift 开发，个人理解还是要用 swift 的框架的工具比较合适。并且她有多个扩展的工具集，配合使用功能还是很强大的。</p>

<p>简介：无</p>

<p>Alamofire 扩展</p>

<p>AlamofireImage – AlamofireImage is an image component library for Alamofire。（用过，使用简单，加载性能也还不错，只是没有深入了解其缓存数据的问题）
AlamofireNetworkActivityIndicator – Controls the visibility of the network activity indicator on iOS using Alamofire
AlamofireObjectMapper – An extension to Alamofire which automatically converts JSON response data into swift objects using ObjectMapper.(个人觉得不是很好用，除非网络返回的 JSON 数据格式单一，不需要任何截取操作)</p>

<p>DEMO：</p>

<p>// HttpManager.swift
// 使用Alamfire网络请求
// success: (json: JSON)-&gt;Void, errors: ()-&gt;Void 这两个闭包用来处理成功和错误的操作
// url：访问地址；parameters；参数
func requestForGetWithParameters(url: String, parameters params: [String:String], success: (json: JSON)-&gt;Void, errors: ()-&gt;Void) {</p>

<pre><code>    // 使用 Alamofire 进行网络数据请求
    Alamofire.request(.GET, url, parameters: params).responseJSON {response in
        switch response.result {
        case .Success:
            if let value = response.result.value {
                let json = JSON(value)
                NSLog("JSON: \(json["result"])")
                guard let result = json["result"].string where result == "SUCCESS" else {
                    errors()
                    return
                }
                success(json: json)
            }
            break
        case .Failure(let error):
            NSLog("error,failure: \(error)")
            errors()
            break
        }
    }
}
</code></pre>

<p>// ViewController.swift 
 // 获取JSON数据，截取需要的数据，生成model
 func onLoadMore() {
        HttpManager.sharedInstance.requestForGetWithPageIndex(
            URL_HOME_ONE,
            pageIndex: pageIndex,
            success: { json in
                // 这里很重要，是用来SwiftyJSON和ObjectMapper生成model
                let home = Mapper<Home>().map(json["hpEntity"].rawValue)
                self.apps.append(home!)
                HomePageViewCell.layoutHeight(home!) //计算cell内容高度
                self.pageIndex++
                self.htv!.tableView?.reloadData()
            },
            error: {
                ProgressHUD.showWarningWithStatus("没有更多内容可加载！")
                // 滑动tableview到最后一个cell
                self.htv!.tableView?.selectRowAtIndexPath(NSIndexPath(forRow: 9, inSection: 0), animated: false, scrollPosition: UITableViewScrollPosition.Bottom)
        })
    }
就此，网络获取的请求、json 数据处理，model生成就完成了。其实还是挺方便的。</Home></p>

<p>SnapKit</p>

<p>github 地址：SnapKit</p>

<p>简介：SnapKit is a DSL to make Auto Layout easy。
doc：http://snapkit.io/docs/</p>

<p>因为没有详细研究过，所以不好多说。只简单谈一谈对Auto Layout的理解。Auto Layout 是 Apple 专门用来配合 IB(Inerface Builder) 解决多拼适配问题的（这样说当然也有不合适的地方）。通过 IB 设置控件之间的约束，使控件在不同设备上相对距离和大小一致。然而不管是通过 IB 还是代码实现这些约束，都不是一件容易的事情。尤其代码实现，对经验不足的人来说，简直是地狱。SnapKit 则对代码实现约束做了封装，对布局的理解简单化，也更直观。
SnapKit 虽然是利器，但用不好就会变凶器。试想一下如果布局复杂，那用代码实现会很恐怖。看过很多blog后，我有新的理解。那就是对布局模块化，简单化。尽量使用 IB 进行布局，对复杂的布局可以尝试 Container View 进行分割。SnapKit 则是用来微调和解决大视图模块之间无法用 IB 产生约束的情况。</p>

<p>Demo：</p>

<p>import SnapKit</p>

<p>class MyViewController: UIViewController {</p>

<pre><code>lazy var box = UIView()

override func viewDidLoad() {
    super.viewDidLoad()

    self.view.addSubview(box)
    box.snp_makeConstraints { (make) -&gt; Void in
       make.width.height.equalTo(50)
       make.center.equalTo(self.view)
    }
} }
</code></pre>

<p>Kingfisher</p>

<p>github 地址：Kingfisher</p>

<p>介绍：A lightweight and pure Swift implemented library for downloading and caching image from the web. 值得注意的是，他有良好的 Cache management。她是借鉴 SDWebImage 这个由 OC 编写的10000+star 图片加载框架。
推荐理由：比AlamofireImage强大，有更好的 cache management 方案。
Kingfisher 和 AlamofireImag 该如何选择？其实这是一个仁者见仁智者见智的问题。但说到功能强大当然是首选 Kingfisher。如果是简单图片展示不需要对图片进行过多操作 和 cache ， AlamofireImage 也是能解决问题。</p>

<p>以下引用 Kingfisher Doc：</p>

<p>Features</p>

<p>Everything in Kingfisher is asynchronous, not only downloading, but also caching. That means you never need to worry about blocking your UI thread.
Multiple-layer cache. Downloaded images will be cached in both memory and disk. So there is no need to download again, this could boost your app’s perceptual speed dramatically.
Cache management. You can set the max duration or size the cache takes. From this, the cache will be cleaned automatically to prevent taking too many resources.
Modern framework. Kingfisher uses NSURLSession and the latest technology of GCD, which makes it a strong and swift framework. It also provides you easy APIs to use.
Cancelable processing task. You can cancel the downloading process if it is not needed anymore.
Prefetching. You can prefetch and cache the images which might soon appear in the page. It will bring your users great experience.
Independent components. You can use the downloader or caching system separately. Or even create your own cache based on Kingfisher’s code.
Options to decompress the image in background before rendering it, which could improve the UI performance.
Categories over UIImageView, NSImage and UIButton for setting image from an URL directly. Use the same code across all Apple platforms.
Support GIF seamlessly. You could just download and set your GIF images as the same as you do for PNG/JPEG format.
HanekeSwift
github 地址：HanekeSwift
简介：A lightweight generic cache for iOS written in Swift with extra love for images
DEMO:</p>

<p>let cache = Cache<JSON>(name: "github")
let URL = NSURL(string: "https://api.github.com/users/haneke")!</JSON></p>

<p>cache.fetch(URL: URL).onSuccess { JSON in
    print(JSON.dictionary?[“bio”])
}
以下引用 HanekeSwift DOC:</p>

<p>Generic cache with out-of-the-box support for UIImage, NSData, JSON and String
First-level memory cache using NSCache
Second-level LRU disk cache using the file system
Asynchronous fetching of original values from network or disk
All disk access is performed in background
Thread-safe
Automatic cache eviction on memory warnings or disk capacity reached
Comprehensive unit tests
Extensible by defining custom formats, supporting additional types or implementing custom fetchers
Zero-config UIImageView and UIButton extensions to use the cache, optimized for UITableView and UICollectionView cell reuse
Background image resizing and decompression
可能你会问，HanekeSwift 和 Kingfisher 都是简化异步处理网络数据和图片的那该如何选择它们呢？首先从 star 数上看 HanekeSwift 3000+， Kingfisher 4000+ 其实差不多，毕竟到这个数量级看的已经不止是 star 数量，更多的是项目的活跃度。Kingfisher 更专注于 image 的加载和缓存，而 HanekeSwift 对 UIImage、NSData、JSON、String 都提供了很好的支持。所以如果是对多种数据希望通过统一的解决方案进行缓存管理， HanekeSwift 貌似会更合适。相反对 image 有较高的缓存管理要求，Kingfisher 则会更推荐。</p>

<p>TransitionTreasury</p>

<p>github地址：TransitionTreasury</p>

<p>简介：A viewController transition framework in Swift。我是被她绚丽的切换方式和简单的使用方法而迷倒。</p>

<p>使用说明：详细 Wiki
ios ViewController 的切换可以通过代码实现，也可以通过在 IB 中给ViewController 链接 Segue 来实现。两种方式各有优劣，也是根据个人习惯和实际需要来选择。TransitionTreasury 是通过代码来管理 ViewController 的跳转，使用起来比较简单。</p>

<p>作者提供的例子：</p>

<p>/// FirstViewController.swift
class FirstViewController: UIViewController {</p>

<pre><code>func push() {
    let vc = SecondViewController()
    navigationController?.tr_pushViewController(vc, method: TRPushTransitionMethod.Fade, completion: {
            print("Push finish")
        })
} }
</code></pre>

<p>/// SecondViewController.swift
class SecondViewController: UIViewController, NavgationTransitionable {</p>

<pre><code>var tr_pushTransition: TRNavgationTransitionDelegate?

func pop() {
    tr_popViewController()
} } 而对于 IB 中链接 Segue 来控制跳转，被认为是推荐的方式。比较好的库有 IBAnimatable ，该库的作者推崇 IB 的使用，对绘制界面能少用代码尽量不用
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vapor 用swift写服务端]]></title>
    <link href="http://helloyokoy.github.io/blog/vapor-swift-server/"/>
    <updated>2016-10-09T15:43:38+08:00</updated>
    <id>http://helloyokoy.github.io/blog/vapor-swift-server</id>
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/1342803/15592871/46decfda-2375-11e6-9494-a9bf4e6aaebf.png" alt="vapor" /></p>

<p>自从苹果官方发布了一个 Swift 的 Linux 开源版本之后，服务端 Swift 终于迎来了一个令人激动的前景。我的好奇心终于无法克制，是时候尝试一下服务端 Swift 了！</p>

<p><a href="http://vapor.codes/">http://vapor.codes/</a></p>

<!--more-->

<p>官方教程如下</p>

<p><a href="https://vapor.github.io/documentation/getting-started/hello-world.html">https://vapor.github.io/documentation/getting-started/hello-world.html</a></p>

<p>GitHub</p>

<p><a href="https://github.com/vapor/vapor">https://github.com/vapor/vapor</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch 介绍]]></title>
    <link href="http://helloyokoy.github.io/blog/jspatch/"/>
    <updated>2016-06-12T18:30:02+08:00</updated>
    <id>http://helloyokoy.github.io/blog/jspatch</id>
    <content type="html"><![CDATA[<h3 id="jspatch">什么是 JSPatch？</h3>

<p>JSPatch 是一个开源项目(<a href="https://github.com/bang590/JSPatch">Github链接</a>)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。</p>

<!--more-->

<p>例如线上 APP 有一段代码出现 bug 导致 crash：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@implementation JPTableViewController
</span><span class='line'>…
</span><span class='line'>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>  NSString *content = self.dataSource[[indexPath row]];  //可能会超出数组范围导致crash
</span><span class='line'>  JPViewController *ctrl = [[JPViewController alloc] initWithContent:content];
</span><span class='line'>  [self.navigationController pushViewController:ctrl];
</span><span class='line'>}
</span><span class='line'>…
</span><span class='line'>@end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>可以通过下发这样一段 JS 代码，覆盖掉原方法，修复这个 bug：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//JS
</span><span class='line'>defineClass(“JPTableViewController”, {
</span><span class='line'>  //instance method definitions
</span><span class='line'>  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
</span><span class='line'>    var row = indexPath.row()
</span><span class='line'>    if (self.dataSource().length &gt; row) {  //加上判断越界的逻辑
</span><span class='line'>      var content = self.dataArr()[row];
</span><span class='line'>      var ctrl = JPViewController.alloc().initWithContent(content);
</span><span class='line'>      self.navigationController().pushViewController(ctrl);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}, {})&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>除了修复 bug，JSPatch 也可以用于动态运营，实时修改线上 APP 行为，或动态添加功能。JSPatch 详细使用文档见 Github Wiki。</p>

<h3 id="jspatch-">什么是 JSPatch 平台？</h3>

<p>JSPatch 需要使用者有一个后台可以下发和管理脚本，并且需要处理传输安全等部署工作，JSPatch 平台帮你做了这些事，提供了脚本后台托管，版本管理，保证传输安全等功能，让你无需搭建一个后台，无需关心部署操作，只需引入一个 SDK 即可立即使用 JSPatch。</p>

<h3 id="jspatch-sdk--github-">JSPatch SDK 与 github 上开源代码的关系？</h3>

<p>Github 开源的是 JSPatch 核心代码，使用完全免费自由，若打算自己搭建后台下发 JSPatch 脚本，可以直接使用 github 上的核心代码，与 JSPatch 平台上的 SDK 无关。JSPatch 平台的 SDK 在核心代码的基础上增加了向平台请求脚本/传输解密/版本管理等功能，只用于这个平台。</p>

<h3 id="jspatch--1">JSPatch 平台速度和稳定性如何？</h3>

<p>通过 JSPatch 平台上传的脚本文件都会保存在七牛云存储上，客户端 APP 只跟七牛服务器通讯，支持高并发，CDN分布全国，速度和稳定性有保证。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift开发库]]></title>
    <link href="http://helloyokoy.github.io/blog/swiftkai-fa-ku/"/>
    <updated>2016-06-05T18:50:01+08:00</updated>
    <id>http://helloyokoy.github.io/blog/swiftkai-fa-ku</id>
    <content type="html"><![CDATA[<ol>
  <li>CryptoSwift</li>
</ol>

<p>swift加密库, 支持md5,sha1,sha224,sha256…</p>

<p>github地址: <a href="https://github.com/krzyzanowskim/CryptoSwift">https://github.com/krzyzanowskim/CryptoSwift</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085348448948.jpg" alt="jpg" /></p>

<!--more-->

<ol>
  <li>Kingfisher</li>
</ol>

<p>Kingfisher 是一个异步下载和缓存图片的库 类似于SDWebImage</p>

<p>只不过它是纯Swift的实现</p>

<p>github地址：<a href="https://github.com/onevcat/Kingfisher">https://github.com/onevcat/Kingfisher</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085373992263.jpg" alt="jpg" /></p>

<ol>
  <li>PeekPop</li>
</ol>

<p>3DTouch动画组件</p>

<p>Peek和Pop是iPhone 6S和6S+上新增的一个很棒的iOS特性，可以很方便地使用3D touch来预览内容。</p>

<p>github地址：<a href="https://github.com/marmelroy/PeekPop">https://github.com/marmelroy/PeekPop</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085502558697.jpg" alt="jpg" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085641814017.gif" alt="jpg" /></p>

<ol>
  <li>AlamofireObjectMapper</li>
</ol>

<p>将Alamofire JSON响应数据 转为swift对象</p>

<p>github地址：<a href="https://github.com/tristanhimmelman/AlamofireObjectMapper">https://github.com/tristanhimmelman/AlamofireObjectMapper</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085537803735.jpg" alt="jpg" /></p>

<ol>
  <li>RxAlamofire</li>
</ol>

<p>为Alamofire提供 函数响应式（FRP）调用接口</p>

<p>以优雅的方式使用Alamofire进行网络请求</p>

<p>github地址：<a href="https://github.com/RxSwiftCommunity/RxAlamofire">https://github.com/RxSwiftCommunity/RxAlamofire</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085656633375.jpg" alt="jpg" /></p>

<ol>
  <li>PromiseKit</li>
</ol>

<p>异步编程类库 提供了很多实用的异步函数 让异步编程更简单</p>

<p>github地址：<a href="https://github.com/mxcl/PromiseKit">https://github.com/mxcl/PromiseKit</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085675411831.jpg" alt="jpg" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085698363881.jpg" alt="jpg" /></p>

<ol>
  <li>EZSwiftExtensions</li>
</ol>

<p>对Swift标准库， Foundation， UIKit 提供了很多高级扩展函数</p>

<p>包括以下内容：</p>

<p>NSObject</p>

<p>Bool</p>

<p>Int</p>

<p>Double</p>

<p>String</p>

<p>NSAttritedString</p>

<p>Array</p>

<p>Dictioanry</p>

<p>NSDate</p>

<p>NSTimer</p>

<p>CGRect</p>

<p>UIViewController</p>

<p>UIView</p>

<p>UITextView</p>

<p>UILabel</p>

<p>UIImageView</p>

<p>UIImage</p>

<p>Block Objects</p>

<p>UIDevice</p>

<p>NSUserDefauts</p>

<p>NSURL</p>

<p>EZ function and variables</p>

<p>github地址：<a href="https://github.com/goktugyil/EZSwiftExtensions">https://github.com/goktugyil/EZSwiftExtensions</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085719198231.jpg" alt="jpg" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085745420071.jpg" alt="jpg" /></p>

<ol>
  <li>Aspects</li>
</ol>

<p>swift面向切面编程（AOP）库 【Method Swizzling】</p>

<p>github地址：<a href="https://github.com/steipete/Aspects">https://github.com/steipete/Aspects</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085770599317.jpg" alt="jpg" /></p>

<ol>
  <li>PermissionScope</li>
</ol>

<p>权限管理库 提供申请权限授权操作</p>

<p>githubd地址：<a href="https://github.com/nickoneill/PermissionScope">https://github.com/nickoneill/PermissionScope</a></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085793901381.jpg" alt="" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160524/1464085821147167.gif" alt="" /></p>

<p>10、Alamofire</p>

<p>网络操作库 基本都知道</p>

<p>github地址：<a href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a></p>

<hr />
<p>转载自<a href="http://www.cocoachina.com/swift/20160525/16437.html">http://www.cocoachina.com/swift/20160525/16437.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PromiseKit: 同时支持Objective-C和Swift的Promise类库]]></title>
    <link href="http://helloyokoy.github.io/blog/promisekit/"/>
    <updated>2016-03-07T18:33:15+08:00</updated>
    <id>http://helloyokoy.github.io/blog/promisekit</id>
    <content type="html"><![CDATA[<p>现代开发需要高度异步，开发工具所提供的异步编程功能是否强大、方便而又令人愉悦？PromiseKit是一款贴心的iOS异步开发类库，更同时支持Objective-C和Swift的promises完整实现。</p>

<p><img src="http://img.blog.csdn.net/20160308094646006" alt="PromiseKit" /></p>

<!--more-->

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>UIApplication.sharedApplication().networkActivityIndicatorVisible = true&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>when(fetchImage(), getLocation()).then { image, location in
</span><span class='line'>    self.imageView.image = image;
</span><span class='line'>    self.label.text = “Buy your cat a house in (location)”
</span><span class='line'>}.always {
</span><span class='line'>    UIApplication.sharedApplication().networkActivityIndicatorVisible = false
</span><span class='line'>}.error { error in
</span><span class='line'>    UIAlertView(…).show()
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>PromiseKit有几个版本，其作者Max Howell在README中表示，如果你正在编写一个库，那么使用PromiseKit 1.6；如果正在开发一款App，那么PromiseKit 3则是最好的选择。</p>

<hr />
<p>GitHub地址：<a href="https://github.com/mxcl/PromiseKit">https://github.com/mxcl/PromiseKit</a></p>
]]></content>
  </entry>
  
</feed>
