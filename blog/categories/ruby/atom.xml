<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ruby | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2015-11-07T17:50:48+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails-perftest 分析 Rails 引用的性能]]></title>
    <link href="http://helloyokoy.github.io/blog/rails-perftest/"/>
    <updated>2015-11-07T15:04:49+08:00</updated>
    <id>http://helloyokoy.github.io/blog/rails-perftest</id>
    <content type="html"><![CDATA[<p>这个是 Rails 官方的 Gem，可以直接集成到 Rails 里面</p>

<p>你可以写 Benchmark 的测试用例:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>require ‘test_helper’
</span><span class='line'>require ‘rails/performance_test_help’&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class HomepageTest &lt; ActionDispatch::PerformanceTest
</span><span class='line'>  # Refer to the documentation for all available options
</span><span class='line'>  # self.profile_options = { runs: 5, metrics: [:wall_time, :memory],
</span><span class='line'>  #                          output: ‘tmp/performance’, formats: [:flat] }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>test “homepage” do
</span><span class='line'>    get ‘/’
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<!--more-->

<p>然后可以执行</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>$ rake test:benchmark
</span><span class='line'>HomepageTest#test_homepage (31 ms warmup)
</span><span class='line'>           wall_time: 6 ms
</span><span class='line'>              memory: 437.27 KB
</span><span class='line'>             objects: 5,514
</span><span class='line'>             gc_runs: 0
</span><span class='line'>             gc_time: 19 ms&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>你可以直接在命令行使用</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>$ perftest profiler ‘User.first’ –runs 3
</span><span class='line'>ProfilerTest#test_user_first (3 ms warmup)
</span><span class='line'>        process_time: 4 ms
</span><span class='line'>              memory: 289 Bytes
</span><span class='line'>             objects: 551&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>你还可以用 Helper 在 View, Controler, Model 里面打点统计</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="appcontrollerstopicscontrollerrb">app/controllers/topics_controller.rb&lt;/h1>
</span><span class='line'>&lt;p>class TopicsController &lt; ApplicationController
</span><span class='line'>  def index
</span><span class='line'>    benchmark(“  Benchmark: topics/index/suggest_topics”) do
</span><span class='line'>      @suggest_topics = Topic.without_hide_nodes.suggest.limit(3)
</span><span class='line'>    end
</span><span class='line'>    …
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Rails log 将会输出</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="developmentlog">development.log&lt;/h1>
</span><span class='line'>&lt;p>Started GET “/topics” for 127.0.0.1 at 2015-01-01 00:50:19 +0800
</span><span class='line'>  …
</span><span class='line'>  Benchmark:  topics/index/suggest_topics (1.4ms)
</span><span class='line'>  …
</span><span class='line'>Completed 200 OK in 121ms (Views: 108.1ms)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>还有更多功能待你发现哦!</p>

<hr />
<p><a href="https://github.com/rails/rails-perftest">https://github.com/rails/rails-perftest</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web开发cache]]></title>
    <link href="http://helloyokoy.github.io/blog/web-cache/"/>
    <updated>2015-11-04T16:55:48+08:00</updated>
    <id>http://helloyokoy.github.io/blog/web-cache</id>
    <content type="html"><![CDATA[<p>总结web应用中常用的各种cache</p>

<p>cache是提高应用性能重要的一个环节，写篇文章总结一下用过的各种对于动态内容的cache。
文章以Nginx，Rails，Mysql，Redis作为例子，换成其他web服务器，语言，数据库，缓存服务都是类似的。
以下是3层的示意图，方便后续引用：</p>

<pre><code>                      +-------+
1                     | Nginx |
                      +-+-+-+-+
                        | | |
        +---------------+ | +---------------+
        |                 |                 |
    +---+---+         +---+---+         +---+---+
2   |Unicorn|         |Unicorn|         |Unicorn|
    +---+---+         +---+---+         +---+---+
        |                 |                 |
        |                 |                 |
        |             +---+---+             |
3        +-------------+  D B  +-------------+
                      +-------+
</code></pre>

<!--more-->

<ol>
  <li>
    <h2 id="section">客户端缓存</h2>
  </li>
</ol>

<p>一个客户端经常会访问同一个资源，比如用浏览器访问网站首页或查看同一篇文章，或用app访问同一个api，如果该资源和他之前访问过的没有任何改变，就可以利用http规范中的304 Not Modified 响应头( http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 )，直接用客户端的缓存，而无需在服务器端再生成一次内容。
在Rails里面内置了fresh_when这个方法，一行代码就可以完成：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class ArticlesController
</span><span class='line'>  def show
</span><span class='line'>    @article = Article.find(params[:id])
</span><span class='line'>    fresh_when :last_modified =&gt; @article.updated_at.utc, :etag =&gt; @article
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>下次用户再访问的时候，会对比request header里面的If-Modified-Since和If-None-Match，如果相符合，就直接返回304，而不再生成response body。</p>

<p>但是这样会遇到一个问题，假设我们的网站导航有用户信息，一个用户在未登陆专题访问了一下，然后登陆以后再访问，会发现页面上显示的还是未登陆状态。或者在app访问一篇文章，做了一下收藏，下次再进入这篇文章，还是显示未收藏状态。解决这个问题的方法很简单，将用户相关的变量也加入到etag的计算里面：</p>

<pre><code>fresh_when :etag =&gt; [@article.cache_key, current_user.id]
fresh_when :etag =&gt; [@article.cache_key, current_user_favorited] 另外提一个坑，如果nginx开启了gzip，对rails执行的结果进行压缩，会将rails输出的etag header干掉，nginx的开发人员说根据rfc规范，对proxy_pass方式处理必须这样（因为内容改变了），但是我个人认为没这个必要，于是用了粗暴的方法，直接将src/http/modules/ngx_http_gzip_filter_module.c这个文件里面的这行代码注释掉，然后重新编译nginx：

//ngx_http_clear_etag(r); 或者你可以选择不改变nginx源代码，将gzip off掉，将压缩用Rack中间件来处理：

config.middleware.use Rack::Deflater 除了在controller里面指定fresh_when以外，rails框架默认使用Rack::ETag middleware，它会自动给无etag的response加上etag，但是和fresh_when相比，自动etag能够节省的只是客户端时间，服务器端还是一样会执行所有的代码，用curl来对比一下。 Rack::ETag自动加入etag：
</code></pre>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -v http://localhost:3000/articles/1
</span><span class='line'>&lt; Etag: “bf328447bcb2b8706193a50962035619”
</span><span class='line'>&lt; X-Runtime: 0.286958
</span><span class='line'>curl -v http://localhost:3000/articles/1 –header ‘If-None-Match: “bf328447bcb2b8706193a50962035619”’
</span><span class='line'>&lt; X-Runtime: 0.293798&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>用fresh_when：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>curl -v http://localhost:3000/articles/1 –header ‘If-None-Match: “bf328447bcb2b8706193a50962035619”’
</span><span class='line'>&lt; X-Runtime: 0.033884&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
  <li>
    <h2 id="nginx">Nginx缓存</h2>
  </li>
</ol>

<p>有一些资源可能会被调用很多，又无关用户状态，并且很少改变，比如新闻app上的列表api，购物网站上ajax请求分类菜单，可以考虑用Nginx来做缓存。
主要有2种实现方法：
####A. 动态请求静态文件化
在rails请求完成以后，将结果保存成静态文件，后续请求就会直接由nginx提供静态文件内容，用after_filter来实现一下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class CategoriesController &lt; ActionController::Base
</span><span class='line'>  after_filter :generate_static_file, :only =&gt; [:index]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def index
</span><span class='line'>    @categories = Category.all
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def generate_static_file
</span><span class='line'>    File.open(Rails.root.join(‘public’, ‘categories’), ‘w’) do |f|
</span><span class='line'>      f.write response.body
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>另外我们需要在任何分类更新的时候，删除掉这个文件，避免缓存不刷新的问题：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Category &lt; ActiveRecord::Base
</span><span class='line'>  after_save :delete_static_file
</span><span class='line'>  after_destroy :delete_static_file&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def delete_static_file
</span><span class='line'>    File.delete Rails.root.join(‘public’, ‘categories’)
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>Rails 4之前，处理这种生成静态文件缓存可以用内置的caches_page， rails 4之后变成了一个独立gem actionpack-page_caching，和手工代码对比一下，</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CategoriesController &lt; ActionController::Base
</span><span class='line'>  caches_page :index&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def update
</span><span class='line'>    #…
</span><span class='line'>    expire_page action: ‘index’
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>如果只有一台服务器，这个方法简单又实用，但是如果有多台服务器，就会出现更新分类只能刷新自己本身这台服务器缓存的问题，可以用nfs来共享静态资源目录解决，或者用第2种：</p>

<h4 id="b-">B. 静态化到集中缓存服务</h4>
<p>首先我们得让Nginx有直接访问缓存的能力：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>upstream redis {
</span><span class='line'>    server redis_server_ip:6379;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>upstream ruby_backend {
</span><span class='line'>    server unicorn_server_ip1 fail_timeout=0;
</span><span class='line'>    server unicorn_server_ip2 fail_timeout=0;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>location /categories {
</span><span class='line'>    set $redis_key $uri;
</span><span class='line'>    default_type   text/html;
</span><span class='line'>    redis_pass redis;
</span><span class='line'>    error_page 404 = @httpapp;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>location @httpapp {
</span><span class='line'>    proxy_pass http://ruby_backend;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Nginx首先会用请求的uri作为key去redis里面获取，如果获取不到（404）就转发给unicorn进行处理，然后改写generate_static_file和delete_static_file方法：</p>

<pre><code>redis_cache.set('categories', response.body)
  	
redis_cache.del('categories')
</code></pre>

<p>这样除了集中管理以外，还能够设置缓存的失效时间，对于一些更新无时效性要求的数据，就可以不用处理刷新机制，简单地固定时间刷新一次：</p>

<pre><code>redis_cache.setex('categories', 3.hours.to_i, response.body)
</code></pre>

<ol>
  <li>
    <h2 id="section-1">整页缓存</h2>
  </li>
</ol>

<p>Nginx缓存在处理带参数资源或者有用户状态的请求时候，就非常难以处理，这个时候可以用到整页缓存。
比如说分页请求列表，我们可以将page参数加入到cache_path：</p>

<pre><code>class CategoriesController
  	caches_action :index, :expires_in =&gt; 1.day, :cache_path =&gt; proc 	{"categories/index/#{params[:page].to_i}"}
end
</code></pre>

<p>比如说我们只需要针对rss输出进行缓存8小时：</p>

<pre><code>class ArticlesController
  	caches_action :index, :expires_in =&gt; 8.hours, :if =&gt; proc 	{request.format.rss?}
end 再比如说对于非登陆用户，我们可以缓存首页：

class HomeController
  	caches_action :index, :expires_in =&gt; 3.hours, :if =&gt; proc {!	user_signed_in?}
end
</code></pre>

<ol>
  <li>
    <h2 id="section-2">片段缓存</h2>
  </li>
</ol>

<p>如果说前面2种缓存能够用到的场景有限，那么片段缓存是适用性最广的。</p>

<h4 id="section-3">场景1：</h4>

<p>我们需要在每个页面一段广告代码，用来显示不同广告，如果没有使用片段缓存，那么每个页面都会要去查询广告的代码，并且花费一定时间去生成html代码：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class='line'>  div.ad
</span><span class='line'>    = advert.content</span></code></pre></td></tr></table></div></figure></p>

<p>加了片段缓存以后，就可以少去这个查询：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- cache “adverts/#{request.controller_name}/#{request.action_name}”, :expires_in =&gt; 1.day do
</span><span class='line'>  - if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class='line'>    div.ad
</span><span class='line'>      = advert.content&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-4">场景2：</h4>
<p>阅读文章，文章的内容可能比较长时间都不会改变，经常变化可能是文章评论，就可以对文章主体部分加上片段缓存：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache “articles/#{@article.id}/#{@article.updated_at.to_i}” do
</span><span class='line'>div.article
</span><span class='line'>  = @article.content.markdown2html&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>节约了生成markdown语法转换到html时间，这里用文章最后更新时间作为cache key的一部分，文章内容如果有改变，缓存自动失效，默认activerecord的cache_key方法也是用updated_at，你也可以加入更多的参数，比如article上有评论数的counter cache，更新评论数的时候不会更新文章时间，可以将这个counter也加入到key的一部分</p>

<h4 id="section-5">场景3：</h4>
<p>复杂页面结构的生成</p>

<p>数据结构比较复杂的页面，在生成的时候避免不了大量的查询和html渲染，用片段缓存，可以将这部分时间大大地节约，以我们网站游记页面 http://chanyouji.com/trips/109123 （请允许小小地打个广告，带点流量）来说：</p>

<p>需要获取天气数据，照片数据，文本数据等，同时还要生成meta，keyword等seo数据，而这些内容又是和其他动态内容交叉，片段缓存就可以分开多个：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache “trips/show/seo/#{@trip.fragment_cache_key}”, :expires_in =&gt; 1.day do
</span><span class='line'>title #{trip_name @trip}
</span><span class='line'>meta name=”description” content=”…”
</span><span class='line'>meta name=”keywords” content=”…”&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p>body
</span><span class='line'>  div
</span><span class='line'>    …
</span><span class='line'>- cache “trips/show/viewer/#{@trip.fragment_cache_key}”, :expires_in =&gt; 1.day do
</span><span class='line'>  - @trip.eager_load_all&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>小贴士，我在trip对象里面加了一个eager_load_all方法，缓存没有命中的时候，查询的时候避免出现n+1问题：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def eager_load_all
</span><span class='line'>    ActiveRecord::Associations::Preloader.new([self], {:trip_days =&gt; [:weather_station_data, :nodes =&gt; [:entry, :notes =&gt; [:photo, :video, :audio]]]}).run
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-6">小技巧1：带条件的片段缓存</h4>

<p>和caches_action不同，rails自带的片段缓存是不支持条件的，比如说我们想未登陆用户给他用片段缓存，而登陆用户不使用，写起来就很麻烦，我们可以改写一下helper就可以了：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def cache_if (condition, name = {}, cache_options = {}, &amp;block)
</span><span class='line'>    if condition
</span><span class='line'>      cache(name, cache_options, &amp;block)
</span><span class='line'>    else
</span><span class='line'>      yield
</span><span class='line'>    end
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache_if !user_signed_in?, “xxx”, :expires_in =&gt; 1.day do&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-7">小技巧2：关联对象的自动更新</h4>

<p>常使用对象update_at时间戳来作为cache key，可以在关联对象上加上touch选项，自动更新关联对象时间戳，比如我们可以在更新或者删除文章评论的时候，自动个更新：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Article
</span><span class='line'>  has_many :comments
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Comment
</span><span class='line'>  belongs_to :article, :touch =&gt; true
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
  <li>
    <h2 id="section-8">数据查询缓存</h2>
  </li>
</ol>

<p>通常来说web应用性能瓶颈都出现在DB IO上，做好数据查询缓存，减少数据库的查询次数，可以极大提高整体响应时间。
数据查询缓存分2种：</p>

<h4 id="a-">A. 同一个请求周期内的缓存</h4>

<p>举一个显示文章列表的例子，输出文章标题和文章类别，对应代码如下</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="controller">controller&lt;/h1>
</span><span class='line'>&lt;p>def index
</span><span class='line'>    @articles = Article.first(10)
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="view">view&lt;/h1>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>@articles.each do |article|
</span><span class='line'>h1 = article.name
</span><span class='line'>span = article.category.name&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>会发生10条类似的sql查询：</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` = ?
</code></pre>

<p>rails内置了query cache</p>

<p><a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb</a>，</p>

<p>在同一个请求周期内，如果没有update/delete/insert的操作，会对相同的sql查询进行缓存，如果文章类别都是相同的话，真正去查询数据库只会有1次。</p>

<p>如果文章类别都不一样，就会出现N+1查询问题（常见的性能瓶颈），rails推荐的解决方法是用Eager Loading Associations</p>

<p><a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>  	def index
</span><span class='line'>&lt;pre>&lt;code>	@articles = Article.includes(:category).first(10)
</span><span class='line'>  	end</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>查询语句会变成</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` in (?,?,?...)
</code></pre>

<h4 id="b--1">B. 跨请求周期的缓存</h4>

<p>同请求周期缓存所带来性能优化是很有限的，很多时候我们需要用跨请求周期的缓存，将一些常用的数据（比如User model）缓存，对于active record来说，利用统一的查询接口来fetch cache，利用callback来expire cache，就很容易实现，而且有一些现成的gem可以来用。</p>

<p>比如说 identity_cache</p>

<p><a href="https://github.com/Shopify/identity_cache">https://github.com/Shopify/identity_cache</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class User &lt; ActiveRecord::Base
</span><span class='line'>  include IdentityCache
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Article &lt; ActiveRecord::Base
</span><span class='line'>  include IdentityCache
</span><span class='line'>  cached_belongs_to :user
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="section-9">都会命中缓存&lt;/h1>
</span><span class='line'>&lt;p>User.fetch(1)
</span><span class='line'>Article.find(2).user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>这个gem的优点是代码实现简单，cache设置灵活，也方便扩展，缺点是需要用不同的查询方法名（fetch），以及额外的关系定义。</p>

<p>如果想在无数据缓存的应用无缝加入缓存功能，推荐@hooopo 做的second_level_cache</p>

<p><a href="https://github.com/hooopo/second_level_cache">https://github.com/hooopo/second_level_cache</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class User &lt; ActiveRecord::Base
</span><span class='line'>  acts_as_cached(:version =&gt; 1, :expires_in =&gt; 1.week)
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="find">还是使用find方法，就会命中缓存&lt;/h1>
</span><span class='line'>&lt;p>User.find(1)
</span><span class='line'>#无需额外用不一样的belongs_to定义
</span><span class='line'>Article.find(2).user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>实现原理是扩展了active record底层arel sql ast处理</p>

<p><a href="https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb">https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb</a></p>

<p>它的优点是无缝接入，缺点是扩展比较困难，对于只获取少量字段的查询无法缓存。</p>

<ol>
  <li>
    <h2 id="section-10">数据库缓存</h2>
  </li>
</ol>

<p>编辑中</p>

<p>这6种缓存，分布在客户端到服务器端不同的位置，所能够节约的时间也正好从多到少依次排列。</p>

<hr />
<p>转载自  <a href="https://ruby-china.org/topics/19389">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WeChat 开发环境搭建]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-develop-environment/"/>
    <updated>2015-10-29T15:46:09+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-develop-environment</id>
    <content type="html"><![CDATA[<p>由于微信开发都是在微信内浏览器运行，不管是登陆还是支付都不能在PC开发端愉快地玩耍，但世界我们还是需要拯救的。</p>

<p>由于自己换了新电脑，第一次做微信开发跟大家分享一下我的开发环境，欢迎拍砖交流。</p>

<p>一般的第三方开发永远离不开两个配置，域名 &amp; 回调，有一些平台支持localhost的域名&amp;回调会方便，更有支持随意更改端口的，微信上面貌似都没有 。</p>

<p>好了，假定我们的域名是playmonkey.me</p>

<h2 id="section">域名</h2>

<p>微信登陆，JSAPI以及支付都有域名限制，所以需要让手机微信上打开palymonkey.me时，访问到我们本地的development server。</p>

<p>干这个勾当的当属 Charles 神器。</p>

<!--more-->

<p>下载安装打开Charles
Proxy -&gt; Proxy Setting -&gt; Http Proxy勾选Enable…. 开启http proxy代理，端口默认是8888
Tool -&gt; DNS Spoofing Settings 勾选Enable DNS Spoofing
然后把palymonkey.me加到DNS Spoofs，指向本机127.0.0.1
Charles好了，下一步配置手机，确保你的手机网络和电脑在同一局域网，配置手机的HTTP代理到电脑的IP上，端口8888；</p>

<p>访问http://playmonkey.me；</p>

<p>什么？挂了？当然，酱紫访问的是本地的80端口。</p>

<p>好了，我们再来用 Nginx 反向代理搞定这个问题，让手机端的playmonkey.me访问到本地development server的3000端口上。</p>

<p>首先安装启动Nginx，用Apache的朋友对不起了，你们要自食其力XD</p>

<p>配置Nginx</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;server {</span>
</span><span class='line'><span class="sr">      listen 80;</span>
</span><span class='line'><span class="sr">      server_name playmonkey.me;</span>
</span><span class='line'><span class="sr">      charset utf-8;</span>
</span><span class='line'><span class="sr">      location /</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">proxy_pass</span>          <span class="ss">http</span><span class="p">:</span><span class="sr">//mon</span><span class="n">key_servers</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_redirect</span>      <span class="n">default</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Forwarded</span><span class="o">-</span><span class="no">For</span> <span class="vg">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Real</span><span class="o">-</span><span class="no">IP</span> <span class="vg">$remote_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="no">Host</span> <span class="vg">$http_host</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_next_upstream</span> <span class="n">http_502</span> <span class="n">http_504</span> <span class="n">error</span> <span class="n">timeout</span> <span class="n">invalid_header</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;  }</span>
</span><span class='line'>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">upstream palymonkey_servers{</span>
</span><span class='line'><span class="sr">  server 127.0.0.1:3000;</span>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>再用手机访问http://playmonkey.me ，Nice….这回看到页面了。
到此我们可以在微信上用playmonkey.me访问本地的dev server，可以愉快地调用JSAPI &amp; 微信oauth登陆 &amp; 发起支付。</p>

<p>噢，如果做的是PC端的oauth微博登录怎么办？ 在本地host加上 127.0.0.1 palymonkey.com。Nice XD、</p>

<h2 id="section-1">异步回调</h2>

<p>上面说到发起支付，微信的支付结果是通过异步回调的，所以需要做内网穿透，这里推荐两个工具 ngrok OR localtunnel</p>

<p>localtunnel</p>

<p>localtunnel 是node写的，用起来非常简单</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>npm install -g localtunnel
</span><span class='line'><span class="nv">$ </span>lt –port 3000
</span><span class='line'>your url is: https://gqgh.localtunnel.me&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>这样外网打开https://gqgh.localtunnel.me 就可以访问到本地的3000端口</p>

<p>但是localtunnel是国外的，公司网络刚刚搭好，经常不稳定果断抛弃转入ngrok；</p>

<p>ngrok（不想折腾的可以忽略XD）</p>

<p>悲催的是ngrok也是国外的，而且服务器给墙了，BUT，问题不大，我们可以pull ngrok 1.X的源码自己编译，2.0会报证书错误如果没有合法的https证书。</p>

<p>好了我们来编译ngrok，噢，对了，ngrok是Go写的，编译出来直接是一个可执行文件，爽歪歪有木有，哈~</p>

<p>在服务器端（每家都有一只staging服务器吧）</p>

<p>NGROK_DOMAIN 设置为您自己拥有的域名，并指向Ngrok server运行的服务器</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'>git clone https://github.com/inconshreveable/ngrok.git
</span><span class='line'><span class="nb">cd </span>ngrok&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;openssl genrsa -out rootCA.key 2048
</span><span class='line'>openssl req -x509 -new -nodes -key rootCA.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -days <span class="m">5000</span> -out rootCA.pem
</span><span class='line'>openssl genrsa -out device.key 2048
</span><span class='line'>openssl req -new -key device.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -out device.csr
</span><span class='line'>openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cp rootCA.pem assets/client/tls/ngrokroot.crt
</span><span class='line'><span class="c"># make clean</span>
</span><span class='line'>make release-server release-client&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>编译完有两个可执行文件 bin/ngrok &amp; bin/ngrokd 
将bin/ngrok copy到你本机
在服务器上开启ngrok server</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;bin/ngrokd -tlsKey<span class="o">=</span>device.key -tlsCrt<span class="o">=</span>device.crt -domain<span class="o">=</span>”<span class="nv">$NGROK_DOMAIN</span>” -httpAddr<span class="o">=</span>”:8000” -httpsAddr<span class="o">=</span>”:8001”&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>本地端</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'><span class="nb">echo</span> -e “server_addr: <span class="nv">$NGROK_DOMAIN</span>:4443<span class="se">\n</span>trust_host_root_certs: <span class="nb">false</span>” <span class="p">&amp;</span>gt<span class="p">;</span> ngrok-config
</span><span class='line'>./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span>playmonkey <span class="m">3000</span> // 配置subdomain到本地3000端口，这样外网通过playmonkey.NGROK_DOMAIN 就可以访问到本地dev server的3000端口&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>或者用SSH forwarding</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span><span class="m">3000</span> –proto<span class="o">=</span>tcp 22&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>以上Ngrok编译&amp;配置出自 <a href="https://gist.github.com/lyoshenka/002b7fbd801d0fd21f2f">How to setup Ngrok with a self-signed SSL cert</a></p>

<p>至此我们在发起微信支付时回调URL的HOST就可以设置为playmonkey.NGROK_DOMAIN</p>

<p>至此我们可以愉快地开发测试 微信的oauth登录 &amp; JSAPI &amp; 支付 &amp; 支付回调，好吧，很多BUG一点都不愉快。
另外感谢 <a href="https://ruby-china.org/ruby_sky">@ruby_sky</a> 的这篇 <a href="https://ruby-china.org/topics/26138">微信支付文章</a> 微信支付做起来如丝般顺滑；
内微信文档看起来太蛋疼了，各种配置也是找半天，大家有兴趣我可以总结一下微信各个开发的各种配置XD。</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/26443">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信开发 gems]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-gems/"/>
    <updated>2015-10-27T15:35:10+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-gems</id>
    <content type="html"><![CDATA[<p>最近陆续有不少用Rails开发微信项目的朋友在Github上开始使用weixin_rails_middleware、weixin_authorize，也不少人谈到Ratchet，春节开始到现在，一直有做微信的开发，现在在论坛上发布出来，希望让更多人知道这些gem的存在，更快速的完成你们手中的任务。</p>

<p>有问题可以前往：微信开发论坛：http://weixin-dev.com/</p>

<p>代码写得不好，还请多多包涵，如果有任何问题，可以直接联系我。:)</p>

<!--more-->

<h4 id="rails">1:一（两）条命令搭建Rails微信版本</h4>

<p>按照最简洁的速度，10分钟可以跑起一个微信的项目：
https://github.com/lanrion/weixin_rails_middleware</p>

<p>自动验证微信请求；
一（两）条命令，一个配置，简练风格；
支持Rails 3, Rails 4；
支持多公众账号平台，例如类似微盟；
支持单个用户，即一个账号，但又不想保存在数据库；
提供回复消息辅助方法；
提供所有微信消息类型的业务逻辑的回复处理；
wiki 中提供自定义菜单中的实现案例；
自动生成token；
详细见：</p>

<p>https://github.com/lanrion/weixin_rails_middleware/wiki/</p>

<p>wiki中也有不少关于开发上的建议与经验，还有自己遇到一些奇葩的问题</p>

<p>https://github.com/lanrion/weixin_rails_middleware</p>

<h4 id="api">2：微信高级API实现：</h4>

<p>https://github.com/lanrion/weixin_authorize</p>

<p>除 Oauth 2 未实现，其他API均已实现；
支持Redis存储access_token；
还是直接看wiki 吧：</p>

<p>https://github.com/lanrion/weixin_authorize/wiki/Getting-Started
wiki中也有不少关于开发上的建议与经验，还有自己遇到一些奇葩的问题</p>

<h4 id="ratchet-v201gem-twitterratchetrails">3：集成Ratchet v2.0.1的gem: twitter_ratchet_rails</h4>

<p>即：http://goratchet.com/ 压缩后非常小，十分适合wap使用，但有一个不足之处在于，组件不够丰富，期待更丰富的实现
没其他多余的好说，看官直接点击：</p>

<p>https://github.com/lanrion/twitter_ratchet_rails</p>

<p>小弟身材弱小，砖别拍的太猛，嘿，把我拍死了，就没人维护这三个gem了。:)</p>

<h4 id="section">4：例子（可能没有及时更新上最新版本）</h4>

<p>Rails 4: https://github.com/lanrion/weixin_rails_middleware_example</p>

<p>Rails 3: https://github.com/lanrion/weixin_rails_3</p>

<p>企业微信gem</p>

<p>请稳步： https://ruby-china.org/topics/22479</p>

<p>微信开发论坛：http://weixin-dev.com/</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/18439">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby gems内存泄露]]></title>
    <link href="http://helloyokoy.github.io/blog/ruby-gems-memory-leak/"/>
    <updated>2015-10-22T15:01:34+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ruby-gems-memory-leak</id>
    <content type="html"><![CDATA[<p>请大家检查下 Gemfile.lock，若在使用如下版本的gem包，那么请及时更新</p>

<ul>
  <li>
    <p>therubyracer &lt; 0.12.2</p>
  </li>
  <li>
    <p>sidekiq &lt; 3.5.1</p>
  </li>
  <li>
    <p>celluloid &gt; 0.16.0, &lt; 0.17.2</p>
  </li>
  <li>
    <p>zipruby &lt;= 0.3.6</p>
  </li>
  <li>
    <p>redcarpet &lt; 3.3.3</p>
  </li>
  <li>
    <p>grape &lt; 0.2.5</p>
  </li>
</ul>

<p><a href="https://github.com/ASoftCo/leaky-gems">https://github.com/ASoftCo/leaky-gems</a></p>
]]></content>
  </entry>
  
</feed>
