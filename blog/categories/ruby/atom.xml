<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ruby | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2015-11-04T20:23:42+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[web开发cache]]></title>
    <link href="http://helloyokoy.github.io/blog/web-cache/"/>
    <updated>2015-11-04T16:55:48+08:00</updated>
    <id>http://helloyokoy.github.io/blog/web-cache</id>
    <content type="html"><![CDATA[<p>总结web应用中常用的各种cache</p>

<p>cache是提高应用性能重要的一个环节，写篇文章总结一下用过的各种对于动态内容的cache。
文章以Nginx，Rails，Mysql，Redis作为例子，换成其他web服务器，语言，数据库，缓存服务都是类似的。
以下是3层的示意图，方便后续引用：</p>

<pre><code>                      +-------+
1                     | Nginx |
                      +-+-+-+-+
                        | | |
        +---------------+ | +---------------+
        |                 |                 |
    +---+---+         +---+---+         +---+---+
2   |Unicorn|         |Unicorn|         |Unicorn|
    +---+---+         +---+---+         +---+---+
        |                 |                 |
        |                 |                 |
        |             +---+---+             |
3        +-------------+  D B  +-------------+
                      +-------+
</code></pre>

<!--more-->

<ol>
  <li>
    <h2 id="section">客户端缓存</h2>
  </li>
</ol>

<p>一个客户端经常会访问同一个资源，比如用浏览器访问网站首页或查看同一篇文章，或用app访问同一个api，如果该资源和他之前访问过的没有任何改变，就可以利用http规范中的304 Not Modified 响应头( http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 )，直接用客户端的缓存，而无需在服务器端再生成一次内容。
在Rails里面内置了fresh_when这个方法，一行代码就可以完成：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class ArticlesController
</span><span class='line'>  def show
</span><span class='line'>    @article = Article.find(params[:id])
</span><span class='line'>    fresh_when :last_modified =&gt; @article.updated_at.utc, :etag =&gt; @article
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>下次用户再访问的时候，会对比request header里面的If-Modified-Since和If-None-Match，如果相符合，就直接返回304，而不再生成response body。</p>

<p>但是这样会遇到一个问题，假设我们的网站导航有用户信息，一个用户在未登陆专题访问了一下，然后登陆以后再访问，会发现页面上显示的还是未登陆状态。或者在app访问一篇文章，做了一下收藏，下次再进入这篇文章，还是显示未收藏状态。解决这个问题的方法很简单，将用户相关的变量也加入到etag的计算里面：</p>

<pre><code>fresh_when :etag =&gt; [@article.cache_key, current_user.id]
fresh_when :etag =&gt; [@article.cache_key, current_user_favorited] 另外提一个坑，如果nginx开启了gzip，对rails执行的结果进行压缩，会将rails输出的etag header干掉，nginx的开发人员说根据rfc规范，对proxy_pass方式处理必须这样（因为内容改变了），但是我个人认为没这个必要，于是用了粗暴的方法，直接将src/http/modules/ngx_http_gzip_filter_module.c这个文件里面的这行代码注释掉，然后重新编译nginx：

//ngx_http_clear_etag(r); 或者你可以选择不改变nginx源代码，将gzip off掉，将压缩用Rack中间件来处理：

config.middleware.use Rack::Deflater 除了在controller里面指定fresh_when以外，rails框架默认使用Rack::ETag middleware，它会自动给无etag的response加上etag，但是和fresh_when相比，自动etag能够节省的只是客户端时间，服务器端还是一样会执行所有的代码，用curl来对比一下。 Rack::ETag自动加入etag：
</code></pre>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -v http://localhost:3000/articles/1
</span><span class='line'>&lt; Etag: “bf328447bcb2b8706193a50962035619”
</span><span class='line'>&lt; X-Runtime: 0.286958
</span><span class='line'>curl -v http://localhost:3000/articles/1 –header ‘If-None-Match: “bf328447bcb2b8706193a50962035619”’
</span><span class='line'>&lt; X-Runtime: 0.293798&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>用fresh_when：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>curl -v http://localhost:3000/articles/1 –header ‘If-None-Match: “bf328447bcb2b8706193a50962035619”’
</span><span class='line'>&lt; X-Runtime: 0.033884&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
  <li>
    <h2 id="nginx">Nginx缓存</h2>
  </li>
</ol>

<p>有一些资源可能会被调用很多，又无关用户状态，并且很少改变，比如新闻app上的列表api，购物网站上ajax请求分类菜单，可以考虑用Nginx来做缓存。
主要有2种实现方法：
####A. 动态请求静态文件化
在rails请求完成以后，将结果保存成静态文件，后续请求就会直接由nginx提供静态文件内容，用after_filter来实现一下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class CategoriesController &lt; ActionController::Base
</span><span class='line'>  after_filter :generate_static_file, :only =&gt; [:index]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def index
</span><span class='line'>    @categories = Category.all
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def generate_static_file
</span><span class='line'>    File.open(Rails.root.join(‘public’, ‘categories’), ‘w’) do |f|
</span><span class='line'>      f.write response.body
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>另外我们需要在任何分类更新的时候，删除掉这个文件，避免缓存不刷新的问题：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Category &lt; ActiveRecord::Base
</span><span class='line'>  after_save :delete_static_file
</span><span class='line'>  after_destroy :delete_static_file&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def delete_static_file
</span><span class='line'>    File.delete Rails.root.join(‘public’, ‘categories’)
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>Rails 4之前，处理这种生成静态文件缓存可以用内置的caches_page， rails 4之后变成了一个独立gem actionpack-page_caching，和手工代码对比一下，</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CategoriesController &lt; ActionController::Base
</span><span class='line'>  caches_page :index&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def update
</span><span class='line'>    #…
</span><span class='line'>    expire_page action: ‘index’
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>如果只有一台服务器，这个方法简单又实用，但是如果有多台服务器，就会出现更新分类只能刷新自己本身这台服务器缓存的问题，可以用nfs来共享静态资源目录解决，或者用第2种：</p>

<h4 id="b-">B. 静态化到集中缓存服务</h4>
<p>首先我们得让Nginx有直接访问缓存的能力：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>upstream redis {
</span><span class='line'>    server redis_server_ip:6379;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>upstream ruby_backend {
</span><span class='line'>    server unicorn_server_ip1 fail_timeout=0;
</span><span class='line'>    server unicorn_server_ip2 fail_timeout=0;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>location /categories {
</span><span class='line'>    set $redis_key $uri;
</span><span class='line'>    default_type   text/html;
</span><span class='line'>    redis_pass redis;
</span><span class='line'>    error_page 404 = @httpapp;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>location @httpapp {
</span><span class='line'>    proxy_pass http://ruby_backend;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Nginx首先会用请求的uri作为key去redis里面获取，如果获取不到（404）就转发给unicorn进行处理，然后改写generate_static_file和delete_static_file方法：</p>

<pre><code>redis_cache.set('categories', response.body)
  	
redis_cache.del('categories')
</code></pre>

<p>这样除了集中管理以外，还能够设置缓存的失效时间，对于一些更新无时效性要求的数据，就可以不用处理刷新机制，简单地固定时间刷新一次：</p>

<pre><code>redis_cache.setex('categories', 3.hours.to_i, response.body)
</code></pre>

<ol>
  <li>
    <h2 id="section-1">整页缓存</h2>
  </li>
</ol>

<p>Nginx缓存在处理带参数资源或者有用户状态的请求时候，就非常难以处理，这个时候可以用到整页缓存。
比如说分页请求列表，我们可以将page参数加入到cache_path：</p>

<pre><code>class CategoriesController
  	caches_action :index, :expires_in =&gt; 1.day, :cache_path =&gt; proc 	{"categories/index/#{params[:page].to_i}"}
end
</code></pre>

<p>比如说我们只需要针对rss输出进行缓存8小时：</p>

<pre><code>class ArticlesController
  	caches_action :index, :expires_in =&gt; 8.hours, :if =&gt; proc 	{request.format.rss?}
end 再比如说对于非登陆用户，我们可以缓存首页：

class HomeController
  	caches_action :index, :expires_in =&gt; 3.hours, :if =&gt; proc {!	user_signed_in?}
end
</code></pre>

<ol>
  <li>
    <h2 id="section-2">片段缓存</h2>
  </li>
</ol>

<p>如果说前面2种缓存能够用到的场景有限，那么片段缓存是适用性最广的。</p>

<h4 id="section-3">场景1：</h4>

<p>我们需要在每个页面一段广告代码，用来显示不同广告，如果没有使用片段缓存，那么每个页面都会要去查询广告的代码，并且花费一定时间去生成html代码：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class='line'>  div.ad
</span><span class='line'>    = advert.content</span></code></pre></td></tr></table></div></figure></p>

<p>加了片段缓存以后，就可以少去这个查询：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- cache “adverts/#{request.controller_name}/#{request.action_name}”, :expires_in =&gt; 1.day do
</span><span class='line'>  - if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class='line'>    div.ad
</span><span class='line'>      = advert.content&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-4">场景2：</h4>
<p>阅读文章，文章的内容可能比较长时间都不会改变，经常变化可能是文章评论，就可以对文章主体部分加上片段缓存：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache “articles/#{@article.id}/#{@article.updated_at.to_i}” do
</span><span class='line'>div.article
</span><span class='line'>  = @article.content.markdown2html&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>节约了生成markdown语法转换到html时间，这里用文章最后更新时间作为cache key的一部分，文章内容如果有改变，缓存自动失效，默认activerecord的cache_key方法也是用updated_at，你也可以加入更多的参数，比如article上有评论数的counter cache，更新评论数的时候不会更新文章时间，可以将这个counter也加入到key的一部分</p>

<h4 id="section-5">场景3：</h4>
<p>复杂页面结构的生成</p>

<p>数据结构比较复杂的页面，在生成的时候避免不了大量的查询和html渲染，用片段缓存，可以将这部分时间大大地节约，以我们网站游记页面 http://chanyouji.com/trips/109123 （请允许小小地打个广告，带点流量）来说：</p>

<p>需要获取天气数据，照片数据，文本数据等，同时还要生成meta，keyword等seo数据，而这些内容又是和其他动态内容交叉，片段缓存就可以分开多个：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache “trips/show/seo/#{@trip.fragment_cache_key}”, :expires_in =&gt; 1.day do
</span><span class='line'>title #{trip_name @trip}
</span><span class='line'>meta name=”description” content=”…”
</span><span class='line'>meta name=”keywords” content=”…”&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p>body
</span><span class='line'>  div
</span><span class='line'>    …
</span><span class='line'>- cache “trips/show/viewer/#{@trip.fragment_cache_key}”, :expires_in =&gt; 1.day do
</span><span class='line'>  - @trip.eager_load_all&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>小贴士，我在trip对象里面加了一个eager_load_all方法，缓存没有命中的时候，查询的时候避免出现n+1问题：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def eager_load_all
</span><span class='line'>    ActiveRecord::Associations::Preloader.new([self], {:trip_days =&gt; [:weather_station_data, :nodes =&gt; [:entry, :notes =&gt; [:photo, :video, :audio]]]}).run
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-6">小技巧1：带条件的片段缓存</h4>

<p>和caches_action不同，rails自带的片段缓存是不支持条件的，比如说我们想未登陆用户给他用片段缓存，而登陆用户不使用，写起来就很麻烦，我们可以改写一下helper就可以了：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def cache_if (condition, name = {}, cache_options = {}, &amp;block)
</span><span class='line'>    if condition
</span><span class='line'>      cache(name, cache_options, &amp;block)
</span><span class='line'>    else
</span><span class='line'>      yield
</span><span class='line'>    end
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache_if !user_signed_in?, “xxx”, :expires_in =&gt; 1.day do&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-7">小技巧2：关联对象的自动更新</h4>

<p>常使用对象update_at时间戳来作为cache key，可以在关联对象上加上touch选项，自动更新关联对象时间戳，比如我们可以在更新或者删除文章评论的时候，自动个更新：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Article
</span><span class='line'>  has_many :comments
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Comment
</span><span class='line'>  belongs_to :article, :touch =&gt; true
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
  <li>
    <h2 id="section-8">数据查询缓存</h2>
  </li>
</ol>

<p>通常来说web应用性能瓶颈都出现在DB IO上，做好数据查询缓存，减少数据库的查询次数，可以极大提高整体响应时间。
数据查询缓存分2种：</p>

<h4 id="a-">A. 同一个请求周期内的缓存</h4>

<p>举一个显示文章列表的例子，输出文章标题和文章类别，对应代码如下</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="controller">controller&lt;/h1>
</span><span class='line'>&lt;p>def index
</span><span class='line'>    @articles = Article.first(10)
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="view">view&lt;/h1>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>@articles.each do |article|
</span><span class='line'>h1 = article.name
</span><span class='line'>span = article.category.name&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>会发生10条类似的sql查询：</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` = ?
</code></pre>

<p>rails内置了query cache</p>

<p><a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb</a>，</p>

<p>在同一个请求周期内，如果没有update/delete/insert的操作，会对相同的sql查询进行缓存，如果文章类别都是相同的话，真正去查询数据库只会有1次。</p>

<p>如果文章类别都不一样，就会出现N+1查询问题（常见的性能瓶颈），rails推荐的解决方法是用Eager Loading Associations</p>

<p><a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>  	def index
</span><span class='line'>&lt;pre>&lt;code>	@articles = Article.includes(:category).first(10)
</span><span class='line'>  	end</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>查询语句会变成</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` in (?,?,?...)
</code></pre>

<h4 id="b--1">B. 跨请求周期的缓存</h4>

<p>同请求周期缓存所带来性能优化是很有限的，很多时候我们需要用跨请求周期的缓存，将一些常用的数据（比如User model）缓存，对于active record来说，利用统一的查询接口来fetch cache，利用callback来expire cache，就很容易实现，而且有一些现成的gem可以来用。</p>

<p>比如说 identity_cache</p>

<p><a href="https://github.com/Shopify/identity_cache">https://github.com/Shopify/identity_cache</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class User &lt; ActiveRecord::Base
</span><span class='line'>  include IdentityCache
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Article &lt; ActiveRecord::Base
</span><span class='line'>  include IdentityCache
</span><span class='line'>  cached_belongs_to :user
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="section-9">都会命中缓存&lt;/h1>
</span><span class='line'>&lt;p>User.fetch(1)
</span><span class='line'>Article.find(2).user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>这个gem的优点是代码实现简单，cache设置灵活，也方便扩展，缺点是需要用不同的查询方法名（fetch），以及额外的关系定义。</p>

<p>如果想在无数据缓存的应用无缝加入缓存功能，推荐@hooopo 做的second_level_cache</p>

<p><a href="https://github.com/hooopo/second_level_cache">https://github.com/hooopo/second_level_cache</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class User &lt; ActiveRecord::Base
</span><span class='line'>  acts_as_cached(:version =&gt; 1, :expires_in =&gt; 1.week)
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="find">还是使用find方法，就会命中缓存&lt;/h1>
</span><span class='line'>&lt;p>User.find(1)
</span><span class='line'>#无需额外用不一样的belongs_to定义
</span><span class='line'>Article.find(2).user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>实现原理是扩展了active record底层arel sql ast处理</p>

<p><a href="https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb">https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb</a></p>

<p>它的优点是无缝接入，缺点是扩展比较困难，对于只获取少量字段的查询无法缓存。</p>

<ol>
  <li>
    <h2 id="section-10">数据库缓存</h2>
  </li>
</ol>

<p>编辑中</p>

<p>这6种缓存，分布在客户端到服务器端不同的位置，所能够节约的时间也正好从多到少依次排列。</p>

<hr />
<p>转载自  <a href="https://ruby-china.org/topics/19389">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为一个优秀的初级开发者]]></title>
    <link href="http://helloyokoy.github.io/blog/how-to-become-a-developer/"/>
    <updated>2015-11-04T16:49:15+08:00</updated>
    <id>http://helloyokoy.github.io/blog/how-to-become-a-developer</id>
    <content type="html"><![CDATA[<p>原文: <a href="http://blog.newrelic.com/2014/04/23/better-junior-developer/">http://blog.newrelic.com/2014/04/23/better-junior-developer/</a></p>

<p>翻译: <a href="https://ruby-china.org/mr_sun">@mr_sun</a></p>

<p>在过去的几年中，New Relic聘请了许多接受过各种编程培训的或者“非传统”编程背景的毕业生，其中就包括我！事实上，在我获得我的学士学位以后，我想要进入一所医药大学做进一步的学习，但是这时我获得了Google提供的一份技术支持的工作。在四年多以后我利用一个休假的时间出席了Hackbright Academy，这是个教女性学员如何编程的学校，课程安排为十周（现在延长到了十二周）。在第一周教学即将结束的时候，我知道我终于找到了我想要专注一生去追求的事业和方向。</p>

<p>不过，我的一个最大的忧虑是，我必须放弃我在其他领域已经积累起来的经验和技巧，去进入到一个全新的领域，在这个新领域里，我将面对的竞争对手都是拥有该领域几十年经验的资深工作者。幸运的是，在我真正进入到这样一个新角色以后，在共同工作的许多优秀的前辈的指导和帮助下，我总结出了一下一些自己的感悟：
- 不断地学习是成为一个优秀开发者的必备基石
- 有很多工程，是不是直接就开始写代码的</p>

<p>要清晰的认识到，即便作为一个还有很多东西要学的初级开发者，也有很多方法来利用我已经在其他领域已具备的技能。因为自己已经经历过那样一段对自己很不确定的时期，这里我想要向大家传播以下两条信息：
- 初级开发者：即使你还在学习关于编程的基本技巧，你也可以有很多方式为你的团队做出自己的贡献。
- mentor：因材施教，换位思考，让你的指导更加符合初级开发者的学习需要，这样将使他们更有自信，使你的指导更具效率。</p>

<!--more-->

<h2 id="section">有很多要学</h2>

<p>作为一个初级开发者，你将面临有太多东西要学的挑战，这时，重要的是不要试图所有东西都靠自己去解决，这里有三种方法可以采用：</p>

<ol>
  <li>
    <p>找到想要帮助你的人</p>

    <p>通过在你所在的团队或者结识其他编程团队，你可以扩展在你遇到问题时能为你提供帮助的网络人群。为了充分的利用网络资源，有一点很重要，就是面对一个问题，你需要先尽自己努力去探究，如此而不解，再去询问别人，这也是珍惜别人时间的一种表现。对于一个初级开发者，如果你在遇到问题时先自己做很多研究，那么你将会更快的学到更多的东西（这个过程中Google and StackOverflow将成为你的好朋友，为你提供很多的帮助）。这也会让你那些经验丰富的同事觉得他们对你的指导更有帮助，让他们更相信在下一次你遇到同样问题时你会充分利用他们给予你的建议和指导。</p>
  </li>
  <li>
    <p>让别人更容易帮助到你</p>

    <p>当你自己找不到合适的方式来描述你遇到的问题时，将更难于让别人理解你到底困惑在哪里。以下是一些我在遇到问题时喜欢使用的提问格式：</p>

    <p>我在尝试__<strong>，这样我就可以</strong>__</p>

    <p>我在____遇到了问题</p>

    <p>我已经查看了__<strong>并且试过了</strong>__</p>

    <p>举个例子，这是我最近一次用以上格式提问：“我试图要理解为什么这个账号登录时会出现这个banner，这样我就能告诉客户他们是否需要关注该警告。我在查看一个问题时找到了这个记录，我检查过了模型，并试图在本地将问题重现”。</p>
  </li>
  <li>
    <p>缩小你要学习的范围</p>

    <p>这就像在你解决一个棘手的技术问题时，你应该尽量将可能存在问题的范围缩小，以使的问题不至于过于繁杂。可能你想要弄明白的问题有太多太多，但是有经验的指导者可以告诉你哪些重要哪些不重要，给你分析这些问题的优先顺序（我的个人目标：真正自己独立的创建一个Rails App）。</p>
  </li>
</ol>

<h2 id="section-1">帮助你的团队</h2>

<p>作为一个初级开发者，你很自然会这样问自己：我本还需要这么多的帮助，又该怎样为我的团队贡献自己的力量呢？要记住，这世界上，开发的岗位永远要比开发人员多。所以并不需要在高效（高级开发人员）和低效（初级开发人员）做出选择，而是在于是否有相应的应用需要开发人员来做。记住以下这些策略将有助于反馈，调整你所写的代码</p>

<ol>
  <li>
    <p>提出好的问题</p>

    <p>我喜欢站在初级开发者的角度开考虑问题，提出好的问题，比如“我们是否在做一件正确的事？”这样可以帮助团队尽早发现错误的引导和假设。这样将避免在开发后期发现这些问题所将浪费大量的时间，所以要尽早提出好的问题。</p>
  </li>
  <li>
    <p>给出好的反馈</p>

    <p>将有用的反馈在合适的场合合适的时间给到正确的人，这对很对人来说并非易事。但是所有的公司都有其专门的反馈部门，因而即使初级开发者也有可能有机会获得大量参与反馈工作的机会。你也可以帮助预测来自于销售或者技术支持部门的关于产品新版本或产品更新的一些冲突。</p>
  </li>
  <li>
    <p>使你的团队面对其他团队表现的更好</p>

    <p>通过对你们所合作的团队投入更多的回应与热情，将使你的团队走的更远。有一种很好的方式来使你的团队在其他合作团队面前表现的更好，就是尽可能的向他们展示你们公司的产品特点。你可以有机会展示你的团队已经充分考虑了一些方面对其他团队的影响，比如可靠性。我几乎总是提前写好脚本并对整个流程作好足够的练习，以此来确保我的演示更加高效同时在演示过程中尽可能少的出错。</p>
  </li>
</ol>

<h2 id="section-2">指导者要怎样才能更好的帮助初级开发者</h2>

<p>以上的建议是专门针对初级开发者的，而对于导师来说，要更好的帮助初级开发者，使他们感觉到自己的价值和意识到自己为团队做出贡献的能力，也有很多事情可做。我很感兴趣于探讨如何让初级开发者的学习风格与有经验者的指导更好的磨合和匹配，以达到更好的效果。以此来保证每个人的时间都能被充分高效的利用，无论开发者还是指导者。举个例子，你可以探讨一个初级开发者希望以怎样的频率收到反馈和指示，以及高级开发者在什么时间什么情况下愿意被问题打断。</p>

<p>同时，作为一个高级开发者也就是mentor，如果你想让初级开发者在一个问题上自己思考更多以此来让他学习更多东西，那么你需要让他知道你的目的。这样是为了避免初级开发者出现过多不自信的消极情绪，因为他们会误以为他们所提出的是一个很简单的问题，但事实上尽管那本是个很复杂的问题，这种误解会让他们怀疑自己的能力，而变得不自信。</p>

<h2 id="section-3">结论</h2>

<p>一个初级开发者在第一份工作中就如同一张白纸。有许多机会可以通过共同工作的高级开发者的一些技术指导来使他们可以快速提升并且让他们感觉到从第一天工作就能创造价值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gemfile 详解]]></title>
    <link href="http://helloyokoy.github.io/blog/gem-description/"/>
    <updated>2015-11-03T16:05:02+08:00</updated>
    <id>http://helloyokoy.github.io/blog/gem-description</id>
    <content type="html"><![CDATA[<p>前几天读到的一篇博客，觉得内容很详实，就翻译了下给大家分享下。绝大部分为直译，极少数地方加了点自己的注释，若有不周到地方，还望大家指出。如果有排版方面的问题，也请指出。</p>

<p>原文：<a href="http://tosbourn.com/what-is-the-gemfile/">http://tosbourn.com/what-is-the-gemfile/</a></p>

<p>作为Ruby开发者，我们一直在使用Gemfile，并且大部分人知道一些关于Gemfile的基础知识。在这篇文章里，我想更加深入到Gemfile里面去看看通过Gemfile所能做的一切。</p>

<h2 id="gemfile">什么是Gemfile</h2>

<p>Gemfile是我们创建的一个用于描述gem之间依赖的文件。gem是一堆Ruby代码的集合，它能够为我们提供调用。你的Gemfile必须放在项目的根目录下面， 这是Bundler的要求，对于任何的其他形式的包管理文件来说，这也是标准。这里值得注意的一点是Gemfile会被作为Ruby代码来执行。当在Bundler上下文环境中被执行的时能使我们访问一些方法，我们用这些方法来解释gem之间的require关系。</p>

<!--more-->

<h2 id="gemfile-1">创建Gemfile</h2>

<p>首先我们要做的就是告诉Gemfile到那里去找到这些gems, 这就是gem的源。</p>

<p>我们使用#source方法来做这件事情</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source “https://rubygems.org”</span></code></pre></td></tr></table></div></figure></p>

<p>这里并不推荐一个项目有多个源。对于99%的项目，你的Gemfile的源都会被要求设置为https://rubygems.org，对于一个源，唯一的要求是它必须是一个合法的Rubygems的repo。</p>

<h2 id="section">源的优先级</h2>

<p>现在我们来探讨下关于gem源的优先级。
我们在Gemfile的顶部位置定义一个源的同时，我们也可以针对每个gem定义一个源。我们也能够为一个本地的gem定义一个路径或者是为gem定义一个git路径，比如说GitHub之类的（我们在后面点讲到这点）。</p>

<p>当Bundler尝试定位一个gem的时候，它会首先查看这个gem有没有显示的设置源，如果有，就先使用这个源。如果你在设置gem的时候有使用source, path或者git依赖的话，Bundler将会先在这些地方找，然后再去其他地方寻找。如果没有被显示设置的话， Bundler将会依照你Gemfile里面定义的源的顺序来找。如果一个gem能够在多个源里面被找到的话（虽然这是极为罕见的，因为你最好只定义一个源），你将会得到一个warning来提示你哪个源被使用了。</p>

<p>你能够使#source作为一个block来调用</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source “https://my_awesome_source.com” do
</span><span class='line'>   gem “my_gem”
</span><span class='line'>   gem “my_other_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="section-1">带验证的源</h2>

<p>有些源需要你使用验证才能够被设定。Bundler有一个设置选项使得你可以为每个源设置用户名和密码</p>

<pre><code>bundle config my_gem_source.com my_username:my_password
</code></pre>

<p>这是任何希望通过Bundler来安装gem都必须要的因为它不会被放入版本管理里面。你也可以直接在Gemfile中设置你的验证信息，当然，这些验证信息也会被commit进你的版本管理工具。如下所示</p>

<pre><code>source "https://username:password@my_gem_source.com" 你在源里面的设置，都会被你以bundle config的方式设置的东西所覆盖。
</code></pre>

<h2 id="ruby">设置Ruby信息</h2>

<p>如果你的应用程序需要使用一个特别的Ruby版本或是引擎，我们都能够在Gemfile里面进行设置。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby “1.9.3”, :patchlevel =&gt; “247”, :engine =&gt; “jruby”, :engine_version =&gt; “1.6.7”</span></code></pre></td></tr></table></div></figure></p>

<p>当设定这个的时候，需要的唯一点信息就是ruby的版本（我们这里使用1.9.3）
* :pathlevel 声明了Ruby的patch level
* :engine 声明了使用的Ruby引擎
* :engine_version 声明了引擎的版本 (如果这个被设置了，engine也需要被设置）</p>

<h2 id="gems">设置Gems</h2>

<p>现在我们到了Gemfile的核心，设置你的gems。最基本的语法如下：</p>

<pre><code>gem "my_gem"
</code></pre>

<p>这里my_gem是 gem的名字，gem的名字是唯一要求的参数，此外还有几个可以选择的参数可以使用。</p>

<h2 id="gem">设置Gem的版本</h2>

<p>对于一个gem，你最常做的事情就是设置它的版本，如果你不设置版本的话，你也可以说任意的版本都可以。</p>

<pre><code>gem "my_gem", "&gt;= 0.0"
</code></pre>

<p>这里有7个操作符供你用来设置你的gem</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>= Equal To “=1.0”&lt;/li>
</span><span class='line'>  &lt;li>!= Not Equal To “!=1.0”&lt;/li>
</span><span class='line'>  &lt;li>
</span><span class='line'>    &lt;blockquote>
</span><span class='line'>      &lt;p>Greater Than “&gt;1.0”&lt;/p>
</span><span class='line'>    &lt;/blockquote>
</span><span class='line'>  &lt;/li>
</span><span class='line'>  &lt;li>&lt; Less Than “&lt;1.0”&lt;/li>
</span><span class='line'>  &lt;li>
</span><span class='line'>    &lt;blockquote>
</span><span class='line'>      &lt;p>= Greater Than or Equal To “&gt;=1.0”&lt;/p>
</span><span class='line'>    &lt;/blockquote>
</span><span class='line'>  &lt;/li>
</span><span class='line'>  &lt;li>&lt;= Less Than or Equal To “&lt;=1.0”&lt;/li>
</span><span class='line'>  &lt;li>~&gt; Pessimistically Greater Than or Equal To “~&gt;1.0”&lt;/li>
</span><span class='line'>  &lt;li>~&gt; Pessimistically Greater Than or Equal To&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>~&gt; 操作能够让你使用这个gem的未来的某个安全的版本。如果你觉得使用一个大的版本更安全，你能够像下面这样声明.</p>

<pre><code>gem "my_gem", "~&gt; 2.0"
</code></pre>

<p>这能够允许你安装任意的2.x版本的gem，但是3.x版本是不被允许的。或许你对这么宽泛的版本感到不爽，你也可以声明一个更具体的版本，如下</p>

<pre><code>gem "my_gem", "~&gt; 2.5.0"
</code></pre>

<p>这能够让你使用2.5.0到2.6.0之间的版本。下面的例子能够让你更加理解~&gt; 操作符</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>gem “my_gem”, “~&gt; 1.0” –&gt; gem “my_gem”, “&gt;= 1.0”, “&lt; 2.0”&lt;/li>
</span><span class='line'>  &lt;li>gem “my_gem”, “~&gt; 1.5.0” –&gt; gem “my_gem”, “&gt;= 1.5.0”, “&lt; 1.6.0”&lt;/li>
</span><span class='line'>  &lt;li>gem “my_gem”, “~&gt; 1.5.5” –&gt; gem “my_gem”, “&gt;= 1.5.5”, “&lt; 1.6.0”</span></code></pre></td></tr></table></div></figure></li>
</ul>

<h2 id="gemrequired">设置gem被required</h2>

<p>如果你使用Rails的话，这点小技巧可能被隐藏了，但是在你的config/application.rb文件里面你能看到这么一行代码。</p>

<pre><code>Bundler.require(:default, Rails.env)
</code></pre>

<p>它的意思是require所有没有被放入group（后面会讲到这个概念）里面的gems和所有放入和当前rails环境（RAILS_ENV, development, test, production)同名的group里面的gems。</p>

<p>默认方式下，如果你在Gemfile里面包含一个gem，当Bundler.require被调用的时候会被包含进来。我们也能通过下面的设置让gem不被包含进来(译者注释：这样你就只能安装这个gem，在使用的时候必须在你的代码里手动的添加require ‘my_gem’来调用my_gem里面的方法了。为什么需要这样呢，因为并不是所有的地方都需要使用这个gem，比如你在rake task里面使用了my_gem, 而其他地方没有使用，故你只需要在这个gem require到task里面，避免了所有的进程都把这个gem加载进去）</p>

<pre><code>gem "my_gem", require: false
</code></pre>

<p>当然你也可以指定哪些文件夹被required的，如下：</p>

<pre><code>gem "my_gem", require: ["my_gem/specific_module/my_class", "my_gem"]
</code></pre>

<p>这点在当你的gem有很多功能的，你必须每次手动require的时候非常有用。</p>

<h2 id="gem-1">gem分组</h2>

<p>正如我上面提到的一样，一个gem可以属于一个或多个group，当它不属于任何group的时候，它被放入了:default group。
有两种方法你可以对一个gem分组。第一种是对group属性进行赋值，如下所示：</p>

<pre><code>gem "my_gem", group: :development
</code></pre>

<p>它的意思是，这个gem只在development环境下被require。这也意味着当你在安装gems的时候，你可以指定某个group下面的gems不被安装，这样在一定程度上能加快gem的安装。</p>

<pre><code>bundle install --without development test
</code></pre>

<p>上面的意思是安装除development和test group意外的所有gems。
第二种gem分组的方法就是你可以将gems放入一个block里面，如下所示：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>group :development do
</span><span class='line'>   gem “my_gem”
</span><span class='line'>   gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>这看上去更美观，并且你也可以设置多个group。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>group :development, :test do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>如果你想让某个group变成可选的形式，你也可以像下面这样，设置optional: true</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>group :development, optional: true do
</span><span class='line'>   gem “my_gem”
</span><span class='line'>   gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>当上面被设置时，为了安装development group下面的gems，需要运行bundle install —with development</p>

<h2 id="gem-2">设置gem的平台</h2>

<p>如果某个gem只能在某个平台上使用，你也可以在gemfile里面设置。平台的原理和group很类似，但不同的是你不需要去通过—without这样的option去指定，它会自动根据平台判断执行。</p>

<pre><code>gem "my_gem", platform: :jrubygem "my_other_gem", platform: [:ruby, :mri_18]
</code></pre>

<p>下面是一个不同平台的list。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>ruby – C Ruby (MRI) or Rubinius, but not Windows&lt;/li>
</span><span class='line'>  &lt;li>ruby_18 to ruby_22 – ruby &amp; (version 1.8 .. version 2.2)&lt;/li>
</span><span class='line'>  &lt;li>mri – Same as ruby, but not Rubinius&lt;/li>
</span><span class='line'>  &lt;li>mri_18 to mri_22 – mri &amp; (version 1.8 .. version 2.2)&lt;/li>
</span><span class='line'>  &lt;li>rbx – Same as ruby, but only Rubinius (not MRI)&lt;/li>
</span><span class='line'>  &lt;li>jruby – JRuby&lt;/li>
</span><span class='line'>  &lt;li>mswin – Windows&lt;/li>
</span><span class='line'>  &lt;li>mingw – Windows 32 bit mingw32 platform (aka RubyInstaller)&lt;/li>
</span><span class='line'>  &lt;li>mingw_18 to mingw_22 – mingw &amp; (version 1.8 .. version 2.2)&lt;/li>
</span><span class='line'>  &lt;li>x64_mingw – Windows 64 bit mingw32 platform&lt;/li>
</span><span class='line'>  &lt;li>x64_mingw_20 to x64_mingw_22 – x64_mingw &amp; (version 2.0 .. version 2.2)&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>我发现平台真的非常有用，当一个开发团队在不同平台开发的时候。当你team的一个开发者使用的是Windows平台的时候，你可能需要不同版本的gem来支持。我经常使用下面的block语法来使用platform设定。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>platforms :jruby do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="gem-3">设置gem的源</h2>

<p>ok，现在我们来讲设置gem的源，如下所示:</p>

<pre><code>gem "my_gem", source: "https://my_awesome_gemsite.com"
</code></pre>

<p>如果这个my_gem 在source里面找不到的话，Bundler也不会去default的源里面找，所以找不到的情况下这个gem就不会被安装。</p>

<h2 id="gitgem">从git安装gem</h2>

<p>你可以设置gem的安装源为一个git repo，比如GitHub, 这只需要你将source属性替换为git。你可以设置这个repo的链接为HTTP(S), SSH, GIT等协议，但最好使用HTTP(S)和SSH，因为其他的会使你可能成为man-in-the-middle攻击的受害者。如果你把gem放入到repo里面，你必须要在repo根目录文件夹下面有一个.gemspec 文件。这里面需要包含一个合法gem的声明。如果你没有提供这个文件，Bundler会尝试创建一个，但是他不会被依赖。如果你尝试去include一个没有提供.gemspec文件的git repo里面的gem，你必须指定一个版本号。</p>

<p>你可以为gem设置branch，tag，ref，默认是使用master branch。你也可以强制Bundler扩展submodule，通过以下方式来设置：</p>

<pre><code>gem "my_gem", git: "ssh@githib.com/tosbourn/my_gem", branch: test_branch, submodules: true
</code></pre>

<p>如果你有多个gem来自同一个git repo，你也可以通过下面block形式组织起来。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git “git@github.com:tosbourn/my_gems.git” do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="gitsource">设置Git作为source</h2>

<p>你可以设置一个URL来作为一个更广义的源，你可以通过调用#git_source方法并将name作为参数传进去，以及一个接收一个参数的block，并返回一个string作为repo的URL。如下所示：</p>

<pre><code>git_source(:custom_git){ |repo| "https://my_secret_git_repos.com/#{repo}.git" }
gem "my_gem", custom_git: "tosbourn/test_repo"
</code></pre>

<h2 id="bitbucketgithubhelper-method">BitBucket和Github的helper method</h2>

<p>因为BitBucket和Github都是比较流行的git repo host，所以有两者的helper method。在两者里面，Bundler都默认repo是public的。</p>

<pre><code>gem "my_gem", github: "tosbourn/my_gem" 
gem "my_gem", bitbucket: "tosbourn/my_gem"
</code></pre>

<p>你也可以设置两者的branch。当用户名和repo名字一致的时候，可以省略一个。</p>

<pre><code>gem "rails", github: "rails"
gem "rails", bitbucket: "rails"
</code></pre>

<p>注意：在Bundler 2出来之前，你不能使用:github这个参数，目前它是使用git://协议的，就是前面讲过的可能会受到man-in-the-middle攻击的。还有一个helper :gist, 如果你Github上是以gist的形式存放的话就能够使用它。你可以只使用gist ID作为path，也可以像:github, :bitbucket那样传入:branch参数。</p>

<pre><code>gem "my_gem", :gist =&gt; "5935162112", branch: "my_custom_branch"
</code></pre>

<h2 id="pathgem">用path包含本地Gem</h2>

<p>你可以通过传入:path参数来依赖你本地的gems。</p>

<pre><code>gem "my_gem", :path =&gt; "../my_path/my_gem"
</code></pre>

<p>如果你传入一个相对路径的话（如上），这个路径是相对于你Gemfile的路径的。如果你想把某个文件夹下所有的gems都包含进去的话，你可以使用如下的block。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>path “../my_path/gems” do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>有一点值得注意的是，如果你使用的是path的话，Bundler是不会编译c extension的。</p>

<h2 id="gems-1">选择性的安装gems</h2>

<p>有时候你想在某个前提条件被满足的情况下安装这个gem，比如你系统里面是否有某个程序。下面这个方法能够接收一个proc或lambda，下面的例子中我们将在你的系统是mac的时候安装这个gem</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>install_if -&gt; { RUBY_PLATFORM =~ /darwin/ } do
</span><span class='line'>   gem “my_osx_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="section-2">结束语</h2>

<p>谢谢你的阅读并希望它能对你有所帮助，如果我有什么遗漏或你有什么问题的话请联系我~</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/26655">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术学习态度]]></title>
    <link href="http://helloyokoy.github.io/blog/tech-learn/"/>
    <updated>2015-11-03T15:23:49+08:00</updated>
    <id>http://helloyokoy.github.io/blog/tech-learn</id>
    <content type="html"><![CDATA[<p>本文仅谈业余时间的技术学习，不谈工作中的要求。</p>

<p>技术固然要时时学习，因为更新快嘛，但对待技术上学什么，怎么花时间学，需要一个指导思想，否则浪费时间而且效果不好。</p>

<ol>
  <li>
    <p>抓住主干，而非细节
最近很火的一句话是“你不要用战术上的勤奋掩盖战略上的懒惰”。放到技术学习上就先主理解主干后关注枝叶，比如C++的好书很多，《Effective C++》和《Inside C++ Object Model》是好书，但它们都不是用来入门的，为什么? 因为它们不是主干，语言实现细节和各种坑你都了解了，碰到实际问题依然用不好C++。</p>
  </li>
  <li>
    <p>尽量不折腾
不去折腾那些不成熟的技术，尽量用较为成熟的技术。在一年多之前，我用AngularJS，MongoDB的时候把我可给坑惨了，所以我下决心如果不因为工作坚决不碰Go语言，Node.js，要学不如学Erlang。新技术应用场景不清晰，前景不清晰，生态环境弱，类库少，坑多不容易跳出来。简而言之就是风险大于收益。同理我也不喜欢用Linux而喜欢Mac，Vim的包也是别人弄好了直接install的。</p>
  </li>
</ol>

<!--more-->

<ol>
  <li>
    <p>尽量学习经典原理而不是浪费时间在细节上。
这一点条和第一点类似，多花时间学习抽象模式，设计原则，类型系统，看诸如《SICP》《The little schemer》《Essential of Programming Language》这种书，如果不是因为工作绝不浪费时间到《Dive into python》这种具体到语言细节的书上。</p>
  </li>
  <li>
    <p>尽量学习形而下的系统而不过多上升到形而上的思想上。上一点谈到了抽象模式和类型系统，但切不可单纯从思想上判断哪种语言一定好，哪种抽象模式就一定好，一定要结合形而下的系统综合看待，学习C语言就要随着OS学习，学习Lisp就随着编译器或分析器一起学习，学习Ruby或Python就跟着web开发来学习，通过某一类系统架构理解语言的优劣，通过语言来理解为何这么架构系统。</p>
  </li>
  <li>
    <p>学好那些通用技能。
比如：1，如何进行Debug，2，如何阅读源代码，3，如何进行基本性能监控，4，熟练用好自己的编辑器和*nix命令行，5，git技巧，6，项目管理能力，7，关系型数据库的知识。</p>
  </li>
</ol>

<hr />
<p>转载自 <a href="http://liusihao.com/post/64854832920/%E6%88%91%E5%AF%B9%E5%BE%85%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%81%E5%BA%A6">我对技术的态度</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wechat 开发环境搭建]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-develop-environment/"/>
    <updated>2015-10-29T15:46:09+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-develop-environment</id>
    <content type="html"><![CDATA[<p>由于微信开发都是在微信内浏览器运行，不管是登陆还是支付都不能在PC开发端愉快地玩耍，但世界我们还是需要拯救的。</p>

<p>由于自己换了新电脑，第一次做微信开发跟大家分享一下我的开发环境，欢迎拍砖交流。</p>

<p>一般的第三方开发永远离不开两个配置，域名 &amp; 回调，有一些平台支持localhost的域名&amp;回调会方便，更有支持随意更改端口的，微信上面貌似都没有 。</p>

<p>好了，假定我们的域名是playmonkey.me</p>

<h2 id="section">域名</h2>

<p>微信登陆，JSAPI以及支付都有域名限制，所以需要让手机微信上打开palymonkey.me时，访问到我们本地的development server。</p>

<p>干这个勾当的当属 Charles 神器。</p>

<!--more-->

<p>下载安装打开Charles
Proxy -&gt; Proxy Setting -&gt; Http Proxy勾选Enable…. 开启http proxy代理，端口默认是8888
Tool -&gt; DNS Spoofing Settings 勾选Enable DNS Spoofing
然后把palymonkey.me加到DNS Spoofs，指向本机127.0.0.1
Charles好了，下一步配置手机，确保你的手机网络和电脑在同一局域网，配置手机的HTTP代理到电脑的IP上，端口8888；</p>

<p>访问http://playmonkey.me；</p>

<p>什么？挂了？当然，酱紫访问的是本地的80端口。</p>

<p>好了，我们再来用 Nginx 反向代理搞定这个问题，让手机端的playmonkey.me访问到本地development server的3000端口上。</p>

<p>首先安装启动Nginx，用Apache的朋友对不起了，你们要自食其力XD</p>

<p>配置Nginx</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;server {</span>
</span><span class='line'><span class="sr">      listen 80;</span>
</span><span class='line'><span class="sr">      server_name playmonkey.me;</span>
</span><span class='line'><span class="sr">      charset utf-8;</span>
</span><span class='line'><span class="sr">      location /</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">proxy_pass</span>          <span class="ss">http</span><span class="p">:</span><span class="sr">//mon</span><span class="n">key_servers</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_redirect</span>      <span class="n">default</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Forwarded</span><span class="o">-</span><span class="no">For</span> <span class="vg">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Real</span><span class="o">-</span><span class="no">IP</span> <span class="vg">$remote_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="no">Host</span> <span class="vg">$http_host</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_next_upstream</span> <span class="n">http_502</span> <span class="n">http_504</span> <span class="n">error</span> <span class="n">timeout</span> <span class="n">invalid_header</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;  }</span>
</span><span class='line'>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">upstream palymonkey_servers{</span>
</span><span class='line'><span class="sr">  server 127.0.0.1:3000;</span>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>再用手机访问http://playmonkey.me ，Nice….这回看到页面了。
到此我们可以在微信上用playmonkey.me访问本地的dev server，可以愉快地调用JSAPI &amp; 微信oauth登陆 &amp; 发起支付。</p>

<p>噢，如果做的是PC端的oauth微博登录怎么办？ 在本地host加上 127.0.0.1 palymonkey.com。Nice XD、</p>

<h2 id="section-1">异步回调</h2>

<p>上面说到发起支付，微信的支付结果是通过异步回调的，所以需要做内网穿透，这里推荐两个工具 ngrok OR localtunnel</p>

<p>localtunnel</p>

<p>localtunnel 是node写的，用起来非常简单</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>npm install -g localtunnel
</span><span class='line'><span class="nv">$ </span>lt –port 3000
</span><span class='line'>your url is: https://gqgh.localtunnel.me&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>这样外网打开https://gqgh.localtunnel.me 就可以访问到本地的3000端口</p>

<p>但是localtunnel是国外的，公司网络刚刚搭好，经常不稳定果断抛弃转入ngrok；</p>

<p>ngrok（不想折腾的可以忽略XD）</p>

<p>悲催的是ngrok也是国外的，而且服务器给墙了，BUT，问题不大，我们可以pull ngrok 1.X的源码自己编译，2.0会报证书错误如果没有合法的https证书。</p>

<p>好了我们来编译ngrok，噢，对了，ngrok是Go写的，编译出来直接是一个可执行文件，爽歪歪有木有，哈~</p>

<p>在服务器端（每家都有一只staging服务器吧）</p>

<p>NGROK_DOMAIN 设置为您自己拥有的域名，并指向Ngrok server运行的服务器</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'>git clone https://github.com/inconshreveable/ngrok.git
</span><span class='line'><span class="nb">cd </span>ngrok&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;openssl genrsa -out rootCA.key 2048
</span><span class='line'>openssl req -x509 -new -nodes -key rootCA.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -days <span class="m">5000</span> -out rootCA.pem
</span><span class='line'>openssl genrsa -out device.key 2048
</span><span class='line'>openssl req -new -key device.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -out device.csr
</span><span class='line'>openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cp rootCA.pem assets/client/tls/ngrokroot.crt
</span><span class='line'><span class="c"># make clean</span>
</span><span class='line'>make release-server release-client&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>编译完有两个可执行文件 bin/ngrok &amp; bin/ngrokd 
将bin/ngrok copy到你本机
在服务器上开启ngrok server</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;bin/ngrokd -tlsKey<span class="o">=</span>device.key -tlsCrt<span class="o">=</span>device.crt -domain<span class="o">=</span>”<span class="nv">$NGROK_DOMAIN</span>” -httpAddr<span class="o">=</span>”:8000” -httpsAddr<span class="o">=</span>”:8001”&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>本地端</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'><span class="nb">echo</span> -e “server_addr: <span class="nv">$NGROK_DOMAIN</span>:4443<span class="se">\n</span>trust_host_root_certs: <span class="nb">false</span>” <span class="p">&amp;</span>gt<span class="p">;</span> ngrok-config
</span><span class='line'>./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span>playmonkey <span class="m">3000</span> // 配置subdomain到本地3000端口，这样外网通过playmonkey.NGROK_DOMAIN 就可以访问到本地dev server的3000端口&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>或者用SSH forwarding</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span><span class="m">3000</span> –proto<span class="o">=</span>tcp 22&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>以上Ngrok编译&amp;配置出自 <a href="https://gist.github.com/lyoshenka/002b7fbd801d0fd21f2f">How to setup Ngrok with a self-signed SSL cert</a></p>

<p>至此我们在发起微信支付时回调URL的HOST就可以设置为playmonkey.NGROK_DOMAIN</p>

<p>至此我们可以愉快地开发测试 微信的oauth登录 &amp; JSAPI &amp; 支付 &amp; 支付回调，好吧，很多BUG一点都不愉快。
另外感谢 <a href="https://ruby-china.org/ruby_sky">@ruby_sky</a> 的这篇 <a href="https://ruby-china.org/topics/26138">微信支付文章</a> 微信支付做起来如丝般顺滑；
内微信文档看起来太蛋疼了，各种配置也是找半天，大家有兴趣我可以总结一下微信各个开发的各种配置XD。</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/26443">ruby-china</a></p>
]]></content>
  </entry>
  
</feed>
