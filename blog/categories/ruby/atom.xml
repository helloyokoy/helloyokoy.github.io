<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ruby | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2018-01-22T17:52:43+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Grape 构建 RESTful API]]></title>
    <link href="http://helloyokoy.github.io/blog/grape-on-rails/"/>
    <updated>2015-12-04T11:32:56+08:00</updated>
    <id>http://helloyokoy.github.io/blog/grape-on-rails</id>
    <content type="html"><![CDATA[<p><img src="http://blog.lanvige.com/uploads/ruby/grape-logo.png" alt="img" /></p>

<p>Rails中构建API的方式有很多种，Grape因性能而被推荐，其可构建于任何Rack上，仍建议使用Rails作为载体，来构建Grape，会非常省心。</p>

<h3 id="section">安装配置</h3>

<p>首先确保安装：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2 id="platform">Platform&lt;/h2>
</span><span class='line'>&lt;p>gem ‘rails’, ‘4.2.0’&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h2 id="restful-api-engine">RESTful API Engine&lt;/h2>
</span><span class='line'>&lt;p>gem ‘grape’
</span><span class='line'>gem ‘grape-entity’&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h3 id="section-1">组织架构</h3>

<h4 id="section-2">目录结构</h4>

<pre><code>api
├── api.rb
└── v1
	├── base.rb
	├── entities
	│   ├── base.rb
	│   └── user_basic.rb
	├── helpers
	│   ├── page_helper.rb
	│   └── user_helper.rb
	├── base_api.rb
	└── users_api.rb
</code></pre>

<p>base.rb 中定义着API的版本、输出格式，及挂载更多API。
users_api.rb 就像controller，对每个resources都进行分开写，然后在base.rb中进行mount
entities 使用grape-entity，控制输出中的对象及格式。
helper 放置常用的helper，像分页，用户验证。</p>

<!--more-->

<p>entities/user_basic.rb</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>module V1
</span><span class='line'>  module Entities
</span><span class='line'>    class UserBasic &lt; Entities::Base
</span><span class='line'>      format_with(:iso8601) { |dt| dt.iso8601 }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>  expose :id
</span><span class='line'>  expose :name
</span><span class='line'>  # 如果需要输出层级对象，可以按这种方式
</span><span class='line'>  # expose :company, using: Entities::Company
</span><span class='line'>
</span><span class='line'>  # 日期、时间一律使用ISO 8601
</span><span class='line'>  expose :created_at, format_with: :iso8601
</span><span class='line'>
</span><span class='line'>  # with_options(format_with: :iso8601) do
</span><span class='line'>  #   expose :created_at
</span><span class='line'>  # end
</span><span class='line'>end   end end
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>base.rb</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>module V1
</span><span class='line'>  class Base &lt; Grape::API
</span><span class='line'>    version      ‘v1’
</span><span class='line'>    format       :json&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code># Mount the APIs
</span><span class='line'>mount UsersApi   end end
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-3">挂载</h4>

<p>routes.rb</p>

<pre><code>mount V1::API =&gt; '/'
</code></pre>

<h4 id="section-4">测试</h4>

<p><a href="http://localhost:3000/v1/users">http://localhost:3000/v1/users</a></p>

<h3 id="best-practices">Best Practices</h3>
<p><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">Best Practices for Designing a Pragmatic RESTful API Vinay Sahni</a></p>

<p><a href="http://www.restapitutorial.com/">A RESTful Tutorial</a></p>

<p>非常推荐 Vinay Sahni的实践，说明的非常清晰，而 RESTful Tutorial 也是推荐，但Wrapper一节不作推荐。</p>

<h3 id="doc-with-swagger-ui">Doc with Swagger UI</h3>

<h4 id="grape-swagger">grape-swagger</h4>

<p>routes.rb</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>gem ‘grape-swagger’
</span><span class='line'>routes.rb&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>add_swagger_documentation
</span><span class='line'>./config/initializers/swagger.rb&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>GrapeSwaggerRails.options.url      = ‘/swagger_doc.json’
</span><span class='line'>GrapeSwaggerRails.options.app_url  = ‘http://swagger.wordnik.com’&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p><a href="http://localhost:3000/swagger_doc.json">http://localhost:3000/swagger_doc.json</a></p>

<h4 id="grapeswaggerrails">GrapeSwaggerRails</h4>

<p>./config/initializers/swagger.rb</p>

<pre><code>gem 'grape-swagger-rails' ./config/initializers/swagger.rb

mount GrapeSwaggerRails::Engine +&gt; '/docs'
</code></pre>

<h3 id="section-5">分页</h3>

<p>类库有will_paginate和<a href="https://github.com/amatsuda/kaminari">Kaminari</a>，示例中选后者。</p>

<p>和Grape结合部分，使用 <a href="https://github.com/davidcelis/api-pagination#grape">api-pagination</a>。</p>

<p>测试：</p>

<p><a href="http://localhost:3000/v1/users?page=2&amp;per_page=2">http://localhost:3000/v1/users?page=2&amp;per_page=2</a></p>

<p>分页有很多种定义方式，建议采用RFC-5988  中所定义。（如上链接）</p>

<h3 id="jsend">JSend</h3>

<p><a href="http://labs.omniti.com/labs/jsend">http://labs.omniti.com/labs/jsend</a></p>

<p>RESTful Tutorial 中推荐过JSend，而之前项目中也使用了类似的格式，就是在数据源外包一层，并加上其它的一些信息，像code, status, message。</p>

<p>这些信息主要是应用于JSONP。<a href="https://github.com/bolasblack/http-api-guide#json-p">建议用该方式</a>：，或者是一些无法获取或处理HTTP Header的JS类库。</p>

<h3 id="partial-response">Partial Response</h3>

<p>Grape中实现参见该文：<a href="http://www.nicolasgarnil.me/blog/2013/crafting-ruby-grape-apis-partial-response-part1/">Crafting Ruby Grape APIs: Partial Response</a></p>

<h3 id="error-">Error 处理</h3>

<p>REF::</p>

<p><a href="https://github.com/bolasblack/http-api-guide">HTTP 接口设计指北</a></p>

<hr />

<p>转载自 <a href="http://blog.lanvige.com/2015/01/13/build-restful-api-with-grape/?utm_source=tuicool&amp;utm_medium=referral">http://blog.lanvige.com/2015/01/13/build-restful-api-with-grape/?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails-perftest 分析 Rails 引用的性能]]></title>
    <link href="http://helloyokoy.github.io/blog/rails-perftest/"/>
    <updated>2015-11-07T15:04:49+08:00</updated>
    <id>http://helloyokoy.github.io/blog/rails-perftest</id>
    <content type="html"><![CDATA[<p>这个是 Rails 官方的 Gem，可以直接集成到 Rails 里面</p>

<p>你可以写 Benchmark 的测试用例:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>require ‘test_helper’
</span><span class='line'>require ‘rails/performance_test_help’&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class HomepageTest &lt; ActionDispatch::PerformanceTest
</span><span class='line'>  # Refer to the documentation for all available options
</span><span class='line'>  # self.profile_options = { runs: 5, metrics: [:wall_time, :memory],
</span><span class='line'>  #                          output: ‘tmp/performance’, formats: [:flat] }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>test “homepage” do
</span><span class='line'>    get ‘/’
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<!--more-->

<p>然后可以执行</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>$ rake test:benchmark
</span><span class='line'>HomepageTest#test_homepage (31 ms warmup)
</span><span class='line'>           wall_time: 6 ms
</span><span class='line'>              memory: 437.27 KB
</span><span class='line'>             objects: 5,514
</span><span class='line'>             gc_runs: 0
</span><span class='line'>             gc_time: 19 ms&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>你可以直接在命令行使用</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>$ perftest profiler ‘User.first’ –runs 3
</span><span class='line'>ProfilerTest#test_user_first (3 ms warmup)
</span><span class='line'>        process_time: 4 ms
</span><span class='line'>              memory: 289 Bytes
</span><span class='line'>             objects: 551&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>你还可以用 Helper 在 View, Controler, Model 里面打点统计</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="appcontrollerstopicscontrollerrb">app/controllers/topics_controller.rb&lt;/h1>
</span><span class='line'>&lt;p>class TopicsController &lt; ApplicationController
</span><span class='line'>  def index
</span><span class='line'>    benchmark(“  Benchmark: topics/index/suggest_topics”) do
</span><span class='line'>      @suggest_topics = Topic.without_hide_nodes.suggest.limit(3)
</span><span class='line'>    end
</span><span class='line'>    …
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Rails log 将会输出</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="developmentlog">development.log&lt;/h1>
</span><span class='line'>&lt;p>Started GET “/topics” for 127.0.0.1 at 2015-01-01 00:50:19 +0800
</span><span class='line'>  …
</span><span class='line'>  Benchmark:  topics/index/suggest_topics (1.4ms)
</span><span class='line'>  …
</span><span class='line'>Completed 200 OK in 121ms (Views: 108.1ms)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>还有更多功能待你发现哦!</p>

<hr />
<p><a href="https://github.com/rails/rails-perftest">https://github.com/rails/rails-perftest</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web开发cache]]></title>
    <link href="http://helloyokoy.github.io/blog/web-cache/"/>
    <updated>2015-11-04T16:55:48+08:00</updated>
    <id>http://helloyokoy.github.io/blog/web-cache</id>
    <content type="html"><![CDATA[<p>总结web应用中常用的各种cache</p>

<p>cache是提高应用性能重要的一个环节，写篇文章总结一下用过的各种对于动态内容的cache。
文章以Nginx，Rails，Mysql，Redis作为例子，换成其他web服务器，语言，数据库，缓存服务都是类似的。
以下是3层的示意图，方便后续引用：</p>

<pre><code>                      +-------+
1                     | Nginx |
                      +-+-+-+-+
                        | | |
        +---------------+ | +---------------+
        |                 |                 |
    +---+---+         +---+---+         +---+---+
2   |Unicorn|         |Unicorn|         |Unicorn|
    +---+---+         +---+---+         +---+---+
        |                 |                 |
        |                 |                 |
        |             +---+---+             |
3        +-------------+  D B  +-------------+
                      +-------+
</code></pre>

<!--more-->

<ol>
  <li>
    <h2 id="section">客户端缓存</h2>
  </li>
</ol>

<p>一个客户端经常会访问同一个资源，比如用浏览器访问网站首页或查看同一篇文章，或用app访问同一个api，如果该资源和他之前访问过的没有任何改变，就可以利用http规范中的304 Not Modified 响应头( http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 )，直接用客户端的缓存，而无需在服务器端再生成一次内容。
在Rails里面内置了fresh_when这个方法，一行代码就可以完成：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class ArticlesController
</span><span class='line'>  def show
</span><span class='line'>    @article = Article.find(params[:id])
</span><span class='line'>    fresh_when :last_modified =&gt; @article.updated_at.utc, :etag =&gt; @article
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>下次用户再访问的时候，会对比request header里面的If-Modified-Since和If-None-Match，如果相符合，就直接返回304，而不再生成response body。</p>

<p>但是这样会遇到一个问题，假设我们的网站导航有用户信息，一个用户在未登陆专题访问了一下，然后登陆以后再访问，会发现页面上显示的还是未登陆状态。或者在app访问一篇文章，做了一下收藏，下次再进入这篇文章，还是显示未收藏状态。解决这个问题的方法很简单，将用户相关的变量也加入到etag的计算里面：</p>

<pre><code>fresh_when :etag =&gt; [@article.cache_key, current_user.id]
fresh_when :etag =&gt; [@article.cache_key, current_user_favorited] 另外提一个坑，如果nginx开启了gzip，对rails执行的结果进行压缩，会将rails输出的etag header干掉，nginx的开发人员说根据rfc规范，对proxy_pass方式处理必须这样（因为内容改变了），但是我个人认为没这个必要，于是用了粗暴的方法，直接将src/http/modules/ngx_http_gzip_filter_module.c这个文件里面的这行代码注释掉，然后重新编译nginx：

//ngx_http_clear_etag(r); 或者你可以选择不改变nginx源代码，将gzip off掉，将压缩用Rack中间件来处理：

config.middleware.use Rack::Deflater 除了在controller里面指定fresh_when以外，rails框架默认使用Rack::ETag middleware，它会自动给无etag的response加上etag，但是和fresh_when相比，自动etag能够节省的只是客户端时间，服务器端还是一样会执行所有的代码，用curl来对比一下。 Rack::ETag自动加入etag：
</code></pre>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -v http://localhost:3000/articles/1
</span><span class='line'>&lt; Etag: “bf328447bcb2b8706193a50962035619”
</span><span class='line'>&lt; X-Runtime: 0.286958
</span><span class='line'>curl -v http://localhost:3000/articles/1 –header ‘If-None-Match: “bf328447bcb2b8706193a50962035619”’
</span><span class='line'>&lt; X-Runtime: 0.293798&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>用fresh_when：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>curl -v http://localhost:3000/articles/1 –header ‘If-None-Match: “bf328447bcb2b8706193a50962035619”’
</span><span class='line'>&lt; X-Runtime: 0.033884&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
  <li>
    <h2 id="nginx">Nginx缓存</h2>
  </li>
</ol>

<p>有一些资源可能会被调用很多，又无关用户状态，并且很少改变，比如新闻app上的列表api，购物网站上ajax请求分类菜单，可以考虑用Nginx来做缓存。
主要有2种实现方法：
####A. 动态请求静态文件化
在rails请求完成以后，将结果保存成静态文件，后续请求就会直接由nginx提供静态文件内容，用after_filter来实现一下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class CategoriesController &lt; ActionController::Base
</span><span class='line'>  after_filter :generate_static_file, :only =&gt; [:index]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def index
</span><span class='line'>    @categories = Category.all
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def generate_static_file
</span><span class='line'>    File.open(Rails.root.join(‘public’, ‘categories’), ‘w’) do |f|
</span><span class='line'>      f.write response.body
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>另外我们需要在任何分类更新的时候，删除掉这个文件，避免缓存不刷新的问题：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Category &lt; ActiveRecord::Base
</span><span class='line'>  after_save :delete_static_file
</span><span class='line'>  after_destroy :delete_static_file&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def delete_static_file
</span><span class='line'>    File.delete Rails.root.join(‘public’, ‘categories’)
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>Rails 4之前，处理这种生成静态文件缓存可以用内置的caches_page， rails 4之后变成了一个独立gem actionpack-page_caching，和手工代码对比一下，</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CategoriesController &lt; ActionController::Base
</span><span class='line'>  caches_page :index&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def update
</span><span class='line'>    #…
</span><span class='line'>    expire_page action: ‘index’
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>如果只有一台服务器，这个方法简单又实用，但是如果有多台服务器，就会出现更新分类只能刷新自己本身这台服务器缓存的问题，可以用nfs来共享静态资源目录解决，或者用第2种：</p>

<h4 id="b-">B. 静态化到集中缓存服务</h4>
<p>首先我们得让Nginx有直接访问缓存的能力：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>upstream redis {
</span><span class='line'>    server redis_server_ip:6379;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>upstream ruby_backend {
</span><span class='line'>    server unicorn_server_ip1 fail_timeout=0;
</span><span class='line'>    server unicorn_server_ip2 fail_timeout=0;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>location /categories {
</span><span class='line'>    set $redis_key $uri;
</span><span class='line'>    default_type   text/html;
</span><span class='line'>    redis_pass redis;
</span><span class='line'>    error_page 404 = @httpapp;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>location @httpapp {
</span><span class='line'>    proxy_pass http://ruby_backend;
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Nginx首先会用请求的uri作为key去redis里面获取，如果获取不到（404）就转发给unicorn进行处理，然后改写generate_static_file和delete_static_file方法：</p>

<pre><code>redis_cache.set('categories', response.body)
  	
redis_cache.del('categories')
</code></pre>

<p>这样除了集中管理以外，还能够设置缓存的失效时间，对于一些更新无时效性要求的数据，就可以不用处理刷新机制，简单地固定时间刷新一次：</p>

<pre><code>redis_cache.setex('categories', 3.hours.to_i, response.body)
</code></pre>

<ol>
  <li>
    <h2 id="section-1">整页缓存</h2>
  </li>
</ol>

<p>Nginx缓存在处理带参数资源或者有用户状态的请求时候，就非常难以处理，这个时候可以用到整页缓存。
比如说分页请求列表，我们可以将page参数加入到cache_path：</p>

<pre><code>class CategoriesController
  	caches_action :index, :expires_in =&gt; 1.day, :cache_path =&gt; proc 	{"categories/index/#{params[:page].to_i}"}
end
</code></pre>

<p>比如说我们只需要针对rss输出进行缓存8小时：</p>

<pre><code>class ArticlesController
  	caches_action :index, :expires_in =&gt; 8.hours, :if =&gt; proc 	{request.format.rss?}
end 再比如说对于非登陆用户，我们可以缓存首页：

class HomeController
  	caches_action :index, :expires_in =&gt; 3.hours, :if =&gt; proc {!	user_signed_in?}
end
</code></pre>

<ol>
  <li>
    <h2 id="section-2">片段缓存</h2>
  </li>
</ol>

<p>如果说前面2种缓存能够用到的场景有限，那么片段缓存是适用性最广的。</p>

<h4 id="section-3">场景1：</h4>

<p>我们需要在每个页面一段广告代码，用来显示不同广告，如果没有使用片段缓存，那么每个页面都会要去查询广告的代码，并且花费一定时间去生成html代码：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class='line'>  div.ad
</span><span class='line'>    = advert.content</span></code></pre></td></tr></table></div></figure></p>

<p>加了片段缓存以后，就可以少去这个查询：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- cache “adverts/#{request.controller_name}/#{request.action_name}”, :expires_in =&gt; 1.day do
</span><span class='line'>  - if advert = Advert.where(:name =&gt; request.controller_name + request.action_name, :enable =&gt; true).first
</span><span class='line'>    div.ad
</span><span class='line'>      = advert.content&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-4">场景2：</h4>
<p>阅读文章，文章的内容可能比较长时间都不会改变，经常变化可能是文章评论，就可以对文章主体部分加上片段缓存：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache “articles/#{@article.id}/#{@article.updated_at.to_i}” do
</span><span class='line'>div.article
</span><span class='line'>  = @article.content.markdown2html&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>节约了生成markdown语法转换到html时间，这里用文章最后更新时间作为cache key的一部分，文章内容如果有改变，缓存自动失效，默认activerecord的cache_key方法也是用updated_at，你也可以加入更多的参数，比如article上有评论数的counter cache，更新评论数的时候不会更新文章时间，可以将这个counter也加入到key的一部分</p>

<h4 id="section-5">场景3：</h4>
<p>复杂页面结构的生成</p>

<p>数据结构比较复杂的页面，在生成的时候避免不了大量的查询和html渲染，用片段缓存，可以将这部分时间大大地节约，以我们网站游记页面 http://chanyouji.com/trips/109123 （请允许小小地打个广告，带点流量）来说：</p>

<p>需要获取天气数据，照片数据，文本数据等，同时还要生成meta，keyword等seo数据，而这些内容又是和其他动态内容交叉，片段缓存就可以分开多个：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache “trips/show/seo/#{@trip.fragment_cache_key}”, :expires_in =&gt; 1.day do
</span><span class='line'>title #{trip_name @trip}
</span><span class='line'>meta name=”description” content=”…”
</span><span class='line'>meta name=”keywords” content=”…”&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p>body
</span><span class='line'>  div
</span><span class='line'>    …
</span><span class='line'>- cache “trips/show/viewer/#{@trip.fragment_cache_key}”, :expires_in =&gt; 1.day do
</span><span class='line'>  - @trip.eager_load_all&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>小贴士，我在trip对象里面加了一个eager_load_all方法，缓存没有命中的时候，查询的时候避免出现n+1问题：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def eager_load_all
</span><span class='line'>    ActiveRecord::Associations::Preloader.new([self], {:trip_days =&gt; [:weather_station_data, :nodes =&gt; [:entry, :notes =&gt; [:photo, :video, :audio]]]}).run
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-6">小技巧1：带条件的片段缓存</h4>

<p>和caches_action不同，rails自带的片段缓存是不支持条件的，比如说我们想未登陆用户给他用片段缓存，而登陆用户不使用，写起来就很麻烦，我们可以改写一下helper就可以了：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def cache_if (condition, name = {}, cache_options = {}, &amp;block)
</span><span class='line'>    if condition
</span><span class='line'>      cache(name, cache_options, &amp;block)
</span><span class='line'>    else
</span><span class='line'>      yield
</span><span class='line'>    end
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>cache_if !user_signed_in?, “xxx”, :expires_in =&gt; 1.day do&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-7">小技巧2：关联对象的自动更新</h4>

<p>常使用对象update_at时间戳来作为cache key，可以在关联对象上加上touch选项，自动更新关联对象时间戳，比如我们可以在更新或者删除文章评论的时候，自动个更新：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Article
</span><span class='line'>  has_many :comments
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Comment
</span><span class='line'>  belongs_to :article, :touch =&gt; true
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
  <li>
    <h2 id="section-8">数据查询缓存</h2>
  </li>
</ol>

<p>通常来说web应用性能瓶颈都出现在DB IO上，做好数据查询缓存，减少数据库的查询次数，可以极大提高整体响应时间。
数据查询缓存分2种：</p>

<h4 id="a-">A. 同一个请求周期内的缓存</h4>

<p>举一个显示文章列表的例子，输出文章标题和文章类别，对应代码如下</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="controller">controller&lt;/h1>
</span><span class='line'>&lt;p>def index
</span><span class='line'>    @articles = Article.first(10)
</span><span class='line'>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="view">view&lt;/h1>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>@articles.each do |article|
</span><span class='line'>h1 = article.name
</span><span class='line'>span = article.category.name&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>会发生10条类似的sql查询：</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` = ?
</code></pre>

<p>rails内置了query cache</p>

<p><a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb">https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/query_cache.rb</a>，</p>

<p>在同一个请求周期内，如果没有update/delete/insert的操作，会对相同的sql查询进行缓存，如果文章类别都是相同的话，真正去查询数据库只会有1次。</p>

<p>如果文章类别都不一样，就会出现N+1查询问题（常见的性能瓶颈），rails推荐的解决方法是用Eager Loading Associations</p>

<p><a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>  	def index
</span><span class='line'>&lt;pre>&lt;code>	@articles = Article.includes(:category).first(10)
</span><span class='line'>  	end</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>查询语句会变成</p>

<pre><code>SELECT `categories`.* FROM `categories` WHERE `categories`.`id` in (?,?,?...)
</code></pre>

<h4 id="b--1">B. 跨请求周期的缓存</h4>

<p>同请求周期缓存所带来性能优化是很有限的，很多时候我们需要用跨请求周期的缓存，将一些常用的数据（比如User model）缓存，对于active record来说，利用统一的查询接口来fetch cache，利用callback来expire cache，就很容易实现，而且有一些现成的gem可以来用。</p>

<p>比如说 identity_cache</p>

<p><a href="https://github.com/Shopify/identity_cache">https://github.com/Shopify/identity_cache</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class User &lt; ActiveRecord::Base
</span><span class='line'>  include IdentityCache
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Article &lt; ActiveRecord::Base
</span><span class='line'>  include IdentityCache
</span><span class='line'>  cached_belongs_to :user
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="section-9">都会命中缓存&lt;/h1>
</span><span class='line'>&lt;p>User.fetch(1)
</span><span class='line'>Article.find(2).user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>这个gem的优点是代码实现简单，cache设置灵活，也方便扩展，缺点是需要用不同的查询方法名（fetch），以及额外的关系定义。</p>

<p>如果想在无数据缓存的应用无缝加入缓存功能，推荐@hooopo 做的second_level_cache</p>

<p><a href="https://github.com/hooopo/second_level_cache">https://github.com/hooopo/second_level_cache</a></p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class User &lt; ActiveRecord::Base
</span><span class='line'>  acts_as_cached(:version =&gt; 1, :expires_in =&gt; 1.week)
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="find">还是使用find方法，就会命中缓存&lt;/h1>
</span><span class='line'>&lt;p>User.find(1)
</span><span class='line'>#无需额外用不一样的belongs_to定义
</span><span class='line'>Article.find(2).user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>实现原理是扩展了active record底层arel sql ast处理</p>

<p><a href="https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb">https://github.com/hooopo/second_level_cache/blob/master/lib/second_level_cache/arel/wheres.rb</a></p>

<p>它的优点是无缝接入，缺点是扩展比较困难，对于只获取少量字段的查询无法缓存。</p>

<ol>
  <li>
    <h2 id="section-10">数据库缓存</h2>
  </li>
</ol>

<p>编辑中</p>

<p>这6种缓存，分布在客户端到服务器端不同的位置，所能够节约的时间也正好从多到少依次排列。</p>

<hr />
<p>转载自  <a href="https://ruby-china.org/topics/19389">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Gems内存泄露]]></title>
    <link href="http://helloyokoy.github.io/blog/ruby-gems-memory-leak/"/>
    <updated>2015-10-25T15:01:34+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ruby-gems-memory-leak</id>
    <content type="html"><![CDATA[<p>请大家检查下 Gemfile.lock，若在使用如下版本的gem包，那么请及时更新</p>

<ul>
  <li>
    <p>therubyracer &lt; 0.12.2</p>
  </li>
  <li>
    <p>sidekiq &lt; 3.5.1</p>
  </li>
  <li>
    <p>celluloid &gt; 0.16.0, &lt; 0.17.2</p>
  </li>
  <li>
    <p>zipruby &lt;= 0.3.6</p>
  </li>
  <li>
    <p>redcarpet &lt; 3.3.3</p>
  </li>
  <li>
    <p>grape &lt; 0.2.5</p>
  </li>
</ul>

<p><a href="https://github.com/ASoftCo/leaky-gems">https://github.com/ASoftCo/leaky-gems</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Gems 推荐]]></title>
    <link href="http://helloyokoy.github.io/blog/rails-gems-recomend/"/>
    <updated>2015-10-09T12:31:27+08:00</updated>
    <id>http://helloyokoy.github.io/blog/rails-gems-recomend</id>
    <content type="html"><![CDATA[<p>Rails社区的gem库，按我感觉质量普遍比较高，这跟Rails社区的氛围有关，以下推荐的是我个人在项目中时常用到的并且比较主流的gem，想到哪儿写到哪儿，挂一漏万。</p>

<h4 id="bootstrapbootstrap-sass">1.bootstrap（bootstrap-sass）</h4>

<p>这个不用解释了吧，对于没有专业前端小伙伴的项目和团队是福音。而且对于想要学习前端技术的同学，bootstrap的源码非常值得进行深入的学习和理解。当然，缺点也是有的，就是大家的网站做出来都比较像，建议有条件的小伙伴使用的时候还是多进行一些个性化修改。</p>

<h4 id="capistranocapistrano--rubygemsorg">2.Capistrano（capistrano | RubyGems.org）</h4>

<p>Capistrano最初就是用来向服务器部署ruby应用的，当然现在也开始支持其他类型项目的部署。Capistrano是一种在多台服务器上运行脚本的开源工具，它主要用于部署web应用。它自动完成多台服务器上新版本的同步更新，包括数据库的改变。使用起来非常方便，基本也是Rails应用开发必备。</p>

<h4 id="bcryptbcrypt--rubygemsorg">3.bcrypt（bcrypt | RubyGems.org）</h4>

<p>bcrypt是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。在rails上使用起来相当简便，web开发一般是少不了的。</p>

<h4 id="sprocketssprockets--rubygemsorg">4.sprockets（sprockets | RubyGems.org）</h4>

<p>Sprockets 是一个 Ruby 库，用来检查 JavaScript 文件的相互依赖关系，用以优化网页中引入的js文件，以避免加载不必要的js文件，加快网页访问速度。这个现在貌似是rails工程默认自带gem，记不太清了，足见重要性。但是我在使用中发现有时候会跟bootstrap的js库发生冲突，主要是版本问题，有使用的小伙伴需要注意一下。</p>

<!--more-->

<h4 id="paperclippaperclip--rubygemsorg">5.Paperclip（paperclip | RubyGems.org）</h4>

<p>paperclip基本上已经是rails的御用图片上传gem了，功能强大使用方便，但是唯一不太好的就是图片剪裁上面功能比较有限。paperclip依赖于ImageMagic，大部分linux包管理器（如apt yum portage等）中应该都能找到这个软件包。</p>

<h4 id="rmagickrmagick--rubygemsorg">6.rmagick（rmagick | RubyGems.org）</h4>

<p>这个gem弥补了paperclip在图片剪裁上的不足。功能十分十分十分的强大，文档也很齐全，只不过是全英文，中文资料比较少。如果项目有要开发头像剪裁上传，那么用rmagic剪裁，paperclip上传是比较好的解决方案。</p>

<h4 id="friendlyidfriendlyid--rubygemsorg">7.friendly_id（friendly_id | RubyGems.org）</h4>

<p>现在大部分网站都已经是友好的url地址了，如果你的rails项目还用数字作为id进行查询那就太low了。</p>

<h4 id="willpaginatewillpaginate">8.will_paginate（will_paginate）</h4>

<p>老版本的will_paginate分业是基于plugin方式的，新版本的will_paginate已经抛弃了这样的做法，转而使用gem的方式。这样一来安装和使用更加方便，配合一些前端的分页加载库，会让分页加载功能开发非常快捷。</p>

<h4 id="ransackransack--rubygemsorg">9.ransack（ransack | RubyGems.org）</h4>

<p>搜索功能一般分为分词和不分词的，如果你只想做用户和文章标题检索之类的功能，那么不分词的搜索gem比较合适，类似的gem挺多的，我常用的是这个。</p>

<h4 id="sunspotsunspot--rubygemsorg">10.sunspot（sunspot | RubyGems.org）</h4>

<p>接上面，全文搜索的gem也不少，sunspot对于小型项目的话，稍微有些重。如果没有那么多要求的话，sphinx也可以考虑，速度快，占用资源低。</p>

<h4 id="gecodergeocoder--rubygemsorg">11.Gecoder（geocoder | RubyGems.org）</h4>

<p>说实话在web上做定位确实比较乏力，尽量还是用手机客户端吧</p>

<h4 id="pumapumapuma--github">12.puma（puma/puma · GitHub）</h4>

<p>对于想要处理并发请求的web项目，Puma 是和 Unicorn相竞争的 Web 服务器，它能够处理并发请求。Puma 使用线程，以及工作者进程，能够更多的利用可用的 CPU。在 Puma 中，如果整个基础代码是线程安全的，那么你可用利用线程。否则，在使用 Puma 的时候，你只能使用工作者进程进行拓展。Puma的设置也比较简单，官方有详细的使用文档，RubyChina也使用Puma，个人推荐。</p>

<h4 id="emojiwpetersonemoji--github">13.Emoji（wpeterson/emoji · GitHub）</h4>

<p>现在只要涉及社交的项目估计很少有不用表情的了，Emoji是个集成度比较高的Emoji表情转码库，使用方便，当然大部分情况下还是要配合前端使用。</p>

]]></content>
  </entry>
  
</feed>
