<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ruby | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2015-11-03T16:30:48+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gemfile 详解]]></title>
    <link href="http://helloyokoy.github.io/blog/gem-description/"/>
    <updated>2015-11-03T16:05:02+08:00</updated>
    <id>http://helloyokoy.github.io/blog/gem-description</id>
    <content type="html"><![CDATA[<p>前几天读到的一篇博客，觉得内容很详实，就翻译了下给大家分享下。绝大部分为直译，极少数地方加了点自己的注释，若有不周到地方，还望大家指出。如果有排版方面的问题，也请指出。</p>

<p>原文：<a href="http://tosbourn.com/what-is-the-gemfile/">http://tosbourn.com/what-is-the-gemfile/</a></p>

<p>作为Ruby开发者，我们一直在使用Gemfile，并且大部分人知道一些关于Gemfile的基础知识。在这篇文章里，我想更加深入到Gemfile里面去看看通过Gemfile所能做的一切。</p>

<h2 id="gemfile">什么是Gemfile</h2>

<p>Gemfile是我们创建的一个用于描述gem之间依赖的文件。gem是一堆Ruby代码的集合，它能够为我们提供调用。你的Gemfile必须放在项目的根目录下面， 这是Bundler的要求，对于任何的其他形式的包管理文件来说，这也是标准。这里值得注意的一点是Gemfile会被作为Ruby代码来执行。当在Bundler上下文环境中被执行的时能使我们访问一些方法，我们用这些方法来解释gem之间的require关系。</p>

<!--more-->

<h2 id="gemfile-1">创建Gemfile</h2>

<p>首先我们要做的就是告诉Gemfile到那里去找到这些gems, 这就是gem的源。</p>

<p>我们使用#source方法来做这件事情</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source “https://rubygems.org”</span></code></pre></td></tr></table></div></figure></p>

<p>这里并不推荐一个项目有多个源。对于99%的项目，你的Gemfile的源都会被要求设置为https://rubygems.org，对于一个源，唯一的要求是它必须是一个合法的Rubygems的repo。</p>

<h2 id="section">源的优先级</h2>

<p>现在我们来探讨下关于gem源的优先级。
我们在Gemfile的顶部位置定义一个源的同时，我们也可以针对每个gem定义一个源。我们也能够为一个本地的gem定义一个路径或者是为gem定义一个git路径，比如说GitHub之类的（我们在后面点讲到这点）。</p>

<p>当Bundler尝试定位一个gem的时候，它会首先查看这个gem有没有显示的设置源，如果有，就先使用这个源。如果你在设置gem的时候有使用source, path或者git依赖的话，Bundler将会先在这些地方找，然后再去其他地方寻找。如果没有被显示设置的话， Bundler将会依照你Gemfile里面定义的源的顺序来找。如果一个gem能够在多个源里面被找到的话（虽然这是极为罕见的，因为你最好只定义一个源），你将会得到一个warning来提示你哪个源被使用了。</p>

<p>你能够使#source作为一个block来调用</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source “https://my_awesome_source.com” do
</span><span class='line'>   gem “my_gem”
</span><span class='line'>   gem “my_other_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="section-1">带验证的源</h2>

<p>有些源需要你使用验证才能够被设定。Bundler有一个设置选项使得你可以为每个源设置用户名和密码</p>

<pre><code>bundle config my_gem_source.com my_username:my_password
</code></pre>

<p>这是任何希望通过Bundler来安装gem都必须要的因为它不会被放入版本管理里面。你也可以直接在Gemfile中设置你的验证信息，当然，这些验证信息也会被commit进你的版本管理工具。如下所示</p>

<pre><code>source "https://username:password@my_gem_source.com" 你在源里面的设置，都会被你以bundle config的方式设置的东西所覆盖。
</code></pre>

<h2 id="ruby">设置Ruby信息</h2>

<p>如果你的应用程序需要使用一个特别的Ruby版本或是引擎，我们都能够在Gemfile里面进行设置。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby “1.9.3”, :patchlevel =&gt; “247”, :engine =&gt; “jruby”, :engine_version =&gt; “1.6.7”</span></code></pre></td></tr></table></div></figure></p>

<p>当设定这个的时候，需要的唯一点信息就是ruby的版本（我们这里使用1.9.3）
* :pathlevel 声明了Ruby的patch level
* :engine 声明了使用的Ruby引擎
* :engine_version 声明了引擎的版本 (如果这个被设置了，engine也需要被设置）</p>

<h2 id="gems">设置Gems</h2>

<p>现在我们到了Gemfile的核心，设置你的gems。最基本的语法如下：</p>

<pre><code>gem "my_gem"
</code></pre>

<p>这里my_gem是 gem的名字，gem的名字是唯一要求的参数，此外还有几个可以选择的参数可以使用。</p>

<h2 id="gem">设置Gem的版本</h2>

<p>对于一个gem，你最常做的事情就是设置它的版本，如果你不设置版本的话，你也可以说任意的版本都可以。</p>

<pre><code>gem "my_gem", "&gt;= 0.0"
</code></pre>

<p>这里有7个操作符供你用来设置你的gem</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>= Equal To “=1.0”&lt;/li>
</span><span class='line'>  &lt;li>!= Not Equal To “!=1.0”&lt;/li>
</span><span class='line'>  &lt;li>
</span><span class='line'>    &lt;blockquote>
</span><span class='line'>      &lt;p>Greater Than “&gt;1.0”&lt;/p>
</span><span class='line'>    &lt;/blockquote>
</span><span class='line'>  &lt;/li>
</span><span class='line'>  &lt;li>&lt; Less Than “&lt;1.0”&lt;/li>
</span><span class='line'>  &lt;li>
</span><span class='line'>    &lt;blockquote>
</span><span class='line'>      &lt;p>= Greater Than or Equal To “&gt;=1.0”&lt;/p>
</span><span class='line'>    &lt;/blockquote>
</span><span class='line'>  &lt;/li>
</span><span class='line'>  &lt;li>&lt;= Less Than or Equal To “&lt;=1.0”&lt;/li>
</span><span class='line'>  &lt;li>~&gt; Pessimistically Greater Than or Equal To “~&gt;1.0”&lt;/li>
</span><span class='line'>  &lt;li>~&gt; Pessimistically Greater Than or Equal To&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>~&gt; 操作能够让你使用这个gem的未来的某个安全的版本。如果你觉得使用一个大的版本更安全，你能够像下面这样声明.</p>

<pre><code>gem "my_gem", "~&gt; 2.0"
</code></pre>

<p>这能够允许你安装任意的2.x版本的gem，但是3.x版本是不被允许的。或许你对这么宽泛的版本感到不爽，你也可以声明一个更具体的版本，如下</p>

<pre><code>gem "my_gem", "~&gt; 2.5.0"
</code></pre>

<p>这能够让你使用2.5.0到2.6.0之间的版本。下面的例子能够让你更加理解~&gt; 操作符</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>gem “my_gem”, “~&gt; 1.0” –&gt; gem “my_gem”, “&gt;= 1.0”, “&lt; 2.0”&lt;/li>
</span><span class='line'>  &lt;li>gem “my_gem”, “~&gt; 1.5.0” –&gt; gem “my_gem”, “&gt;= 1.5.0”, “&lt; 1.6.0”&lt;/li>
</span><span class='line'>  &lt;li>gem “my_gem”, “~&gt; 1.5.5” –&gt; gem “my_gem”, “&gt;= 1.5.5”, “&lt; 1.6.0”</span></code></pre></td></tr></table></div></figure></li>
</ul>

<h2 id="gemrequired">设置gem被required</h2>

<p>如果你使用Rails的话，这点小技巧可能被隐藏了，但是在你的config/application.rb文件里面你能看到这么一行代码。</p>

<pre><code>Bundler.require(:default, Rails.env)
</code></pre>

<p>它的意思是require所有没有被放入group（后面会讲到这个概念）里面的gems和所有放入和当前rails环境（RAILS_ENV, development, test, production)同名的group里面的gems。</p>

<p>默认方式下，如果你在Gemfile里面包含一个gem，当Bundler.require被调用的时候会被包含进来。我们也能通过下面的设置让gem不被包含进来(译者注释：这样你就只能安装这个gem，在使用的时候必须在你的代码里手动的添加require ‘my_gem’来调用my_gem里面的方法了。为什么需要这样呢，因为并不是所有的地方都需要使用这个gem，比如你在rake task里面使用了my_gem, 而其他地方没有使用，故你只需要在这个gem require到task里面，避免了所有的进程都把这个gem加载进去）</p>

<pre><code>gem "my_gem", require: false
</code></pre>

<p>当然你也可以指定哪些文件夹被required的，如下：</p>

<pre><code>gem "my_gem", require: ["my_gem/specific_module/my_class", "my_gem"]
</code></pre>

<p>这点在当你的gem有很多功能的，你必须每次手动require的时候非常有用。</p>

<h2 id="gem-1">gem分组</h2>

<p>正如我上面提到的一样，一个gem可以属于一个或多个group，当它不属于任何group的时候，它被放入了:default group。
有两种方法你可以对一个gem分组。第一种是对group属性进行赋值，如下所示：</p>

<pre><code>gem "my_gem", group: :development
</code></pre>

<p>它的意思是，这个gem只在development环境下被require。这也意味着当你在安装gems的时候，你可以指定某个group下面的gems不被安装，这样在一定程度上能加快gem的安装。</p>

<pre><code>bundle install --without development test
</code></pre>

<p>上面的意思是安装除development和test group意外的所有gems。
第二种gem分组的方法就是你可以将gems放入一个block里面，如下所示：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>group :development do
</span><span class='line'>   gem “my_gem”
</span><span class='line'>   gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>这看上去更美观，并且你也可以设置多个group。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>group :development, :test do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>如果你想让某个group变成可选的形式，你也可以像下面这样，设置optional: true</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>group :development, optional: true do
</span><span class='line'>   gem “my_gem”
</span><span class='line'>   gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>当上面被设置时，为了安装development group下面的gems，需要运行bundle install —with development</p>

<h2 id="gem-2">设置gem的平台</h2>

<p>如果某个gem只能在某个平台上使用，你也可以在gemfile里面设置。平台的原理和group很类似，但不同的是你不需要去通过—without这样的option去指定，它会自动根据平台判断执行。</p>

<pre><code>gem "my_gem", platform: :jrubygem "my_other_gem", platform: [:ruby, :mri_18]
</code></pre>

<p>下面是一个不同平台的list。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;ul>
</span><span class='line'>  &lt;li>ruby – C Ruby (MRI) or Rubinius, but not Windows&lt;/li>
</span><span class='line'>  &lt;li>ruby_18 to ruby_22 – ruby &amp; (version 1.8 .. version 2.2)&lt;/li>
</span><span class='line'>  &lt;li>mri – Same as ruby, but not Rubinius&lt;/li>
</span><span class='line'>  &lt;li>mri_18 to mri_22 – mri &amp; (version 1.8 .. version 2.2)&lt;/li>
</span><span class='line'>  &lt;li>rbx – Same as ruby, but only Rubinius (not MRI)&lt;/li>
</span><span class='line'>  &lt;li>jruby – JRuby&lt;/li>
</span><span class='line'>  &lt;li>mswin – Windows&lt;/li>
</span><span class='line'>  &lt;li>mingw – Windows 32 bit mingw32 platform (aka RubyInstaller)&lt;/li>
</span><span class='line'>  &lt;li>mingw_18 to mingw_22 – mingw &amp; (version 1.8 .. version 2.2)&lt;/li>
</span><span class='line'>  &lt;li>x64_mingw – Windows 64 bit mingw32 platform&lt;/li>
</span><span class='line'>  &lt;li>x64_mingw_20 to x64_mingw_22 – x64_mingw &amp; (version 2.0 .. version 2.2)&lt;/li>
</span><span class='line'>&lt;/ul>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>我发现平台真的非常有用，当一个开发团队在不同平台开发的时候。当你team的一个开发者使用的是Windows平台的时候，你可能需要不同版本的gem来支持。我经常使用下面的block语法来使用platform设定。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>platforms :jruby do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="gem-3">设置gem的源</h2>

<p>ok，现在我们来讲设置gem的源，如下所示:</p>

<pre><code>gem "my_gem", source: "https://my_awesome_gemsite.com"
</code></pre>

<p>如果这个my_gem 在source里面找不到的话，Bundler也不会去default的源里面找，所以找不到的情况下这个gem就不会被安装。</p>

<h2 id="gitgem">从git安装gem</h2>

<p>你可以设置gem的安装源为一个git repo，比如GitHub, 这只需要你将source属性替换为git。你可以设置这个repo的链接为HTTP(S), SSH, GIT等协议，但最好使用HTTP(S)和SSH，因为其他的会使你可能成为man-in-the-middle攻击的受害者。如果你把gem放入到repo里面，你必须要在repo根目录文件夹下面有一个.gemspec 文件。这里面需要包含一个合法gem的声明。如果你没有提供这个文件，Bundler会尝试创建一个，但是他不会被依赖。如果你尝试去include一个没有提供.gemspec文件的git repo里面的gem，你必须指定一个版本号。</p>

<p>你可以为gem设置branch，tag，ref，默认是使用master branch。你也可以强制Bundler扩展submodule，通过以下方式来设置：</p>

<pre><code>gem "my_gem", git: "ssh@githib.com/tosbourn/my_gem", branch: test_branch, submodules: true
</code></pre>

<p>如果你有多个gem来自同一个git repo，你也可以通过下面block形式组织起来。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git “git@github.com:tosbourn/my_gems.git” do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="gitsource">设置Git作为source</h2>

<p>你可以设置一个URL来作为一个更广义的源，你可以通过调用#git_source方法并将name作为参数传进去，以及一个接收一个参数的block，并返回一个string作为repo的URL。如下所示：</p>

<pre><code>git_source(:custom_git){ |repo| "https://my_secret_git_repos.com/#{repo}.git" }
gem "my_gem", custom_git: "tosbourn/test_repo"
</code></pre>

<h2 id="bitbucketgithubhelper-method">BitBucket和Github的helper method</h2>

<p>因为BitBucket和Github都是比较流行的git repo host，所以有两者的helper method。在两者里面，Bundler都默认repo是public的。</p>

<pre><code>gem "my_gem", github: "tosbourn/my_gem" 
gem "my_gem", bitbucket: "tosbourn/my_gem"
</code></pre>

<p>你也可以设置两者的branch。当用户名和repo名字一致的时候，可以省略一个。</p>

<pre><code>gem "rails", github: "rails"
gem "rails", bitbucket: "rails"
</code></pre>

<p>注意：在Bundler 2出来之前，你不能使用:github这个参数，目前它是使用git://协议的，就是前面讲过的可能会受到man-in-the-middle攻击的。还有一个helper :gist, 如果你Github上是以gist的形式存放的话就能够使用它。你可以只使用gist ID作为path，也可以像:github, :bitbucket那样传入:branch参数。</p>

<pre><code>gem "my_gem", :gist =&gt; "5935162112", branch: "my_custom_branch"
</code></pre>

<h2 id="pathgem">用path包含本地Gem</h2>

<p>你可以通过传入:path参数来依赖你本地的gems。</p>

<pre><code>gem "my_gem", :path =&gt; "../my_path/my_gem"
</code></pre>

<p>如果你传入一个相对路径的话（如上），这个路径是相对于你Gemfile的路径的。如果你想把某个文件夹下所有的gems都包含进去的话，你可以使用如下的block。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>path “../my_path/gems” do
</span><span class='line'>  gem “my_gem”
</span><span class='line'>  gem “my_other_gem”
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>有一点值得注意的是，如果你使用的是path的话，Bundler是不会编译c extension的。</p>

<h2 id="gems-1">选择性的安装gems</h2>

<p>有时候你想在某个前提条件被满足的情况下安装这个gem，比如你系统里面是否有某个程序。下面这个方法能够接收一个proc或lambda，下面的例子中我们将在你的系统是mac的时候安装这个gem</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>install_if -&gt; { RUBY_PLATFORM =~ /darwin/ } do
</span><span class='line'>   gem “my_osx_gem”
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h2 id="section-2">结束语</h2>

<p>谢谢你的阅读并希望它能对你有所帮助，如果我有什么遗漏或你有什么问题的话请联系我~</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/26655">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术学习态度]]></title>
    <link href="http://helloyokoy.github.io/blog/tech-learn/"/>
    <updated>2015-11-03T15:23:49+08:00</updated>
    <id>http://helloyokoy.github.io/blog/tech-learn</id>
    <content type="html"><![CDATA[<p>本文仅谈业余时间的技术学习，不谈工作中的要求。</p>

<p>技术固然要时时学习，因为更新快嘛，但对待技术上学什么，怎么花时间学，需要一个指导思想，否则浪费时间而且效果不好。</p>

<ol>
  <li>
    <p>抓住主干，而非细节
最近很火的一句话是“你不要用战术上的勤奋掩盖战略上的懒惰”。放到技术学习上就先主理解主干后关注枝叶，比如C++的好书很多，《Effective C++》和《Inside C++ Object Model》是好书，但它们都不是用来入门的，为什么? 因为它们不是主干，语言实现细节和各种坑你都了解了，碰到实际问题依然用不好C++。</p>
  </li>
  <li>
    <p>尽量不折腾
不去折腾那些不成熟的技术，尽量用较为成熟的技术。在一年多之前，我用AngularJS，MongoDB的时候把我可给坑惨了，所以我下决心如果不因为工作坚决不碰Go语言，Node.js，要学不如学Erlang。新技术应用场景不清晰，前景不清晰，生态环境弱，类库少，坑多不容易跳出来。简而言之就是风险大于收益。同理我也不喜欢用Linux而喜欢Mac，Vim的包也是别人弄好了直接install的。</p>
  </li>
</ol>

<!--more-->

<ol>
  <li>
    <p>尽量学习经典原理而不是浪费时间在细节上。
这一点条和第一点类似，多花时间学习抽象模式，设计原则，类型系统，看诸如《SICP》《The little schemer》《Essential of Programming Language》这种书，如果不是因为工作绝不浪费时间到《Dive into python》这种具体到语言细节的书上。</p>
  </li>
  <li>
    <p>尽量学习形而下的系统而不过多上升到形而上的思想上。上一点谈到了抽象模式和类型系统，但切不可单纯从思想上判断哪种语言一定好，哪种抽象模式就一定好，一定要结合形而下的系统综合看待，学习C语言就要随着OS学习，学习Lisp就随着编译器或分析器一起学习，学习Ruby或Python就跟着web开发来学习，通过某一类系统架构理解语言的优劣，通过语言来理解为何这么架构系统。</p>
  </li>
  <li>
    <p>学好那些通用技能。
比如：1，如何进行Debug，2，如何阅读源代码，3，如何进行基本性能监控，4，熟练用好自己的编辑器和*nix命令行，5，git技巧，6，项目管理能力，7，关系型数据库的知识。</p>
  </li>
</ol>

<hr />
<p>转载自 <a href="http://liusihao.com/post/64854832920/%E6%88%91%E5%AF%B9%E5%BE%85%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%81%E5%BA%A6">我对技术的态度</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wechat 开发环境搭建]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-develop-environment/"/>
    <updated>2015-10-29T15:46:09+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-develop-environment</id>
    <content type="html"><![CDATA[<p>由于微信开发都是在微信内浏览器运行，不管是登陆还是支付都不能在PC开发端愉快地玩耍，但世界我们还是需要拯救的。</p>

<p>由于自己换了新电脑，第一次做微信开发跟大家分享一下我的开发环境，欢迎拍砖交流。</p>

<p>一般的第三方开发永远离不开两个配置，域名 &amp; 回调，有一些平台支持localhost的域名&amp;回调会方便，更有支持随意更改端口的，微信上面貌似都没有 。</p>

<p>好了，假定我们的域名是playmonkey.me</p>

<h2 id="section">域名</h2>

<p>微信登陆，JSAPI以及支付都有域名限制，所以需要让手机微信上打开palymonkey.me时，访问到我们本地的development server。</p>

<p>干这个勾当的当属 Charles 神器。</p>

<!--more-->

<p>下载安装打开Charles
Proxy -&gt; Proxy Setting -&gt; Http Proxy勾选Enable…. 开启http proxy代理，端口默认是8888
Tool -&gt; DNS Spoofing Settings 勾选Enable DNS Spoofing
然后把palymonkey.me加到DNS Spoofs，指向本机127.0.0.1
Charles好了，下一步配置手机，确保你的手机网络和电脑在同一局域网，配置手机的HTTP代理到电脑的IP上，端口8888；</p>

<p>访问http://playmonkey.me；</p>

<p>什么？挂了？当然，酱紫访问的是本地的80端口。</p>

<p>好了，我们再来用 Nginx 反向代理搞定这个问题，让手机端的playmonkey.me访问到本地development server的3000端口上。</p>

<p>首先安装启动Nginx，用Apache的朋友对不起了，你们要自食其力XD</p>

<p>配置Nginx</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;server {</span>
</span><span class='line'><span class="sr">      listen 80;</span>
</span><span class='line'><span class="sr">      server_name playmonkey.me;</span>
</span><span class='line'><span class="sr">      charset utf-8;</span>
</span><span class='line'><span class="sr">      location /</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">proxy_pass</span>          <span class="ss">http</span><span class="p">:</span><span class="sr">//mon</span><span class="n">key_servers</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_redirect</span>      <span class="n">default</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Forwarded</span><span class="o">-</span><span class="no">For</span> <span class="vg">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Real</span><span class="o">-</span><span class="no">IP</span> <span class="vg">$remote_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="no">Host</span> <span class="vg">$http_host</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_next_upstream</span> <span class="n">http_502</span> <span class="n">http_504</span> <span class="n">error</span> <span class="n">timeout</span> <span class="n">invalid_header</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;  }</span>
</span><span class='line'>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">upstream palymonkey_servers{</span>
</span><span class='line'><span class="sr">  server 127.0.0.1:3000;</span>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>再用手机访问http://playmonkey.me ，Nice….这回看到页面了。
到此我们可以在微信上用playmonkey.me访问本地的dev server，可以愉快地调用JSAPI &amp; 微信oauth登陆 &amp; 发起支付。</p>

<p>噢，如果做的是PC端的oauth微博登录怎么办？ 在本地host加上 127.0.0.1 palymonkey.com。Nice XD、</p>

<h2 id="section-1">异步回调</h2>

<p>上面说到发起支付，微信的支付结果是通过异步回调的，所以需要做内网穿透，这里推荐两个工具 ngrok OR localtunnel</p>

<p>localtunnel</p>

<p>localtunnel 是node写的，用起来非常简单</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>npm install -g localtunnel
</span><span class='line'><span class="nv">$ </span>lt –port 3000
</span><span class='line'>your url is: https://gqgh.localtunnel.me&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>这样外网打开https://gqgh.localtunnel.me 就可以访问到本地的3000端口</p>

<p>但是localtunnel是国外的，公司网络刚刚搭好，经常不稳定果断抛弃转入ngrok；</p>

<p>ngrok（不想折腾的可以忽略XD）</p>

<p>悲催的是ngrok也是国外的，而且服务器给墙了，BUT，问题不大，我们可以pull ngrok 1.X的源码自己编译，2.0会报证书错误如果没有合法的https证书。</p>

<p>好了我们来编译ngrok，噢，对了，ngrok是Go写的，编译出来直接是一个可执行文件，爽歪歪有木有，哈~</p>

<p>在服务器端（每家都有一只staging服务器吧）</p>

<p>NGROK_DOMAIN 设置为您自己拥有的域名，并指向Ngrok server运行的服务器</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'>git clone https://github.com/inconshreveable/ngrok.git
</span><span class='line'><span class="nb">cd </span>ngrok&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;openssl genrsa -out rootCA.key 2048
</span><span class='line'>openssl req -x509 -new -nodes -key rootCA.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -days <span class="m">5000</span> -out rootCA.pem
</span><span class='line'>openssl genrsa -out device.key 2048
</span><span class='line'>openssl req -new -key device.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -out device.csr
</span><span class='line'>openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cp rootCA.pem assets/client/tls/ngrokroot.crt
</span><span class='line'><span class="c"># make clean</span>
</span><span class='line'>make release-server release-client&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>编译完有两个可执行文件 bin/ngrok &amp; bin/ngrokd 
将bin/ngrok copy到你本机
在服务器上开启ngrok server</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;bin/ngrokd -tlsKey<span class="o">=</span>device.key -tlsCrt<span class="o">=</span>device.crt -domain<span class="o">=</span>”<span class="nv">$NGROK_DOMAIN</span>” -httpAddr<span class="o">=</span>”:8000” -httpsAddr<span class="o">=</span>”:8001”&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>本地端</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'><span class="nb">echo</span> -e “server_addr: <span class="nv">$NGROK_DOMAIN</span>:4443<span class="se">\n</span>trust_host_root_certs: <span class="nb">false</span>” <span class="p">&amp;</span>gt<span class="p">;</span> ngrok-config
</span><span class='line'>./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span>playmonkey <span class="m">3000</span> // 配置subdomain到本地3000端口，这样外网通过playmonkey.NGROK_DOMAIN 就可以访问到本地dev server的3000端口&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>或者用SSH forwarding</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span><span class="m">3000</span> –proto<span class="o">=</span>tcp 22&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>以上Ngrok编译&amp;配置出自 <a href="https://gist.github.com/lyoshenka/002b7fbd801d0fd21f2f">How to setup Ngrok with a self-signed SSL cert</a></p>

<p>至此我们在发起微信支付时回调URL的HOST就可以设置为playmonkey.NGROK_DOMAIN</p>

<p>至此我们可以愉快地开发测试 微信的oauth登录 &amp; JSAPI &amp; 支付 &amp; 支付回调，好吧，很多BUG一点都不愉快。
另外感谢 <a href="https://ruby-china.org/ruby_sky">@ruby_sky</a> 的这篇 <a href="https://ruby-china.org/topics/26138">微信支付文章</a> 微信支付做起来如丝般顺滑；
内微信文档看起来太蛋疼了，各种配置也是找半天，大家有兴趣我可以总结一下微信各个开发的各种配置XD。</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/26443">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信开发 gems]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-gems/"/>
    <updated>2015-10-27T15:35:10+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-gems</id>
    <content type="html"><![CDATA[<p>最近陆续有不少用Rails开发微信项目的朋友在Github上开始使用weixin_rails_middleware、weixin_authorize，也不少人谈到Ratchet，春节开始到现在，一直有做微信的开发，现在在论坛上发布出来，希望让更多人知道这些gem的存在，更快速的完成你们手中的任务。</p>

<p>有问题可以前往：微信开发论坛：http://weixin-dev.com/</p>

<p>代码写得不好，还请多多包涵，如果有任何问题，可以直接联系我。:)</p>

<!--more-->

<h4 id="rails">1:一（两）条命令搭建Rails微信版本</h4>

<p>按照最简洁的速度，10分钟可以跑起一个微信的项目：
https://github.com/lanrion/weixin_rails_middleware</p>

<p>自动验证微信请求；
一（两）条命令，一个配置，简练风格；
支持Rails 3, Rails 4；
支持多公众账号平台，例如类似微盟；
支持单个用户，即一个账号，但又不想保存在数据库；
提供回复消息辅助方法；
提供所有微信消息类型的业务逻辑的回复处理；
wiki 中提供自定义菜单中的实现案例；
自动生成token；
详细见：</p>

<p>https://github.com/lanrion/weixin_rails_middleware/wiki/</p>

<p>wiki中也有不少关于开发上的建议与经验，还有自己遇到一些奇葩的问题</p>

<p>https://github.com/lanrion/weixin_rails_middleware</p>

<h4 id="api">2：微信高级API实现：</h4>

<p>https://github.com/lanrion/weixin_authorize</p>

<p>除 Oauth 2 未实现，其他API均已实现；
支持Redis存储access_token；
还是直接看wiki 吧：</p>

<p>https://github.com/lanrion/weixin_authorize/wiki/Getting-Started
wiki中也有不少关于开发上的建议与经验，还有自己遇到一些奇葩的问题</p>

<h4 id="ratchet-v201gem-twitterratchetrails">3：集成Ratchet v2.0.1的gem: twitter_ratchet_rails</h4>

<p>即：http://goratchet.com/ 压缩后非常小，十分适合wap使用，但有一个不足之处在于，组件不够丰富，期待更丰富的实现
没其他多余的好说，看官直接点击：</p>

<p>https://github.com/lanrion/twitter_ratchet_rails</p>

<p>小弟身材弱小，砖别拍的太猛，嘿，把我拍死了，就没人维护这三个gem了。:)</p>

<h4 id="section">4：例子（可能没有及时更新上最新版本）</h4>

<p>Rails 4: https://github.com/lanrion/weixin_rails_middleware_example</p>

<p>Rails 3: https://github.com/lanrion/weixin_rails_3</p>

<p>企业微信gem</p>

<p>请稳步： https://ruby-china.org/topics/22479</p>

<p>微信开发论坛：http://weixin-dev.com/</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/18439">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby gems内存泄露]]></title>
    <link href="http://helloyokoy.github.io/blog/ruby-gems-memory-leak/"/>
    <updated>2015-10-22T15:01:34+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ruby-gems-memory-leak</id>
    <content type="html"><![CDATA[<p>请大家检查下 Gemfile.lock，若在使用如下版本的gem包，那么请及时更新</p>

<ul>
  <li>
    <p>therubyracer &lt; 0.12.2</p>
  </li>
  <li>
    <p>sidekiq &lt; 3.5.1</p>
  </li>
  <li>
    <p>celluloid &gt; 0.16.0, &lt; 0.17.2</p>
  </li>
  <li>
    <p>zipruby &lt;= 0.3.6</p>
  </li>
  <li>
    <p>redcarpet &lt; 3.3.3</p>
  </li>
  <li>
    <p>grape &lt; 0.2.5</p>
  </li>
</ul>

<p><a href="https://github.com/ASoftCo/leaky-gems">https://github.com/ASoftCo/leaky-gems</a></p>
]]></content>
  </entry>
  
</feed>
