<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：ruby | BryanFu Blog]]></title>
  <link href="http://helloyokoy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://helloyokoy.github.io/"/>
  <updated>2015-11-03T15:56:49+08:00</updated>
  <id>http://helloyokoy.github.io/</id>
  <author>
    <name><![CDATA[BryanFu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[技术学习态度]]></title>
    <link href="http://helloyokoy.github.io/blog/tech-learn/"/>
    <updated>2015-11-03T15:23:49+08:00</updated>
    <id>http://helloyokoy.github.io/blog/tech-learn</id>
    <content type="html"><![CDATA[<p>本文仅谈业余时间的技术学习，不谈工作中的要求。</p>

<p>技术固然要时时学习，因为更新快嘛，但对待技术上学什么，怎么花时间学，需要一个指导思想，否则浪费时间而且效果不好。</p>

<ol>
  <li>
    <p>抓住主干，而非细节
最近很火的一句话是“你不要用战术上的勤奋掩盖战略上的懒惰”。放到技术学习上就先主理解主干后关注枝叶，比如C++的好书很多，《Effective C++》和《Inside C++ Object Model》是好书，但它们都不是用来入门的，为什么? 因为它们不是主干，语言实现细节和各种坑你都了解了，碰到实际问题依然用不好C++。</p>
  </li>
  <li>
    <p>尽量不折腾
不去折腾那些不成熟的技术，尽量用较为成熟的技术。在一年多之前，我用AngularJS，MongoDB的时候把我可给坑惨了，所以我下决心如果不因为工作坚决不碰Go语言，Node.js，要学不如学Erlang。新技术应用场景不清晰，前景不清晰，生态环境弱，类库少，坑多不容易跳出来。简而言之就是风险大于收益。同理我也不喜欢用Linux而喜欢Mac，Vim的包也是别人弄好了直接install的。</p>
  </li>
</ol>

<!--more-->

<ol>
  <li>
    <p>尽量学习经典原理而不是浪费时间在细节上。
这一点条和第一点类似，多花时间学习抽象模式，设计原则，类型系统，看诸如《SICP》《The little schemer》《Essential of Programming Language》这种书，如果不是因为工作绝不浪费时间到《Dive into python》这种具体到语言细节的书上。</p>
  </li>
  <li>
    <p>尽量学习形而下的系统而不过多上升到形而上的思想上。上一点谈到了抽象模式和类型系统，但切不可单纯从思想上判断哪种语言一定好，哪种抽象模式就一定好，一定要结合形而下的系统综合看待，学习C语言就要随着OS学习，学习Lisp就随着编译器或分析器一起学习，学习Ruby或Python就跟着web开发来学习，通过某一类系统架构理解语言的优劣，通过语言来理解为何这么架构系统。</p>
  </li>
  <li>
    <p>学好那些通用技能。
比如：1，如何进行Debug，2，如何阅读源代码，3，如何进行基本性能监控，4，熟练用好自己的编辑器和*nix命令行，5，git技巧，6，项目管理能力，7，关系型数据库的知识。</p>
  </li>
</ol>

<hr />
<p>转载自 <a href="http://liusihao.com/post/64854832920/%E6%88%91%E5%AF%B9%E5%BE%85%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%81%E5%BA%A6">我对技术的态度</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wechat 开发环境搭建]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-develop-environment/"/>
    <updated>2015-10-29T15:46:09+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-develop-environment</id>
    <content type="html"><![CDATA[<p>由于微信开发都是在微信内浏览器运行，不管是登陆还是支付都不能在PC开发端愉快地玩耍，但世界我们还是需要拯救的。</p>

<p>由于自己换了新电脑，第一次做微信开发跟大家分享一下我的开发环境，欢迎拍砖交流。</p>

<p>一般的第三方开发永远离不开两个配置，域名 &amp; 回调，有一些平台支持localhost的域名&amp;回调会方便，更有支持随意更改端口的，微信上面貌似都没有 。</p>

<p>好了，假定我们的域名是playmonkey.me</p>

<h2 id="section">域名</h2>

<p>微信登陆，JSAPI以及支付都有域名限制，所以需要让手机微信上打开palymonkey.me时，访问到我们本地的development server。</p>

<p>干这个勾当的当属 Charles 神器。</p>

<!--more-->

<p>下载安装打开Charles
Proxy -&gt; Proxy Setting -&gt; Http Proxy勾选Enable…. 开启http proxy代理，端口默认是8888
Tool -&gt; DNS Spoofing Settings 勾选Enable DNS Spoofing
然后把palymonkey.me加到DNS Spoofs，指向本机127.0.0.1
Charles好了，下一步配置手机，确保你的手机网络和电脑在同一局域网，配置手机的HTTP代理到电脑的IP上，端口8888；</p>

<p>访问http://playmonkey.me；</p>

<p>什么？挂了？当然，酱紫访问的是本地的80端口。</p>

<p>好了，我们再来用 Nginx 反向代理搞定这个问题，让手机端的playmonkey.me访问到本地development server的3000端口上。</p>

<p>首先安装启动Nginx，用Apache的朋友对不起了，你们要自食其力XD</p>

<p>配置Nginx</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;server {</span>
</span><span class='line'><span class="sr">      listen 80;</span>
</span><span class='line'><span class="sr">      server_name playmonkey.me;</span>
</span><span class='line'><span class="sr">      charset utf-8;</span>
</span><span class='line'><span class="sr">      location /</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">proxy_pass</span>          <span class="ss">http</span><span class="p">:</span><span class="sr">//mon</span><span class="n">key_servers</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_redirect</span>      <span class="n">default</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Forwarded</span><span class="o">-</span><span class="no">For</span> <span class="vg">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="n">X</span><span class="o">-</span><span class="no">Real</span><span class="o">-</span><span class="no">IP</span> <span class="vg">$remote_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_set_header</span>    <span class="no">Host</span> <span class="vg">$http_host</span><span class="p">;</span>
</span><span class='line'>        <span class="n">proxy_next_upstream</span> <span class="n">http_502</span> <span class="n">http_504</span> <span class="n">error</span> <span class="n">timeout</span> <span class="n">invalid_header</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;  }</span>
</span><span class='line'>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">upstream palymonkey_servers{</span>
</span><span class='line'><span class="sr">  server 127.0.0.1:3000;</span>
</span><span class='line'><span class="sr">}</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>再用手机访问http://playmonkey.me ，Nice….这回看到页面了。
到此我们可以在微信上用playmonkey.me访问本地的dev server，可以愉快地调用JSAPI &amp; 微信oauth登陆 &amp; 发起支付。</p>

<p>噢，如果做的是PC端的oauth微博登录怎么办？ 在本地host加上 127.0.0.1 palymonkey.com。Nice XD、</p>

<h2 id="section-1">异步回调</h2>

<p>上面说到发起支付，微信的支付结果是通过异步回调的，所以需要做内网穿透，这里推荐两个工具 ngrok OR localtunnel</p>

<p>localtunnel</p>

<p>localtunnel 是node写的，用起来非常简单</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>npm install -g localtunnel
</span><span class='line'><span class="nv">$ </span>lt –port 3000
</span><span class='line'>your url is: https://gqgh.localtunnel.me&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>这样外网打开https://gqgh.localtunnel.me 就可以访问到本地的3000端口</p>

<p>但是localtunnel是国外的，公司网络刚刚搭好，经常不稳定果断抛弃转入ngrok；</p>

<p>ngrok（不想折腾的可以忽略XD）</p>

<p>悲催的是ngrok也是国外的，而且服务器给墙了，BUT，问题不大，我们可以pull ngrok 1.X的源码自己编译，2.0会报证书错误如果没有合法的https证书。</p>

<p>好了我们来编译ngrok，噢，对了，ngrok是Go写的，编译出来直接是一个可执行文件，爽歪歪有木有，哈~</p>

<p>在服务器端（每家都有一只staging服务器吧）</p>

<p>NGROK_DOMAIN 设置为您自己拥有的域名，并指向Ngrok server运行的服务器</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'>git clone https://github.com/inconshreveable/ngrok.git
</span><span class='line'><span class="nb">cd </span>ngrok&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;openssl genrsa -out rootCA.key 2048
</span><span class='line'>openssl req -x509 -new -nodes -key rootCA.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -days <span class="m">5000</span> -out rootCA.pem
</span><span class='line'>openssl genrsa -out device.key 2048
</span><span class='line'>openssl req -new -key device.key -subj “/CN<span class="o">=</span><span class="nv">$NGROK_DOMAIN</span>” -out device.csr
</span><span class='line'>openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;cp rootCA.pem assets/client/tls/ngrokroot.crt
</span><span class='line'><span class="c"># make clean</span>
</span><span class='line'>make release-server release-client&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>编译完有两个可执行文件 bin/ngrok &amp; bin/ngrokd 
将bin/ngrok copy到你本机
在服务器上开启ngrok server</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;bin/ngrokd -tlsKey<span class="o">=</span>device.key -tlsCrt<span class="o">=</span>device.crt -domain<span class="o">=</span>”<span class="nv">$NGROK_DOMAIN</span>” -httpAddr<span class="o">=</span>”:8000” -httpsAddr<span class="o">=</span>”:8001”&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>本地端</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;NGROK_DOMAIN<span class="o">=</span>”my.domain.com”
</span><span class='line'><span class="nb">echo</span> -e “server_addr: <span class="nv">$NGROK_DOMAIN</span>:4443<span class="se">\n</span>trust_host_root_certs: <span class="nb">false</span>” <span class="p">&amp;</span>gt<span class="p">;</span> ngrok-config
</span><span class='line'>./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span>playmonkey <span class="m">3000</span> // 配置subdomain到本地3000端口，这样外网通过playmonkey.NGROK_DOMAIN 就可以访问到本地dev server的3000端口&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>或者用SSH forwarding</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./ngrok -config<span class="o">=</span>ngrok-config -subdomain<span class="o">=</span><span class="m">3000</span> –proto<span class="o">=</span>tcp 22&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>以上Ngrok编译&amp;配置出自 <a href="https://gist.github.com/lyoshenka/002b7fbd801d0fd21f2f">How to setup Ngrok with a self-signed SSL cert</a></p>

<p>至此我们在发起微信支付时回调URL的HOST就可以设置为playmonkey.NGROK_DOMAIN</p>

<p>至此我们可以愉快地开发测试 微信的oauth登录 &amp; JSAPI &amp; 支付 &amp; 支付回调，好吧，很多BUG一点都不愉快。
另外感谢 <a href="https://ruby-china.org/ruby_sky">@ruby_sky</a> 的这篇 <a href="https://ruby-china.org/topics/26138">微信支付文章</a> 微信支付做起来如丝般顺滑；
内微信文档看起来太蛋疼了，各种配置也是找半天，大家有兴趣我可以总结一下微信各个开发的各种配置XD。</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/26443">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信开发 gems]]></title>
    <link href="http://helloyokoy.github.io/blog/wechat-gems/"/>
    <updated>2015-10-27T15:35:10+08:00</updated>
    <id>http://helloyokoy.github.io/blog/wechat-gems</id>
    <content type="html"><![CDATA[<p>最近陆续有不少用Rails开发微信项目的朋友在Github上开始使用weixin_rails_middleware、weixin_authorize，也不少人谈到Ratchet，春节开始到现在，一直有做微信的开发，现在在论坛上发布出来，希望让更多人知道这些gem的存在，更快速的完成你们手中的任务。</p>

<p>有问题可以前往：微信开发论坛：http://weixin-dev.com/</p>

<p>代码写得不好，还请多多包涵，如果有任何问题，可以直接联系我。:)</p>

<!--more-->

<h4 id="rails">1:一（两）条命令搭建Rails微信版本</h4>

<p>按照最简洁的速度，10分钟可以跑起一个微信的项目：
https://github.com/lanrion/weixin_rails_middleware</p>

<p>自动验证微信请求；
一（两）条命令，一个配置，简练风格；
支持Rails 3, Rails 4；
支持多公众账号平台，例如类似微盟；
支持单个用户，即一个账号，但又不想保存在数据库；
提供回复消息辅助方法；
提供所有微信消息类型的业务逻辑的回复处理；
wiki 中提供自定义菜单中的实现案例；
自动生成token；
详细见：</p>

<p>https://github.com/lanrion/weixin_rails_middleware/wiki/</p>

<p>wiki中也有不少关于开发上的建议与经验，还有自己遇到一些奇葩的问题</p>

<p>https://github.com/lanrion/weixin_rails_middleware</p>

<h4 id="api">2：微信高级API实现：</h4>

<p>https://github.com/lanrion/weixin_authorize</p>

<p>除 Oauth 2 未实现，其他API均已实现；
支持Redis存储access_token；
还是直接看wiki 吧：</p>

<p>https://github.com/lanrion/weixin_authorize/wiki/Getting-Started
wiki中也有不少关于开发上的建议与经验，还有自己遇到一些奇葩的问题</p>

<h4 id="ratchet-v201gem-twitterratchetrails">3：集成Ratchet v2.0.1的gem: twitter_ratchet_rails</h4>

<p>即：http://goratchet.com/ 压缩后非常小，十分适合wap使用，但有一个不足之处在于，组件不够丰富，期待更丰富的实现
没其他多余的好说，看官直接点击：</p>

<p>https://github.com/lanrion/twitter_ratchet_rails</p>

<p>小弟身材弱小，砖别拍的太猛，嘿，把我拍死了，就没人维护这三个gem了。:)</p>

<h4 id="section">4：例子（可能没有及时更新上最新版本）</h4>

<p>Rails 4: https://github.com/lanrion/weixin_rails_middleware_example</p>

<p>Rails 3: https://github.com/lanrion/weixin_rails_3</p>

<p>企业微信gem</p>

<p>请稳步： https://ruby-china.org/topics/22479</p>

<p>微信开发论坛：http://weixin-dev.com/</p>

<hr />
<p>转载自 <a href="https://ruby-china.org/topics/18439">ruby-china</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby gems内存泄露]]></title>
    <link href="http://helloyokoy.github.io/blog/ruby-gems-memory-leak/"/>
    <updated>2015-10-22T15:01:34+08:00</updated>
    <id>http://helloyokoy.github.io/blog/ruby-gems-memory-leak</id>
    <content type="html"><![CDATA[<p>请大家检查下 Gemfile.lock，若在使用如下版本的gem包，那么请及时更新</p>

<ul>
  <li>
    <p>therubyracer &lt; 0.12.2</p>
  </li>
  <li>
    <p>sidekiq &lt; 3.5.1</p>
  </li>
  <li>
    <p>celluloid &gt; 0.16.0, &lt; 0.17.2</p>
  </li>
  <li>
    <p>zipruby &lt;= 0.3.6</p>
  </li>
  <li>
    <p>redcarpet &lt; 3.3.3</p>
  </li>
  <li>
    <p>grape &lt; 0.2.5</p>
  </li>
</ul>

<p><a href="https://github.com/ASoftCo/leaky-gems">https://github.com/ASoftCo/leaky-gems</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotion简介]]></title>
    <link href="http://helloyokoy.github.io/blog/rubymotion/"/>
    <updated>2015-10-15T15:52:38+08:00</updated>
    <id>http://helloyokoy.github.io/blog/rubymotion</id>
    <content type="html"><![CDATA[<h2 id="rubymotion-">RubyMotion 是什么</h2>
<p><img src="https://ruby-china-files.b0.upaiyun.com/photo/2015/aa191c47356e1b30b1f1a7d7e82fea3c.gif" alt="icon" /></p>

<h2 id="section">统一的运行时环境</h2>
<p>在 iOS 以及 OS X 系统之上，RubyMotion 基于 Objective-C Runtime 和 Foundation 类实现了 Ruby 语言。 在 Andorid 系统之上，RubyMotion 基于 Android Java Runtime，Dalvik 以及 ART 实现了 Ruby 语言。由于这种异常紧密的集成，Ruby 可以自如的调用各平台的接口而不会产生任何性能损失。你可以轻松自如的混编 Ruby 和 Objective-C 或者 Ruby 和 Java，自由的访问各平台提供的最新的 API，自由调用各种第三方库。</p>

<h2 id="section-1">完全编译</h2>

<p>RubyMotion 使用基于 LLVM 构建(参见原理)的革命性的、先进的预编译器（AOT Complier）将项目中的 Ruby 代码编译成经过优化的机器代码。在 iOS 以及 Android 项目，编译器可以生成 32 位和 64 位的 ARM 目标代码，在 OS X 项目则可以生成 32 位和 64 位的 Intel 目标代码。原始的 Ruby 代码不会出现在程序中，也不会在运行期间被解释执行。RubyMotion 的典型项目的程序包大小在 1MB 以下。</p>

<h2 id="section-2">自动管理内存</h2>

<p>在 Ruby 语言中，你无需考虑内存管理事宜。因为，RubyMotion 会自动释放内存中那些你创建的但是却不再会被使用的对象。针对 iOS 和 OS X 平台，我们提供了一个自定义的内存模型，在设计上类似 Objective-C 的 ARC 机制。这个模型无需再使用额外内存或者代码来处理不再使用的对象的声明和回收。针对 Android 平台，我们使用 Java 运行时环境的 GC 来管理内存。</p>

<!--more-->

<h2 id="section-3">支持并行</h2>

<p>绝大斗数 Android 设备以及最新的 iOS 和 OS X 硬件都支持多核处理器。所以在设计应用程序时，考虑到支持并发是非常重要的。RubyMotion 被设计成没有全局锁且是可重入的（re-entrant），主要目的就是可以让代码并行的执行。针对 iOS 和 OS X 平台，RubyMotion 为 Grand Central Dispatch 提供了方便的接口，你可以自如的使用 CPU 核心来平衡需要大量计算的任务。</p>

<h2 id="rubymotion">要不要选择 RubyMotion</h2>

<p>如果你喜欢 Ruby，当然你需要来尝试 RubyMotion，并且你会爱上他。并且，选择 RubyMotion 意味着你可以像开发 Rails 应用一样使用 Rake 工具链，同时又不会放弃 AutoLayout 等原生开发时必须的技术。你可以使用来自人类希望的 JetBrains 出品的 RubyMine，也可以使用 SublimeText 或者 VIM(Emacs)。你会看到类似 Rails 的文件组织结构。作为一个 Rails 开发者，你会感到所有的开发环境都是如此的令人感到熟悉。一个人，凭借 Ruby 实现真正意义上的全端全栈，似乎指日可待啊～</p>

<h2 id="section-4">社区发展</h2>

<p>RubyMotion 存在已经第四个年头，所以目前是一个稳定的项目。由于之前没有提供免费试用版，所以造成好多人想去学习，却因为感觉到相对昂贵的价格而止步不前。现在不用了，快去 <a href="http://www.rubymotion.com/download/">http://www.rubymotion.com/download/</a> 下载免费版把玩吧……</p>

<p>在社区发展方面，社区贡献了非常多的 Gems。得益于 Ruby 强大的 DSL 生成能力和元编程特性，非常多的 Gems 对原生开发冗余的编程模型和繁杂的 API 调用做了非常好的封装。<a href="http://motion-toolbox.com/">http://motion-toolbox.com/</a> 里面收录了绝大多数优质的 RubyMotion 的 Gems。</p>

<h2 id="section-5">相关资料</h2>

<p><a href="https://ruby-china.org/topics/22416">RubyMotion Workshop Beijing 资料总结</a></p>

<p><a href="http://www.rubymotion.com/download/">RubyMotion 官网</a></p>
]]></content>
  </entry>
  
</feed>
