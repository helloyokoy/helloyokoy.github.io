
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>IOS多线程 - BryanFu Blog</title>
	<meta name="author" content="BryanFu">

	
	<meta name="description" content="在这篇文章中，我将为你整理一下 iOS 开发中几种多线程方案，以及其使用方法和注意事项。当然也会给出几种多线程的案例，在实际使用中感受它们的区别。还有一点需要说明的是，这篇文章将会使用 Swift 和 Objective-c 两种语言讲解，双语幼儿园。OK，let&rsquo;t begin! &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="BryanFu Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript">

function addBlankTargetForLinks () {

  $('a[href^="http"]').each(function(){

      $(this).attr('target', '_blank');

  });

}

$(document).bind('DOMNodeInserted', function(event) {

  addBlankTargetForLinks();

});

</script>
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">BryanFu Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:helloyokoy.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/helloyokoy" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:helloyokoy.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">IOS多线程</h2>
	<div class="entry-content"><blockquote><p>在这篇文章中，我将为你整理一下 iOS 开发中几种多线程方案，以及其使用方法和注意事项。当然也会给出几种多线程的案例，在实际使用中感受它们的区别。还有一点需要说明的是，这篇文章将会使用 Swift 和 Objective-c 两种语言讲解，双语幼儿园。OK，let&rsquo;t begin!</p></blockquote>

<h2>概述</h2>

<hr />

<p>这篇文章中，我不会说多线程是什么、线程和进程的区别、多线程有什么用，当然我也不会说什么是串行、什么是并行等问题，这些我们应该都知道的。</p>

<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>

<pre><code>Pthreads
NSThread
GCD
NSOperation &amp; NSOperationQueue
</code></pre>

<p>所以接下来，我会一一讲解这些方案的使用方法和一些案例。在将这些内容的时候，我也会顺带说一些多线程周边产品。比如： 线程同步、 延时执行、 单例模式 等等。</p>

<h3>Pthreads</h3>

<p>其实这个方案不用说的，只是拿来充个数，为了让大家了解一下就好了。百度百科里是这么说的：</p>

<p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。</p>

<p>简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于 c语言 的框架，使用起来这酸爽！感受一下：</p>

<p>OBJECTIVE-C</p>

<p>当然第一步要包含头文件</p>

<pre><code>#import
</code></pre>

<p>然后创建线程，并执行任务</p>

<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
pthread_t thread;
//创建一个线程并自动执行
pthread_create(&amp;thread, NULL, start, NULL);
}
void *start(void *data) {
NSLog(@"%@", [NSThread currentThread]);
return NULL;
}
</code></pre>

<p>打印输出：</p>

<pre><code>2015-07-27 23:57:21.689 testThread[10616:2644653] {number = 2, name = (null)}
</code></pre>

<p>看代码就会发现他需要 c语言函数，这是比较蛋疼的，更蛋疼的是你需要手动处理线程的各个状态的转换即管理生命周期，比如，这段代码虽然创建了一个线程，但并没有销毁。</p>

<p>SWIFT</p>

<p>很遗憾，在我目前的 swift1.2 中无法执行这套方法，原因是这个函数需要传入一个函数指针 CFunctionPointer类型，但是目前 swift 无法将方法转换成此类型。听说 swift 2.0 引入一个新特性 @convention&copy;, 可以完成 Swift 方法转换成 c 语言指针的。在这里可以看到</p>

<p>那么，Pthreads 方案的多线程我就介绍这么多，毕竟做 iOS 开发几乎不可能用到。但是如果你感兴趣的话，或者说想要自己实现一套多线程方案，从底层开始定制，那么可以去搜一下相关资料。</p>

<h3>NSThread</h3>

<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法。</p>

<h5>创建并启动</h5>

<p>先创建线程类，再启动
OBJECTIVE-C</p>

<pre><code>// 创建
NSThread *thread = [[NSThread alloc] initWithTarget:self    selector:@selector(run:) object:nil];
// 启动
[thread start];
</code></pre>

<p>SWIFT</p>

<pre><code>//创建
let thread = NSThread(target: self, selector: "run:", object: nil)
//启动
thread.start()
</code></pre>

<h5>创建并自动启动</h5>

<p>OBJECTIVE-C</p>

<pre><code>[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];
</code></pre>

<p>SWIFT</p>

<pre><code>NSThread.detachNewThreadSelector("run:", toTarget: self, withObject: nil)
</code></pre>

<p>使用 NSObject 的方法创建并自动启动</p>

<p>OBJECTIVE-C</p>

<pre><code>[self performSelectorInBackground:@selector(run:) withObject:nil];
</code></pre>

<p>SWIFT</p>

<p>很遗憾 too! 苹果认为 performSelector: 不安全，所以在 Swift 去掉了这个方法。</p>

<pre><code>Note: The performSelector: method and related selector-invoking methods are not imported in Swift because they are inherently unsafe.
</code></pre>

<h5>其他方法</h5>

<p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法大家可以去类的定义里去看。</p>

<p>OBJECTIVE-C</p>

<pre><code>//取消线程
- (void)cancel;
//启动线程
- (void)start;
//判断某个线程的状态的属性
@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isCancelled) BOOL cancelled;
//设置和获取线程名字
-(void)setName:(NSString *)n;
-(NSString *)name;
//获取当前线程信息
+ (NSThread *)currentThread;
//获取主线程信息
+ (NSThread *)mainThread;
//使当前线程暂停一段时间，或者暂停到某个时刻
+ (void)sleepForTimeInterval:(NSTimeInterval)time;
+ (void)sleepUntilDate:(NSDate *)date;
</code></pre>

<p>SWIFT</p>

<p>Swift的方法名字和OC的方法名都一样，我就不浪费空间列举出来了。</p>

<p>其实，NSThread 用起来也挺简单的，因为它就那几种方法。同时，我们也只有在一些非常简单的场景才会用 NSThread, 毕竟它还不够智能，不能优雅地处理多线程中的其他高级概念。所以接下来要说的内容才是重点。</p>

<h3>GCD</h3>

<p>Grand Central Dispatch，听名字就霸气。它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案，老少咸宜，实在是居家旅行、杀人灭口，必备良药。不好意思，有点中二，咱们继续。</p>

<h5>任务和队列</h5>

<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。</p>

<p>任务：即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： 同步执行 和 异步执行，他们之间的区别是 是否会创建新的线程。
同步执行：只要是同步执行的任务，都会在当前线程执行，不会另开线程。</p>

<p>异步执行：只要是异步执行的任务，都会另开线程，在别的线程执行。</p>

<p>更新：</p>

<p>这里说的并不准确，同步（sync） 和 异步（async） 的主要区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕！</p>

<p>如果是 同步（sync） 操作，它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行。</p>

<p>如果是 异步（async）操作，当前线程会直接往下执行，它不会阻塞当前线程。</p>

<p>队列：用于存放任务。一共有两种队列， 串行队列 和 并行队列。
串行队列 中的任务会根据队列的定义 FIFO 的执行，一个接一个的先进先出的进行执行。</p>

<p>更新：放到串行队列的任务，GCD 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。</p>

<p>并行队列 中的任务根据同步或异步有不同的执行方式。虽然很绕，但请看下表：</p>

<p>更新：放到串行队列的任务，GCD 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，GCD 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。</p>

<h5>创建队列</h5>

<p>主队列：这是一个特殊的 串行队列。什么是主队列，大家都知道吧，它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。</p>

<p>  //OBJECTIVE-C
  dispatch_queue_t queue = ispatch_get_main_queue();
  //SWIFT
  let queue = ispatch_get_main_queue()
自己创建的队列：凡是自己创建的队列都是 串行队列。其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空。大家可以看xcode的文档查看参数意义。
更新：自己可以创建 串行队列, 也可以创建 并行队列。看下面的代码（代码已更新），它有两个参数，第一个上面已经说了，第二个才是最重要的。
第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>

<pre><code>//OBJECTIVE-C
dispatch_queue_t queue = dispatch_queue_create("tk.bourne.testQueue", NULL);
//SWIFT
let queue = dispatch_queue_create("tk.bourne.testQueue", nil);
</code></pre>

<p>全局并行队列：这应该是唯一一个并行队列，只要是并行任务一般都加入到这个队列。</p>

<pre><code>//OBJECTIVE-C
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//SWIFT
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
</code></pre>

<h5>创建任务</h5>

<p>同步任务：不会另开线程 (SYNC)</p>

<p>OBJECTIVE-C</p>

<pre><code>dispatch_sync(, ^{
  //code here
  NSLog(@"%@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>dispatch_sync(, { () -&gt; Void in
  //code here
  println(NSThread.currentThread())
})
</code></pre>

<p>异步任务：会另开线程 (ASYNC)</p>

<p>OBJECTIVE-C</p>

<pre><code>dispatch_async(, ^{
  //code here
  NSLog(@"%@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>dispatch_async(, { () -&gt; Void in
  //code here
  println(NSThread.currentThread())
})
</code></pre>

<p>更新：</p>

<p>为了更好的理解同步和异步，和各种队列的使用，下面看两个示例：</p>

<p>示例一：</p>

<p>以下代码在主线程调用，结果是什么？</p>

<pre><code>NSLog("之前 - %@", NSThread.currentThread())
dispatch_sync(dispatch_get_main_queue(), { () -&gt; Void in 
    NSLog("sync - %@", NSThread.currentThread())
})
NSLog("之后 - %@", NSThread.currentThread())
</code></pre>

<p>答案：</p>

<p>只会打印第一句：之前 - {number = 1, name = main} ，然后主线程就卡死了，你可以在界面上放一个按钮，你就会发现点不了了。</p>

<p>解释：</p>

<p>同步任务会阻塞当前线程，然后把 Block 中的任务放到指定的队列中执行，只有等到 Block 中的任务完成后才会让当前线程继续往下运行。</p>

<p>那么这里的步骤就是：打印完第一句后，dispatch_sync 立即阻塞当前的主线程，然后把 Block 中的任务放到 main_queue 中，可以 main_queue 中的任务会被取出来放到主线程中执行，但主线程这个时候已经被阻塞了，所以 Block 中的任务就不能完成，它不完成，dispatch_sync 就会一直阻塞主线程，这就是死锁现象。导致主线程一直卡死。</p>

<p>示例二：</p>

<p>以下代码会产生什么结果？</p>

<pre><code>let queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL)
    NSLog("之前 - %@", NSThread.currentThread())
    dispatch_async(queue, { () -&gt; Void in
    NSLog("sync之前 - %@", NSThread.currentThread())
    dispatch_sync(queue, { () -&gt; Void in
         NSLog("sync - %@", NSThread.currentThread())
    })
    NSLog("sync之后 - %@", NSThread.currentThread())
    })
NSLog("之后 - %@", NSThread.currentThread())
</code></pre>

<p>答案：</p>

<pre><code>2015-07-30 02:06:51.058 test[33329:8793087] 之前 - {number = 1, name = main}

2015-07-30 02:06:51.059 test[33329:8793356] sync之前 - {number = 2, name = (null)}

2015-07-30 02:06:51.059 test[33329:8793087] 之后 - {number = 1, name = main}
</code></pre>

<p>很明显 sync - %@ 和 sync之后 - %@ 没有被打印出来！这是为什么呢？我们再来分析一下：</p>

<p>分析：</p>

<p>我们按执行顺序一步步来哦：</p>

<p>使用 DISPATCH_QUEUE_SERIAL 这个参数，创建了一个 串行队列。
打印出 之前 - %@ 这句。
dispatch_async 异步执行，所以当前线程不会被阻塞，于是有了两条线程，一条当前线程继续往下打印出 之后 - %@这句, 另一台执行 Block 中的内容打印 sync之前 - %@ 这句。因为这两条是并行的，所以打印的先后顺序无所谓。</p>

<p>注意，高潮来了。现在的情况和上一个例子一样了。dispatch_sync同步执行，于是它所在的线程会被阻塞，一直等到 sync 里的任务执行完才会继续往下。于是 sync 就高兴的把自己 Block 中的任务放到 queue 中，可谁想 queue 是一个串行队列，一次执行一个任务，所以 sync 的 Block 必须等到前一个任务执行完毕，可万万没想到的是 queue 正在执行的任务就是被 sync 阻塞了的那个。于是又发生了死锁。所以 sync 所在的线程被卡死了。剩下的两句代码自然不会打印。
队列组</p>

<p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。下面是使用方法，这是一个很实用的功能。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建队列组
dispatch_group_t group = dispatch_group_create();
//2.创建队列
dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue, ^{
for (NSInteger i = 0; i &lt; 3; i++) {
    NSLog(@"group-01 - %@", [NSThread currentThread]);
}
});
//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue(), ^{
for (NSInteger i = 0; i &lt; 8; i++) {
    NSLog(@"group-02 - %@", [NSThread currentThread]);
}
});
//3.3.执行5次循环
dispatch_group_async(group, queue, ^{
for (NSInteger i = 0; i &lt; 5; i++) {
    NSLog(@"group-03 - %@", [NSThread currentThread]);
}
});
//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
NSLog(@"完成 - %@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建队列组
let group = dispatch_group_create()
//2.创建队列
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue) { () -&gt; Void in
for _ in 0.. Void in
for _ in 0.. Void in
for _ in 0.. Void in
NSLog("完成 - %@", NSThread.currentThread())
}
</code></pre>

<p>打印结果</p>

<pre><code>2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] 完成 - {number = 1, name = main}
</code></pre>

<p>这些就是 GCD 的基本功能，但是它的能力远不止这些，等讲完 NSOperation 后，我们再来看看它的一些其他方面用途。而且，只要你想象力够丰富，你可以组合出更好的用法。</p>

<p>更新：关于GCD，还有两个需要说的：</p>

<pre><code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法重点是你传入的 queue，当你传入的 queue 是通过 DISPATCH_QUEUE_CONCURRENT 参数自己创建的 queue 时，这个方法会阻塞这个 queue（注意是阻塞 queue ，而不是阻塞当前线程），一直等到这个 queue 中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue 中排在它后面的任务继续执行。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_async 一样了。</p>

<pre><code>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法的使用和上一个一样，传入 自定义的并发队列（DISPATCH_QUEUE_CONCURRENT），它和上一个方法一样的阻塞 queue，不同的是 这个方法还会 阻塞当前线程。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_sync 一样了。</p>

<h3>NSOperation和NSOperationQueue</h3>

<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>

<p>将要执行的任务封装到一个 NSOperation 对象中。
将此任务添加到一个 NSOperationQueue 对象中。
然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>

<h5>添加任务</h5>

<p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>

<p>NSInvocationOperation : 需要传入一个方法名。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建NSInvocationOperation对象
NSInvocationOperation *operation = [[NSInvocationOperation alloc]   initWithTarget:self selector:@selector(run) object:nil];
</code></pre>

<p>  //2.开始执行
  [operation start];
SWIFT</p>

<p>在 Swift 构建的和谐社会里，是容不下 NSInvocationOperation 这种不是类型安全的败类的。苹果如是说。这里有相关解释</p>

<p>NSBlockOperation
OBJECTIVE-C</p>

<pre><code>//1.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
  NSLog(@"%@", [NSThread currentThread]);
}];
//2.开始任务
[operation start];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建NSBlockOperation对象
let operation = NSBlockOperation { () -&gt; Void in
  println(NSThread.currentThread())
}
//2.开始任务
operation.start()
</code></pre>

<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程 执行这些任务，注意下面的打印结果：</p>

<p>OBJECTIVE-C</p>

<pre><code>  //1.创建NSBlockOperation对象
  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@"%@", [NSThread currentThread]);
  }];
  //添加多个Block
  for (NSInteger i = 0; i &lt; 5; i++) {
      [operation addExecutionBlock:^{
          NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
      }];
  }
  //2.开始任务
  [operation start];
</code></pre>

<p>SWIFT</p>

<pre><code>    //1.创建NSBlockOperation对象
    let operation = NSBlockOperation { () -&gt; Void in
        NSLog("%@", NSThread.currentThread())
    }
    //2.添加多个Block
    for i in 0.. Void in
            NSLog("第%ld次 - %@", i, NSThread.currentThread())
        }
    }
    //2.开始任务
    operation.start()
</code></pre>

<p>打印输出</p>

<pre><code>2015-07-28 17:50:16.585 test[17527:4095467] 第2次 -{number = 1, name = main}
2015-07-28 17:50:16.585 test[17527:4095666] 第1次 -{number = 4, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095665]{number = 3, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095662] 第0次 -{number = 2, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095666] 第3次 -{number = 4, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095467] 第4次 -{number = 1, name = main}
</code></pre>

<p>NOTE：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>

<pre><code>‘*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added after the operation has started executing or finished'
</code></pre>

<p>NOTE：大家可能发现了一个问题，为什么我在 Swift 里打印输出使用 NSLog() 而不是 println() 呢？原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。它会把需要输出的每个字符一个一个的输出到控制台。普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 println() 同时打印，就会导致控制台上的字符混乱的堆在一起，而NSLog() 就没有这个问题。到底是什么样子的呢？你可以把上面 NSLog() 改为 println() ，然后一试便知。</p>

<h5>自定义Operation</h5>

<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。所以这个功能提供给高级玩家，我在这里就不说了，等我需要用到时在研究它，到时候可能会再做更新。</p>

<h5>创建队列</h5>

<p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 同步执行 的。就算是 addExecutionBlock 方法，也会在 当前线程和其他线程 中执行，也就是说还是会占用当前线程。这是就要用到队列 NSOperationQueue 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 start() 方法</p>

<p>主队列</p>

<p>细心的同学就会发现，每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>

<pre><code>//OBJECTIVE-C
NSOperationQueue *queue = [NSOperationQueue mainQueue];
//SWIFT
let queue = NSOperationQueue.mainQueue()
</code></pre>

<p>其他队列
因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>

<p>注意：其他队列的任务会在其他线程并行执行。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建一个其他队列    
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
//2.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"%@", [NSThread currentThread]);
}];
//3.添加多个Block
for (NSInteger i = 0; i &lt; 5; i++) {
[operation addExecutionBlock:^{
    NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
}];
}
//4.队列添加任务
[queue addOperation:operation];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建其他队列
let queue = NSOperationQueue()
//2.创建NSBlockOperation对象
let operation = NSBlockOperation { () -&gt; Void in
NSLog("%@", NSThread.currentThread())
}
//3.添加多个Block
for i in 0.. Void in
    NSLog("第%ld次 - %@", i, NSThread.currentThread())
}
}
//4.队列添加任务
queue.addOperation(operation)
</code></pre>

<p>打印输出</p>

<pre><code>2015-07-28 20:26:28.463 test[18622:4443534]{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第2次 -{number = 2, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443535] 第0次 -{number = 4, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443533] 第1次 -{number = 3, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443534] 第3次 -{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第4次 -{number = 2, name = (null)}
</code></pre>

<p>OK, 这时应该发问了，大家将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有并行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>

<p>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛！</p>

<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>

<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.任务一：下载图片
NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"下载图片 - %@", [NSThread currentThread]);
[NSThread sleepForTimeInterval:1.0];
}];
//2.任务二：打水印
NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"打水印   - %@", [NSThread currentThread]);
[NSThread sleepForTimeInterval:1.0];
}];
//3.任务三：上传图片
NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
NSLog(@"上传图片 - %@", [NSThread currentThread]);
[NSThread sleepForTimeInterval:1.0];
}];
//4.设置依赖
[operation2 addDependency:operation1];      //任务二依赖任务一
[operation3 addDependency:operation2];      //任务三依赖任务二
//5.创建队列并加入任务
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperations:@[operation3, operation2, operation1]  waitUntilFinished:NO];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.任务一：下载图片
let operation1 = NSBlockOperation { () -&gt; Void in
NSLog("下载图片 - %@", NSThread.currentThread())
NSThread.sleepForTimeInterval(1.0)
}
//2.任务二：打水印
let operation2 = NSBlockOperation { () -&gt; Void in
NSLog("打水印   - %@", NSThread.currentThread())
NSThread.sleepForTimeInterval(1.0)
}
//3.任务三：上传图片
let operation3 = NSBlockOperation { () -&gt; Void in
NSLog("上传图片 - %@", NSThread.currentThread())
NSThread.sleepForTimeInterval(1.0)
}
//4.设置依赖
operation2.addDependency(operation1)    //任务二依赖任务一
operation3.addDependency(operation2)    //任务三依赖任务二
//5.创建队列并加入任务
let queue = NSOperationQueue()
queue.addOperations([operation3, operation2, operation1],   waitUntilFinished: false)
</code></pre>

<p>打印结果</p>

<pre><code>2015-07-28 21:24:28.622 test[19392:4637517] 下载图片 -{number = 2, name = (null)}
2015-07-28 21:24:29.622 test[19392:4637515] 打水印 -{number = 3, name = (null)}
2015-07-28 21:24:30.627 test[19392:4637515] 上传图片 -{number = 3, name = (null)}
</code></pre>

<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。
可以使用 removeDependency 来解除依赖关系。
可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。
其他方法</p>

<p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>

<pre><code>NSOperation

BOOL executing; //判断任务是否正在执行
BOOL finished; //判断任务是否完成
void (^completionBlock)(void); //用来设置完成后需要执行的操作
- (void)cancel; //取消任务
- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕
NSOperationQueue

NSUInteger operationCount; //获取队列的任务数
- (void)cancelAllOperations; //取消队列中所有的任务
- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕
[queue setSuspended:YES]; // 暂停queue
[queue setSuspended:NO]; // 继续queue
</code></pre>

<p>好啦，到这里差不多就讲完了。当然，我讲的并不完整，可能有一些知识我并没有讲到，但作为常用方法，这些已经足够了。不过我在这里只是告诉你了一些方法的功能，只是怎么把他们用到合适的地方，就需要多多实践了。下面我会说一些关于多线程的案例，是大家更加什么地了解。</p>

<h3>其他用法</h3>

<p>在这部分，我会说一些和多线程知识相关的案例，可能有些很简单，大家早都知道的，不过因为这篇文章讲的是多线程嘛，所以应该尽可能的全面嘛。还有就是，我会尽可能的使用多种方法实现，让大家看看其中的区别。</p>

<h5>线程同步</h5>

<p>所谓线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>

<p>互斥锁 ：给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。
OBJECTIVE-C</p>

<pre><code>@synchronized(self) {
//需要执行的代码块
}
SWIFT


objc_sync_enter(self)
//需要执行的代码块
objc_sync_exit(self)
</code></pre>

<p>同步执行 ：我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 GCD 和 NSOperation 两种方案，我都写出来。
OBJECTIVE-C</p>

<pre><code>//GCD
//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中
dispatch_sync(queue, ^{
  NSInteger ticket = lastTicket;
  [NSThread sleepForTimeInterval:0.1];
  NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
  ticket -= 1;
  lastTicket = ticket;
});
//NSOperation &amp; NSOperationQueue
//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中
//       2. 设置 queue 的 maxConcurrentOperationCount 为 1
//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的  waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。   waitUntilFinished 要在添加到队列之后！
 NSBlockOperation *operation = [NSBlockOperation    blockOperationWithBlock:^{
  NSInteger ticket = lastTicket;
  [NSThread sleepForTimeInterval:1];
  NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
  ticket -= 1;
  lastTicket = ticket;
}];
[queue addOperation:operation];
[operation waitUntilFinished];
//后续要做的事
</code></pre>

<p>SWIFT</p>

<p>这里的 swift 代码，我就不写了，因为每句都一样，只是语法不同而已，照着 OC 的代码就能写出 Swift 的。这篇文章已经老长老长了，我就不浪费篇幅了，又不是高中写作文。</p>

<h5>延迟执行</h5>

<p>所谓延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>

<h6>perform</h6>

<p>OBJECTIVE-C</p>

<pre><code> // 3秒后自动调用self的run:方法，并且传递参数：@"abc"
[self performSelector:@selector(run:) withObject:@"abc" afterDelay:3];
</code></pre>

<p>SWIFT</p>

<p>之前就已经说过，Swift 里去掉了这个方法。</p>

<h6>GCD</h6>

<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用，这里只写 OC 的，Swift 的是一样的。</p>

<p>OBJECTIVE-C</p>

<pre><code>// 创建队列
dispatch_queue_t queue =    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
// 设置延时，单位秒
double delay = 3; 
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
// 3秒后需要执行的任务
});
</code></pre>

<h6>NSTimer</h6>

<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法，不过这里直说延迟执行的用法。同样只写 OC 版的，Swift 也是相同的。</p>

<p>OBJECTIVE-C</p>

<pre><code>[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@"abc" repeats:NO];
</code></pre>

<h5>单例模式</h5>

<p>至于什么是单例模式，我也不多说，我只说说一般怎么实现。在 Objective-C 中，实现单例的方法已经很具体了，虽然有别的方法，但是一般都是用一个标准的方法了，下面来看看。</p>

<p>OBJECTIVE-C</p>

<pre><code>@interface Tool : NSObject
+ (instancetype)sharedTool;
@end
@implementation Tool
static id _instance;
+ (instancetype)sharedTool {
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    _instance = [[Tool alloc] init];
});
return _instance;
}
@end
</code></pre>

<p>这里之所以将单例模式，是因为其中用到了 GCD 的 dispatch_once 方法。下面看 Swift 中的单例模式，在Swift中单例模式非常简单！想知道怎么从 OC 那么复杂的方法变成下面的写法的，请看这里</p>

<p>SWIFT</p>

<pre><code>class Tool: NSObject {
static let sharedTool = Tool()
// 私有化构造方法，阻止其他对象使用这个类的默认的'()'构造方法
private override init() {}
}
</code></pre>

<h5>从其他线程回到主线程的方法</h5>

<p>我们都知道在其他线程操作完成后必须到主线程更新UI。所以，介绍完所有的多线程方案后，我们来看看有哪些方法可以回到主线程。</p>

<p>NSThread</p>

<pre><code>//Objective-C
[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
//Swift
//swift 取消了 performSelector 方法。
</code></pre>

<p>GCD</p>

<pre><code>//Objective-C
dispatch_async(dispatch_get_main_queue(), ^{
});
//Swift
dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
})
</code></pre>

<p>NSOperationQueue</p>

<pre><code>//Objective-C
[[NSOperationQueue mainQueue] addOperationWithBlock:^{
}];
//Swift
NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in
}
</code></pre>
</div>


<div class="meta">
	<div class="date">




Aug 8th, 2015</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		

		
	
      		<!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
	<span class="jiathis_txt">分享到：</span>
	<a class="jiathis_button_tools_1"></a>
	<a class="jiathis_button_tools_2"></a>
	<a class="jiathis_button_tools_3"></a>
	<a class="jiathis_button_tools_4"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    BryanFu

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'helloyokoy';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://helloyokoy.github.io/blog/2015/08/08/iosduo-xian-cheng/';
        var disqus_url = 'http://helloyokoy.github.io/blog/2015/08/08/iosduo-xian-cheng/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>